require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"js-2dmath":[function(require,module,exports){
module.exports=require('Focm2+');
},{}],"Focm2+":[function(require,module,exports){
require("./lib/math.js");

module.exports = {
    Vec2: require("./lib/vec2.js"),
    Line2: require("./lib/line2.js"),
    Segment2: require("./lib/segment2.js"),
    //geom
    Rectangle: require("./lib/rectangle.js"),
    AABB2: require("./lib/aabb2.js"),
    Circle: require("./lib/circle.js"),
    Triangle: require("./lib/triangle.js"),
    Polygon: require("./lib/polygon.js"),

    Beizer: require("./lib/beizer.js"),
    Matrix23: require("./lib/matrix23.js"),
    Matrix22: require("./lib/matrix22.js"),
    Collide: require("./lib/collide.js"),
    Intersection: require("./lib/intersection.js"),
    Transitions: require("./lib/transitions.js"),
    Xorshift: require("./lib/xorshift.js"),
    Noise: require("./lib/noise.js"),
    Draw: require("./lib/draw.js"),

    NMtree: require("./lib/nmtree.js"),

    Collision : {
        Response: require("./lib/collision/response.js"),
        GJK: require("./lib/collision/gjk.js"),
        EPA: require("./lib/collision/epa.js"),
        Manifold: require("./lib/collision/manifold.js"),
        SAT: require("./lib/collision/sat.js"),
        Resolve: require("./lib/collision/resolve.js")
    },

    NumericalIntegration: {
        RK4: require("./lib/numerical-integration/rk4.js"),
        Verlet: require("./lib/numerical-integration/verlet.js"),
        Euler: require("./lib/numerical-integration/euler.js")
    }
};

module.exports.globalize = function (object) {
    var i;
    for (i in module.exports) {
        if ("globalize" !== i) {
            object[i] = module.exports[i];
        }
    }
};


},{"./lib/aabb2.js":3,"./lib/beizer.js":4,"./lib/circle.js":5,"./lib/collide.js":6,"./lib/collision/epa.js":7,"./lib/collision/gjk.js":8,"./lib/collision/manifold.js":9,"./lib/collision/resolve.js":10,"./lib/collision/response.js":11,"./lib/collision/sat.js":12,"./lib/draw.js":14,"./lib/intersection.js":15,"./lib/line2.js":16,"./lib/math.js":17,"./lib/matrix22.js":18,"./lib/matrix23.js":19,"./lib/nmtree.js":20,"./lib/noise.js":21,"./lib/numerical-integration/euler.js":22,"./lib/numerical-integration/rk4.js":23,"./lib/numerical-integration/verlet.js":24,"./lib/polygon.js":25,"./lib/rectangle.js":26,"./lib/segment2.js":27,"./lib/transitions.js":28,"./lib/triangle.js":29,"./lib/vec2.js":30,"./lib/xorshift.js":31}],3:[function(require,module,exports){
/**
 * Stability: 1 (Only additions & fixes)
 *
 * BoundingBox2 is represented as a 5 coordinates array
 * [left: Number, bottom: Number, right: Number, top: Number, normalized: Boolean]
 */

var min = Math.min,
    max = Math.max,
    TOPLEFT = 1,
    TOPMIDDLE = 2,
    TOPRIGHT = 3,

    CENTERLEFT = 4,
    CENTER = 5,
    CENTERRIGHT = 6,

    BOTTOMLEFT = 7,
    BOTTOM = 8,
    BOTTOMRIGHT = 9,

    r = 0,
    x = 0,
    y = 0,

    min_x = 0,
    max_x = 0,
    min_y = 0,
    max_y = 0;

/**
 * @param {Number} l
 * @param {Number} b
 * @param {Number} r
 * @param {Number} t
 * @return {AABB2}
 */
function create(l, b, r, t) {
if (l == undefined || Number.isNaN(l) || 'number' !== typeof l) {
    throw new Error("l is undefined or null")
}

if (b == undefined || Number.isNaN(b) || 'number' !== typeof b) {
    throw new Error("b is undefined or null")
}

if (r == undefined || Number.isNaN(r) || 'number' !== typeof r) {
    throw new Error("r is undefined or null")
}

if (t == undefined || Number.isNaN(t) || 'number' !== typeof t) {
    throw new Error("t is undefined or null")
}

    var out = [l, b, r, t, false];
    normalize(out, out);
    return out;
}
/**
 * @param {AABB2} aabb2
 * @param {Number} x
 * @param {Number} y
 * @return {Array<AABB2>}
 */
function fromAABB2Division(aabb2, x, y) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

    var out = [],
        i,
        j,
        l = aabb2[0],
        b = aabb2[1],
        r = aabb2[2],
        t = aabb2[3],
        w = (r - l) / x,
        h = (t - b) / y;

    for (i = 0; i < x; ++i) {
        for (j = 0; j < y; ++j) {
            out.push([l + i * w, b + j * h, l + (i + 1) * w, b + (j + 1) * h]);
        }
    }

    return out;
}
/**
 * @param {Segment2} seg2
 * @return {AABB2}
 */
function fromSegment2(seg2) {
    var out = [seg2[0], seg2[1], seg2[2], seg2[3], false];
    normalize(out, out);
    return out;
}
/**
 * @param {Circle} circle
 * @return {AABB2}
 */
function fromCircle(circle) {
    r = circle[1];
    x = circle[0][0];
    y = circle[0][1];
    return create(
        x - r,
        y - r,
        x + r,
        y + r
    );
}
/**
 * @param {Rectangle} rect
 * @return {AABB2}
 */
function fromRectangle(rect) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

    var out = [rect[0][0], rect[0][1], rect[1][0], rect[1][1], false];
    normalize(out, out);
    return out;
}
/**
 * @todo implement a more robust / fast algorithm http://stackoverflow.com/questions/2587751/an-algorithm-to-find-bounding-box-of-closed-bezier-curves (Timo answer)
 *
 * @reference http://jsfiddle.net/4VCVX/3/
 *
 * @param {Beizer} beizer
 * @param {Number} npoints
 * @return {AABB2}
 */
function fromBeizer(beizer, npoints) {
if (npoints == undefined || Number.isNaN(npoints) || 'number' !== typeof npoints) {
    throw new Error("npoints is undefined or null")
}

    npoints = npoints || 40;
    var vec2_list = Beizer.get(beizer, npoints),
        i,
        l = Infinity,
        b = Infinity,
        r = -Infinity,
        t = -Infinity,
        v,
        x,
        y;

    // loop min, max
    for (i = 0; i < npoints; ++i) {
        v = vec2_list[i];

        x = v[0];
        y = v[1];

        if (x > r) {
            r = x;
        } else if (x < l) {
            l = x;
        }

        if (y < b) {
            b = y;
        } else if (y > t) {
            t = y;
        }
    }

    return [l, b, r, t, true];

}

/**
 * @return {AABB2}
 */
function zero() {
    return [0, 0, 0, 0, true];
}
/**
 * @param {AABB2} aabb2
 * @return {AABB2}
 */
function clone(aabb2) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

    return [aabb2[0], aabb2[1], aabb2[2], aabb2[3], aabb2[4]];
}
/**
 * @param {AABB2} out
 * @param {AABB2} aabb2
 * @return {AABB2}
 */
function copy(out, aabb2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid AABB2 out")
}

if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

    out[0] = aabb2[0];
    out[1] = aabb2[1];
    out[2] = aabb2[2];
    out[3] = aabb2[3];
    out[4] = aabb2[4];

    return out;
}
/**
 * @param {AABB2} out
 * @param {AABB2} aabb2
 * @param {Number} margin
 * @return {AABB2}
 */
function expand(out, aabb2, margin) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid AABB2 out")
}

if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

if (margin == undefined || Number.isNaN(margin) || 'number' !== typeof margin) {
    throw new Error("margin is undefined or null")
}

    out[0] = aabb2[0] - margin;
    out[1] = aabb2[1] - margin;
    out[2] = aabb2[2] + margin;
    out[3] = aabb2[3] + margin;

    return out;
}
/**
 * @param {AABB2} out
 * @param {AABB2} aabb2_1
 * @param {AABB2} aabb2_2
 * @return {AABB2}
 */
function merge(out, aabb2_1, aabb2_2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid AABB2 out")
}

if (!Array.isArray(aabb2_1) || aabb2_1[0] == undefined || Number.isNaN(aabb2_1[0]) || 'number' !== typeof aabb2_1[0] || aabb2_1[1] == undefined || Number.isNaN(aabb2_1[1]) || 'number' !== typeof aabb2_1[1] || aabb2_1[2] == undefined || Number.isNaN(aabb2_1[2]) || 'number' !== typeof aabb2_1[2] || aabb2_1[3] == undefined || Number.isNaN(aabb2_1[3]) || 'number' !== typeof aabb2_1[3]) {
    throw new Error("invalid AABB2 aabb2_1")
}

if (!Array.isArray(aabb2_2) || aabb2_2[0] == undefined || Number.isNaN(aabb2_2[0]) || 'number' !== typeof aabb2_2[0] || aabb2_2[1] == undefined || Number.isNaN(aabb2_2[1]) || 'number' !== typeof aabb2_2[1] || aabb2_2[2] == undefined || Number.isNaN(aabb2_2[2]) || 'number' !== typeof aabb2_2[2] || aabb2_2[3] == undefined || Number.isNaN(aabb2_2[3]) || 'number' !== typeof aabb2_2[3]) {
    throw new Error("invalid AABB2 aabb2_2")
}

    out[0] = min(aabb2_1[0], aabb2_2[0]);
    out[1] = min(aabb2_1[1], aabb2_2[1]);
    out[2] = max(aabb2_1[2], aabb2_2[2]);
    out[3] = max(aabb2_1[3], aabb2_2[3]);

    return out;
}
/**
 * @param {AABB2} out
 * @param {AABB2} aabb2_1
 * @param {AABB2} aabb2_2
 * @param {Vec2} vec2_offset
 * @return {AABB2}
 */
function offsetMerge(out, aabb2_1, aabb2_2, vec2_offset) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid AABB2 out")
}

if (!Array.isArray(aabb2_1) || aabb2_1[0] == undefined || Number.isNaN(aabb2_1[0]) || 'number' !== typeof aabb2_1[0] || aabb2_1[1] == undefined || Number.isNaN(aabb2_1[1]) || 'number' !== typeof aabb2_1[1] || aabb2_1[2] == undefined || Number.isNaN(aabb2_1[2]) || 'number' !== typeof aabb2_1[2] || aabb2_1[3] == undefined || Number.isNaN(aabb2_1[3]) || 'number' !== typeof aabb2_1[3]) {
    throw new Error("invalid AABB2 aabb2_1")
}

if (!Array.isArray(aabb2_2) || aabb2_2[0] == undefined || Number.isNaN(aabb2_2[0]) || 'number' !== typeof aabb2_2[0] || aabb2_2[1] == undefined || Number.isNaN(aabb2_2[1]) || 'number' !== typeof aabb2_2[1] || aabb2_2[2] == undefined || Number.isNaN(aabb2_2[2]) || 'number' !== typeof aabb2_2[2] || aabb2_2[3] == undefined || Number.isNaN(aabb2_2[3]) || 'number' !== typeof aabb2_2[3]) {
    throw new Error("invalid AABB2 aabb2_2")
}

if (!Array.isArray(vec2_offset) || vec2_offset[0] == undefined || Number.isNaN(vec2_offset[0]) || 'number' !== typeof vec2_offset[0] || vec2_offset[1] == undefined || Number.isNaN(vec2_offset[1]) || 'number' !== typeof vec2_offset[1]) {
    throw new Error("invalid Vec2 vec2_offset")
}

    out[0] = min(aabb2_1[0], aabb2_2[0] + vec2_offset[0]);
    out[1] = min(aabb2_1[1], aabb2_2[1] + vec2_offset[1]);
    out[2] = max(aabb2_1[2], aabb2_2[2] + vec2_offset[0]);
    out[3] = max(aabb2_1[3], aabb2_2[3] + vec2_offset[1]);

    return out;
}
/**
 * offset & scale merge
 * @param {AABB2} out
 * @param {AABB2} aabb2_1
 * @param {AABB2} aabb2_2
 * @param {Vec2} vec2_offset
 * @param {Vec2} vec2_scale
 * @return {AABB2}
 */
function osMerge(out, aabb2_1, aabb2_2, vec2_offset, vec2_scale) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid AABB2 out")
}

if (!Array.isArray(aabb2_1) || aabb2_1[0] == undefined || Number.isNaN(aabb2_1[0]) || 'number' !== typeof aabb2_1[0] || aabb2_1[1] == undefined || Number.isNaN(aabb2_1[1]) || 'number' !== typeof aabb2_1[1] || aabb2_1[2] == undefined || Number.isNaN(aabb2_1[2]) || 'number' !== typeof aabb2_1[2] || aabb2_1[3] == undefined || Number.isNaN(aabb2_1[3]) || 'number' !== typeof aabb2_1[3]) {
    throw new Error("invalid AABB2 aabb2_1")
}

if (!Array.isArray(aabb2_2) || aabb2_2[0] == undefined || Number.isNaN(aabb2_2[0]) || 'number' !== typeof aabb2_2[0] || aabb2_2[1] == undefined || Number.isNaN(aabb2_2[1]) || 'number' !== typeof aabb2_2[1] || aabb2_2[2] == undefined || Number.isNaN(aabb2_2[2]) || 'number' !== typeof aabb2_2[2] || aabb2_2[3] == undefined || Number.isNaN(aabb2_2[3]) || 'number' !== typeof aabb2_2[3]) {
    throw new Error("invalid AABB2 aabb2_2")
}

if (!Array.isArray(vec2_offset) || vec2_offset[0] == undefined || Number.isNaN(vec2_offset[0]) || 'number' !== typeof vec2_offset[0] || vec2_offset[1] == undefined || Number.isNaN(vec2_offset[1]) || 'number' !== typeof vec2_offset[1]) {
    throw new Error("invalid Vec2 vec2_offset")
}

if (!Array.isArray(vec2_scale) || vec2_scale[0] == undefined || Number.isNaN(vec2_scale[0]) || 'number' !== typeof vec2_scale[0] || vec2_scale[1] == undefined || Number.isNaN(vec2_scale[1]) || 'number' !== typeof vec2_scale[1]) {
    throw new Error("invalid Vec2 vec2_scale")
}

    out[0] = min(aabb2_1[0], (aabb2_2[0] * vec2_scale[0]) + vec2_offset[0]);
    out[1] = min(aabb2_1[1], (aabb2_2[1] * vec2_scale[1]) + vec2_offset[1]);
    out[2] = max(aabb2_1[2], (aabb2_2[2] * vec2_scale[0]) + vec2_offset[0]);
    out[3] = max(aabb2_1[3], (aabb2_2[3] * vec2_scale[1]) + vec2_offset[1]);

    return out;
}
/**
 * offset & scale merge
 * @param {AABB2} aabb2
 * @return {Number}
 */
function area(aabb2) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

    return (aabb2[2] - aabb2[0]) * (aabb2[3] - aabb2[1]);
}
/**
 * @param {AABB2} out
 * @param {AABB2} aabb2
 * @return {AABB2}
 */
function normalize(out, aabb2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid AABB2 out")
}

if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

    min_x = aabb2[0] > aabb2[2] ? aabb2[2] : aabb2[0];
    max_x = aabb2[0] > aabb2[2] ? aabb2[0] : aabb2[2];
    min_y = aabb2[1] > aabb2[3] ? aabb2[3] : aabb2[1];
    max_y = aabb2[1] > aabb2[3] ? aabb2[1] : aabb2[3];

    out[0] = min_x;
    out[1] = min_y;

    out[2] = max_x;
    out[3] = max_y;

    out[4] = true;

}
/**
 * @param {AABB2} out
 * @param {AABB2} aabb2
 * @param {Vec2} vec2
 * @return {AABB2}
 */
function translate(out, aabb2, vec2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid AABB2 out")
}

if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    x = vec2[0];
    y = vec2[1];

    out[0] = aabb2[0] + x;
    out[1] = aabb2[1] + y;
    out[2] = aabb2[2] + x;
    out[3] = aabb2[3] + y;

    return out;
}
/**
 * @param {Vec2} out_vec2
 * @param {AABB2} aabb2
 * @param {Vec2} vec2
 * @return {Vec2}
 */
function clampVec(out_vec2, aabb2, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out_vec2[0] = min(max(aabb2[0], vec2[0]), aabb2[2]);
    out_vec2[1] = min(max(aabb2[1], vec2[1]), aabb2[3]);

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {AABB2} aabb2
 */
function center(out_vec2, aabb2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

    out_vec2[0] = (aabb2[0] + aabb2[1]) * 0.5;
    out_vec2[1] = (aabb2[3] + aabb2[2]) * 0.5;

    return out_vec2;
}

/**
 * alignment values: AABB2.TOPLEFT, AABB2.TOPMIDDLE, AABB2.TOPRIGHT, AABB2.CENTERLEFT, AABB2.CENTER, AABB2.CENTERRIGHT, AABB2.BOTTOMLEFT, AABB2.BOTTOM, AABB2.BOTTOMRIGH
 *
 * @param {Vec2} out_vec2
 * @param {AABB2} aabb2
 * @param {Number} alignment
 * @return {Vec2}
 */
function align(out_vec2, aabb2, alignment) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

if (alignment == undefined || Number.isNaN(alignment) || 'number' !== typeof alignment) {
    throw new Error("alignment is undefined or null")
}

    switch (alignment) {
    case TOPLEFT:
        // do nothing!
        out_vec2[0] = aabb2[0];
        out_vec2[1] = aabb2[1];
        break;
    case TOPMIDDLE:
        out_vec2[0] = (aabb2[2] - aabb2[0]) * 0.5 + aabb2[0];
        out_vec2[1] = aabb2[1];
        break;
    case TOPRIGHT:
        out_vec2[0] = aabb2[2];
        out_vec2[1] = aabb2[1];
        break;

    case CENTERLEFT:
        out_vec2[0] = aabb2[0];
        out_vec2[1] = (aabb2[3] - aabb2[1]) * 0.5 + aabb2[1];
        break;
    case CENTER:
        out_vec2[0] = (aabb2[2] - aabb2[0]) * 0.5 + aabb2[0];
        out_vec2[1] = (aabb2[3] - aabb2[1]) * 0.5 + aabb2[1];
        break;
    case CENTERRIGHT:
        out_vec2[0] = aabb2[2];
        out_vec2[1] = (aabb2[3] - aabb2[1]) * 0.5 + aabb2[1];
        break;

    case BOTTOMLEFT:
        out_vec2[0] = aabb2[0];
        out_vec2[1] = aabb2[3];
        break;
    case BOTTOM:
        out_vec2[0] = (aabb2[2] - aabb2[0]) * 0.5 + aabb2[0];
        out_vec2[1] = aabb2[3];
        break;
    case BOTTOMRIGHT:
        out_vec2[0] = aabb2[2];
        out_vec2[1] = aabb2[3];
        break;
    }

    return out_vec2;
}
/**
 * @param {AABB2} aabb2
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function isVec2Inside(aabb2, vec2) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return aabb2[0] < vec2[0] && aabb2[2] > vec2[0] && aabb2[1] < vec2[1] && aabb2[3] > vec2[1];
}
/**
 * @param {AABB2} aabb2
 * @param {AABB2} aabb2_2
 * @return {Boolean}
 */
function isAABB2Inside(aabb2, aabb2_2) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

if (!Array.isArray(aabb2_2) || aabb2_2[0] == undefined || Number.isNaN(aabb2_2[0]) || 'number' !== typeof aabb2_2[0] || aabb2_2[1] == undefined || Number.isNaN(aabb2_2[1]) || 'number' !== typeof aabb2_2[1] || aabb2_2[2] == undefined || Number.isNaN(aabb2_2[2]) || 'number' !== typeof aabb2_2[2] || aabb2_2[3] == undefined || Number.isNaN(aabb2_2[3]) || 'number' !== typeof aabb2_2[3]) {
    throw new Error("invalid AABB2 aabb2_2")
}

    return aabb2[0] <= aabb2_2[0] &&
        aabb2[1] <= aabb2_2[1] &&
        aabb2_2[2] <= aabb2[2] &&
        aabb2_2[3] <= aabb2[3];
}
/**
 * @param {AABB2} aabb2
 * @return {Number}
 */
function perimeter(aabb2) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

    return (aabb2[2] - aabb2[0]) * 2 + (aabb2[3] - aabb2[1]) * 2;
}

/**
 * @class AABB2
 */
var AABB2 =  {
    // defines
    TOPLEFT: TOPLEFT,
    TOPMIDDLE: TOPMIDDLE,
    TOPRIGHT: TOPRIGHT,
    CENTERLEFT: CENTERLEFT,
    CENTER: CENTER,
    CENTERRIGHT: CENTERRIGHT,
    BOTTOMLEFT: BOTTOMLEFT,
    BOTTOM: BOTTOM,
    BOTTOMRIGHT: BOTTOMRIGHT,

    create: create,
    fromAABB2Division: fromAABB2Division,
    fromSegment2: fromSegment2,
    fromCircle: fromCircle,
    fromRectangle: fromRectangle,
    zero: zero,
    clone: clone,
    copy: copy,
    expand: expand,
    merge: merge,
    offsetMerge: offsetMerge,
    osMerge: osMerge,
    area: area,
    normalize: normalize,
    translate: translate,
    clampVec: clampVec,
    center: center,
    align: align,
    isVec2Inside: isVec2Inside,
    isAABB2Inside: isAABB2Inside,
    perimeter: perimeter,

    // alias
    contains: isAABB2Inside
};

module.exports = AABB2;
},{}],4:[function(require,module,exports){
/**
 * Stability: 1 (Only additions & fixes)
 *
 * @reference http://pomax.github.io/bezierinfo/
 * @reference https://github.com/jackcviers/Degrafa/blob/master/Degrafa/com/degrafa/geometry/utilities/BezierUtils.as
 * @reference http://cagd.cs.byu.edu/~557/text/ch7.pdf
 * @reference http://algorithmist.wordpress.com/2009/02/02/degrafa-closest-point-on-quad-bezier/
 * @reference http://algorithmist.wordpress.com/2009/01/26/degrafa-bezierutils-class/
*/
var sqrt = Math.sqrt,
    cl0 = 0,
    cl1 = 0,
    cl2 = 0,
    cl3 = 0,
    t1 = 0,
    t2 = 0,
    t3 = 0;

/**
 * cp0 - start point
 * cp1 - start control point
 * cp2 - end control point
 * cp3 - end point
 *
 * @param {Number} cp0x
 * @param {Number} cp0y
 * @param {Number} cp1x
 * @param {Number} cp1y
 * @param {Number} cp2x
 * @param {Number} cp2y
 * @param {Number} cp3x
 * @param {Number} cp3y
 * @return {Beizer}
 */
function cubic(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y) {
if (cp0x == undefined || Number.isNaN(cp0x) || 'number' !== typeof cp0x) {
    throw new Error("cp0x is undefined or null")
}

if (cp0y == undefined || Number.isNaN(cp0y) || 'number' !== typeof cp0y) {
    throw new Error("cp0y is undefined or null")
}

if (cp1x == undefined || Number.isNaN(cp1x) || 'number' !== typeof cp1x) {
    throw new Error("cp1x is undefined or null")
}

if (cp1y == undefined || Number.isNaN(cp1y) || 'number' !== typeof cp1y) {
    throw new Error("cp1y is undefined or null")
}

if (cp2x == undefined || Number.isNaN(cp2x) || 'number' !== typeof cp2x) {
    throw new Error("cp2x is undefined or null")
}

if (cp2y == undefined || Number.isNaN(cp2y) || 'number' !== typeof cp2y) {
    throw new Error("cp2y is undefined or null")
}

if (cp3x == undefined || Number.isNaN(cp3x) || 'number' !== typeof cp3x) {
    throw new Error("cp3x is undefined or null")
}

if (cp3y == undefined || Number.isNaN(cp3y) || 'number' !== typeof cp3y) {
    throw new Error("cp3y is undefined or null")
}

    return [[cp0x, cp0y], [cp1x, cp1y], [cp2x, cp2y], [cp3x, cp3y]];
}
/**
 * For implementation see Figure 21.2
 * @reference http://pomax.github.io/bezierinfo/
 * @todo DO IT!
 *
 * @param {Number} cp0x
 * @param {Number} cp0y
 * @param {Number} cp1x
 * @param {Number} cp1y
 * @param {Number} cp2x
 * @param {Number} cp2y
 * @return {Beizer}
 */
function from3Points(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y) {
if (cp0x == undefined || Number.isNaN(cp0x) || 'number' !== typeof cp0x) {
    throw new Error("cp0x is undefined or null")
}

if (cp0y == undefined || Number.isNaN(cp0y) || 'number' !== typeof cp0y) {
    throw new Error("cp0y is undefined or null")
}

if (cp1x == undefined || Number.isNaN(cp1x) || 'number' !== typeof cp1x) {
    throw new Error("cp1x is undefined or null")
}

if (cp1y == undefined || Number.isNaN(cp1y) || 'number' !== typeof cp1y) {
    throw new Error("cp1y is undefined or null")
}

if (cp2x == undefined || Number.isNaN(cp2x) || 'number' !== typeof cp2x) {
    throw new Error("cp2x is undefined or null")
}

if (cp2y == undefined || Number.isNaN(cp2y) || 'number' !== typeof cp2y) {
    throw new Error("cp2y is undefined or null")
}

}
/**
 * @param {Number} cp0x
 * @param {Number} cp0y
 * @param {Number} cp1x
 * @param {Number} cp1y
 * @param {Number} cp2x
 * @param {Number} cp2y
 * @return {Beizer}
 */
function quadric(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y) {
if (cp0x == undefined || Number.isNaN(cp0x) || 'number' !== typeof cp0x) {
    throw new Error("cp0x is undefined or null")
}

if (cp0y == undefined || Number.isNaN(cp0y) || 'number' !== typeof cp0y) {
    throw new Error("cp0y is undefined or null")
}

if (cp1x == undefined || Number.isNaN(cp1x) || 'number' !== typeof cp1x) {
    throw new Error("cp1x is undefined or null")
}

if (cp1y == undefined || Number.isNaN(cp1y) || 'number' !== typeof cp1y) {
    throw new Error("cp1y is undefined or null")
}

if (cp2x == undefined || Number.isNaN(cp2x) || 'number' !== typeof cp2x) {
    throw new Error("cp2x is undefined or null")
}

if (cp2y == undefined || Number.isNaN(cp2y) || 'number' !== typeof cp2y) {
    throw new Error("cp2y is undefined or null")
}

    return [[cp0x, cp0y], [cp1x, cp1y], [cp2x, cp2y]];
}
/**
 * For implementation see Figure 21.1
 * @reference http://pomax.github.io/bezierinfo/
 * @param {Number} cp0x
 * @param {Number} cp0y
 * @param {Number} cp1x
 * @param {Number} cp1y
 * @param {Number} cp2x
 * @param {Number} cp2y
 */
function quadricFrom3Points(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y) {
if (cp0x == undefined || Number.isNaN(cp0x) || 'number' !== typeof cp0x) {
    throw new Error("cp0x is undefined or null")
}

if (cp0y == undefined || Number.isNaN(cp0y) || 'number' !== typeof cp0y) {
    throw new Error("cp0y is undefined or null")
}

if (cp1x == undefined || Number.isNaN(cp1x) || 'number' !== typeof cp1x) {
    throw new Error("cp1x is undefined or null")
}

if (cp1y == undefined || Number.isNaN(cp1y) || 'number' !== typeof cp1y) {
    throw new Error("cp1y is undefined or null")
}

if (cp2x == undefined || Number.isNaN(cp2x) || 'number' !== typeof cp2x) {
    throw new Error("cp2x is undefined or null")
}

if (cp2y == undefined || Number.isNaN(cp2y) || 'number' !== typeof cp2y) {
    throw new Error("cp2y is undefined or null")
}


}
/**
 * Solves the curve (quadric or cubic) for any given parameter t.
 * @source https://github.com/hyperandroid/CAAT/blob/master/src/Math/Bezier.js
 * @param {Vec2} out_vec2
 * @param {Beizer} curve
 * @param {Number} t [0-1]
 * @return {Vec2}
 */
function solve(out_vec2, curve, t) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (t == undefined || Number.isNaN(t) || 'number' !== typeof t) {
    throw new Error("t is undefined or null")
}

    if (curve.length === 4) {
        //cubic
        t2 = t * t;
        t3 = t * t2;
        cl0 = curve[0];
        cl1 = curve[1];
        cl2 = curve[2];
        cl3 = curve[3];

        out_vec2[0] = (cl0[0] + t * (-cl0[0] * 3 + t * (3 * cl0[0] - cl0[0] * t))) +
                   t * (3 * cl1[0] + t * (-6 * cl1[0] + cl1[0] * 3 * t)) +
                   t2 * (cl2[0] * 3 - cl2[0] * 3 * t) +
                   cl3[0] * t3;
        out_vec2[1] = (cl0[1] + t * (-cl0[1] * 3 + t * (3 * cl0[1] - cl0[1] * t))) +
                   t * (3 * cl1[1] + t * (-6 * cl1[1] + cl1[1] * 3 * t)) +
                   t2 * (cl2[1] * 3 - cl2[1] * 3 * t) +
                   cl3[1] * t3;
    } else {
        // quadric

        cl0 = curve[0];
        cl1 = curve[1];
        cl2 = curve[2];
        t1 = 1 - t;

        out_vec2[0] = t1 * t1 * cl0[0] + 2 * t1 * t * cl1[0] + t * t * cl2[0];
        out_vec2[1] = t1 * t1 * cl0[1] + 2 * t1 * t * cl1[1] + t * t * cl2[1];
    }

    return out_vec2;
}
/**
 * Solve the curve npoints times and return the solution array.
 *
 * @see Polygon.fromBeizer
 *
 * @param {Beizer} curve
 * @param {Number} npoints
 * @return {Vec2[]}
 */
function getPoints(curve, npoints) {
if (npoints == undefined || Number.isNaN(npoints) || 'number' !== typeof npoints) {
    throw new Error("npoints is undefined or null")
}

    var inv_npoints = 1 / npoints,
        i,
        output = [],
        vec2;

    for (i = 0; i <= 1; i += inv_npoints) {
        vec2 = [0, 0];
        output.push(solve(vec2, curve, i));
    }

    return output;
}
/**
 * Calculate the curve length by incrementally solving the curve every substep=CAAT.Curve.k. This value defaults
 * to .05 so at least 20 iterations will be performed.
 * @todo some kind of cache maybe it's needed!
 * @param {Beizer} curve
 * @param {Number} step
 * @return {Number} the approximate curve length.
 */
function length(curve, step) {
if (step == undefined || Number.isNaN(step) || 'number' !== typeof step) {
    throw new Error("step is undefined or null")
}

    step = step || 0.05;

    var x1,
        y1,
        llength = 0,
        pt = [0, 0],
        t;

    x1 = curve[0][0];
    y1 = curve[0][1];
    for (t = step; t <= 1 + step; t += step) {
        solve(pt, curve, t);
        llength += sqrt((pt[0] - x1) * (pt[0] - x1) + (pt[1] - y1) * (pt[1] - y1));
        x1 = pt[0];
        y1 = pt[1];
    }

    return llength;
}

/**
 * credits - CAAT
 *
 * @class Beizer
 */
var Beizer = {
    cubic: cubic,
    quadric: quadric,
    solve: solve,
    length: length,
    getPoints: getPoints
};


module.exports = Beizer;
},{}],5:[function(require,module,exports){
/**
 * Stability: 1 (Only additions & fixes)
 *
 * Circle is represented as a two coordinates array
 * [c:Vec2, r:Number]
 */

var Vec2 = require("./vec2.js"),
    vec2_sub = Vec2.sub,
    vec2_distance = Vec2.distance,
    vec2_distance_sq = Vec2.distanceSq,
    vec2_midpoint = Vec2.midPoint,

    Rectangle = require("./rectangle.js"),
    rectangle_center = Rectangle.center,

    Triangle = require("./triangle.js"),
    triangle_circumcenter = Triangle.circumcenter,
    triangle_center = Triangle.center,
    triangle_abmidpoint = Triangle.abMidPoint,
    triangle_bcmidpoint = Triangle.bcMidPoint,
    triangle_camidpoint = Triangle.caMidPoint,

    max = Math.max,
    TWOPI = Math.TWOPI,
    QUATER_PI = Math.PI * 0.25,
    PI = Math.PI,
    sqrt = Math.sqrt,
    aux_vec2 = [0, 0],
    aux_num,
    aux_num2;
/**
 * @param {Number} x
 * @param {Number} y
 * @param {Number} radius
 * @return {Circle}
 */
function create(x, y, radius) {
if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

if (radius == undefined || Number.isNaN(radius) || 'number' !== typeof radius) {
    throw new Error("radius is undefined or null")
}

    return [[x, y], radius];
}
/**
 * @param {Vec2} vec2
 * @param {Number} radius
 * @return {Circle}
 */
function fromVec2(vec2, radius) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (radius == undefined || Number.isNaN(radius) || 'number' !== typeof radius) {
    throw new Error("radius is undefined or null")
}

    return [[vec2[0], vec2[1]], radius];
}
/**
 * Create a Circle with seg2 as diameter
 *
 * @param {Segment2} seg2
 * @return {Circle}
 */
function fromSegment2(seg2) {
    var out = [[0, 0], 0];

    out[0][0] = (seg2[0] + seg2[2]) * 0.5;
    out[0][1] = (seg2[1] + seg2[3]) * 0.5;

    //subtract
    aux_num = out[0][0] - seg2[0];
    aux_num2 = out[0][1] - seg2[1];
    //sqrLength
    out[1] = sqrt(aux_num * aux_num + aux_num2 * aux_num2);

    return out;
}
/**
 * @param {Rectangle} rect
 * @param {Boolean=} inside
 * @return {Circle}
 */
function fromRectangle(rect, inside) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if (inside !== undefined) {
if ('boolean' !== typeof inside) {
    throw new Error("inside is not a boolean")
}

}
    var out = [[0, 0], 0];
    rectangle_center(out[0], rect);

    if (inside) {
        aux_vec2[0] = rect[0][0] + (rect[1][0] - rect[0][0]) * 0.5;
        aux_vec2[1] = rect[0][1];

        out[1] = vec2_distance(out[0], aux_vec2);
    } else {
        out[1] = vec2_distance(out[0], rect[0]);
    }

    return out;
}
/**
 * @todo review inside cases
 * @param {Triangle} tri
 * @param {Boolean=} inside
 * @param {Boolean=} circumcenter
 * @return {Circle}
 */
function fromTriangle(tri, inside, circumcenter) {
if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

if (inside !== undefined) {
if ('boolean' !== typeof inside) {
    throw new Error("inside is not a boolean")
}

}
if (circumcenter !== undefined) {
if ('boolean' !== typeof circumcenter) {
    throw new Error("circumcenter is not a boolean")
}

}
    var out = [[0, 0], 0];

    if (circumcenter && !inside) {
        triangle_circumcenter(out[0], tri);

        // use distance^2 for comparison
        out[1] = vec2_distance_sq(out[0], tri[0]);
        aux_num = vec2_distance_sq(out[0], tri[1]);
        if (aux_num > out[1]) {
            out[1] = aux_num;
        }
        out[1] = vec2_distance_sq(out[0], tri[2]);
        if (aux_num > out[1]) {
            out[1] = aux_num;
        }
        // and now return the good one :)
        out[1] = sqrt(out[1]);

        return out;
    }

    triangle_center(out[0], tri);

    // use distance^2 for comparison
    triangle_abmidpoint(aux_vec2, tri);
    out[1] = vec2_distance_sq(out[0], aux_vec2);

    triangle_bcmidpoint(aux_vec2, tri);
    aux_num = vec2_distance_sq(out[0], aux_vec2);
    if (aux_num < out[1]) {
        out[1] = aux_num;
    }

    triangle_camidpoint(aux_vec2, tri);
    aux_num = vec2_distance_sq(out[0], aux_vec2);
    if (aux_num < out[1]) {
        out[1] = aux_num;
    }

    // and now return the good one :)
    out[1] = sqrt(out[1]);

    return out;
}

/**
 * @param {Circle} circle
 * @return {Circle}
 */
function clone(circle) {
    return [[circle[0][0], circle[0][1]], circle[1]];
}
/**
 * @param {Circle} out
 * @param {Circle} circle
 * @return {Circle}
 */
function copy(out, circle) {
    out[0][0] = circle[0][0];
    out[0][1] = circle[0][1];
    out[1] = circle[1];

    return out;
}
/**
 * @param {Circle} out
 * @param {Circle} circle
 * @param {Vec2} vec2
 * @return {Circle}
 */
function translate(out, circle, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out[0][0] = circle[0][0] + vec2[0];
    out[0][1] = circle[0][1] + vec2[1];
    out[1] = circle[1];

    return out;
}
/**
 * @param {Circle} out
 * @param {Circle} circle
 * @param {Vec2} vec2
 * @return {Circle}
 */
function moveTo(out, circle, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out[0][0] = vec2[0];
    out[0][1] = vec2[1];
    out[1] = circle[1];

    return out;
}
/**
 * @param {Circle} circle
 * @param {Circle} circle_2
 * @return {Number}
 */
function distance(circle, circle_2) {
    return max(0, vec2_distance(circle[0], circle_2[0]) - circle[1] - circle_2[1]);
}
/**
 * @param {Circle} circle
 * @return {Number}
 */
function length(circle) {
    return TWOPI * circle[1];
}
/**
 * @param {Circle} circle
 * @return {Number}
 */
function area(circle) {
    return PI * circle[1] * circle[1];
}
/**
 * @param {Circle} circle
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function isVec2Inside(circle, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return vec2_distance(circle[0], vec2) < circle[1];
}
/**
 * @param {Vec2} out_vec2
 * @param {Circle} circle
 * @param {Vec2} vec2
 * @return {Vec2}
 */
function closestPoint(out_vec2, circle, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    //const Vector& P, const Vector& Centre, float radius, bool* inside)
    vec2_sub(out_vec2, vec2 - cirlce[0]);

    var dist2 = vec2_length(out_vec2);

    // is inside? (dist2 <= radius * radius);

    //if(dist2 > EPS) Delta /= sqrt(dist2);

    vec2_scale(out_vec2, out_vec2, scale);
    vec2_add(out_vec2, cirlce[0], scale);

    return out_vec2;
}

/**
 * @param {Circle} circle
 * @param {Number} mass
 */
function momentOfInertia(circle, mass) {
if (mass == undefined || Number.isNaN(mass) || 'number' !== typeof mass) {
    throw new Error("mass is undefined or null")
}

    var r = circle[1];
    return mass * r * r * 0.5;

}

/**
 * @class Circle
 */
var Circle = {
    create: create,
    fromVec2: fromVec2,
    fromSegment2: fromSegment2,
    fromRectangle: fromRectangle,
    fromTriangle: fromTriangle,
    clone: clone,
    copy: copy,
    translate: translate,
    moveTo: moveTo,
    distance: distance,
    length: length,
    area: area,
    isVec2Inside: isVec2Inside,

    //physics
    momentOfInertia: momentOfInertia,

    // alias
    perimeter: length,
    move: moveTo
};


module.exports = Circle;
},{"./rectangle.js":26,"./triangle.js":29,"./vec2.js":30}],6:[function(require,module,exports){
/**
 * Stability: 0 (Anything could happen)
 *
 * This need revision.
 * **inside:Boolean** param must be added to all functions
 * *Note** this not return the contact points, use intersections for that.
 *
 * @source http://members.gamedev.net/oliii/satpost/SpherePolygonCollision.cpp
 */

var Vec2 = require("./vec2.js"),
    vec2_distance = Vec2.distance,
    vec2_distance_sq = Vec2.distanceSq,
    vec2_midpoint = Vec2.midPoint,
    vec2_$near = Vec2.$near,
    vec2_sub = Vec2.sub,
    vec2_dot = Vec2.dot,

    Segment2 = require("./segment2.js"),
    Segment2_$closestPoint = Segment2.$closestPoint,

    aux_vec2 = [0, 0],
    ca = [0, 0],
    ba = [0, 0],
    pa = [0, 0],

    EPS = Math.EPS = 0.001;

/**
 * @param {Number} num
 * @param {Number} num2
 * @param {Number} dist
 */
function _near(num, num2, dist) {
if (num == undefined || Number.isNaN(num) || 'number' !== typeof num) {
    throw new Error("num is undefined or null")
}

if (num2 == undefined || Number.isNaN(num2) || 'number' !== typeof num2) {
    throw new Error("num2 is undefined or null")
}

if (dist == undefined || Number.isNaN(dist) || 'number' !== typeof dist) {
    throw new Error("dist is undefined or null")
}

    return num > num2 - dist && num < num2 + dist;
}

/**
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Number} x3
 * @param {Number} y3
 */
function _rectangle_vec2(x1, y1, x2, y2, x3, y3) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

if (x3 == undefined || Number.isNaN(x3) || 'number' !== typeof x3) {
    throw new Error("x3 is undefined or null")
}

if (y3 == undefined || Number.isNaN(y3) || 'number' !== typeof y3) {
    throw new Error("y3 is undefined or null")
}

    return (x1 > x3 || x2 < x3 || y1 > y3 || y2 < y3) ? false : true;
}
/**
 * @param {AABB2} bb2
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function bb2_vec2(bb2, vec2) {
if (!Array.isArray(bb2) || bb2[0] == undefined || Number.isNaN(bb2[0]) || 'number' !== typeof bb2[0] || bb2[1] == undefined || Number.isNaN(bb2[1]) || 'number' !== typeof bb2[1] || bb2[2] == undefined || Number.isNaN(bb2[2]) || 'number' !== typeof bb2[2] || bb2[3] == undefined || Number.isNaN(bb2[3]) || 'number' !== typeof bb2[3]) {
    throw new Error("invalid AABB2 bb2")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return _rectangle_vec2(bb2[0], bb2[1], bb2[2], bb2[3], vec2[0], vec2[1]);
}
/**
 * @param {Vec2} vec2
 * @param {AABB2} bb2
 * @return {Boolean}
 */
function vec2_bb2(vec2, bb2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (!Array.isArray(bb2) || bb2[0] == undefined || Number.isNaN(bb2[0]) || 'number' !== typeof bb2[0] || bb2[1] == undefined || Number.isNaN(bb2[1]) || 'number' !== typeof bb2[1] || bb2[2] == undefined || Number.isNaN(bb2[2]) || 'number' !== typeof bb2[2] || bb2[3] == undefined || Number.isNaN(bb2[3]) || 'number' !== typeof bb2[3]) {
    throw new Error("invalid AABB2 bb2")
}

    return _rectangle_vec2(bb2[0], bb2[1], bb2[2], bb2[3], vec2[0], vec2[1]);
}
/**
 * @param {Rectangle} rect
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function rectangle_vec2(rect, vec2) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var tl = rect[0], br = rect[1];
    return _rectangle_vec2(tl[0], tl[1], br[0], br[1], vec2[0], vec2[1]);
}
/**
 * @param {Vec2} vec2
 * @param {Rectangle} rect
 * @return {Boolean}
 */
function vec2_rectangle(vec2, rect) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

    var tl = rect[0], br = rect[1];
    return _rectangle_vec2(tl[0], tl[1], br[0], br[1], vec2[0], vec2[1]);
}

/**
 * @param {Segment2} seg2
 * @param {Vec2} vec2
 * @benchmark
 * @return {Boolean}
 */
function segment2_vec2(seg2, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var x = vec2[0],
        y = vec2[1];

    Segment2_$closestPoint(aux_vec2, seg2[0], seg2[1], seg2[2], seg2[3], x, y);

    return vec2_$near(aux_vec2[0], aux_vec2[1], x, y);
}
/**
 * @param {Vec2} vec2
 * @param {Segment2} seg2
 * @return {Boolean}
 */
function vec2_segment2(vec2, seg2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return segment2_vec2(seg2, vec2);
}
/**
 * @param {Vec2} vec2
 * @param {Line2} line2
 * @return {Boolean}
 */
function vec2_line2(vec2, line2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    //return _near(vec2[1], line2[1] * vec2[0] - line2[0][1]);
    var p = line2[0];
    return _near(line2[1], (vec2[1] - p[1]) / (vec2[0] - p[0]), EPS);
}

/**
 * @param {Line2} line2
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function line2_vec2(line2, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    //return _near(vec2[1], line2[1] * vec2[0] - line2[0][1]);
    var p = line2[0];
    return _near(line2[1], (vec2[1] - p[1]) / (vec2[0] - p[0]), EPS);
}



/**
 * @param {Circle} circle_1
 * @param {Circle} circle_2
 * @return {Boolean}
 */
function circle_circle(circle_1, circle_2) {
    strict = strict || false;

    var // Determine minimum and maximum radius where circles can intersect
        r_max = circle_1[1] + circle_2[1],
        // Determine actual distance between circle circles
        c_dist_sq = Vec2.distanceSq(circle_1[0], circle_2[0]);

    if (c_dist_sq > r_max * r_max) {
        return false;
    }

    return true;
}

/**
 * @param {Circle} circle
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function circle_vec2(circle, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var distance_to_center = vec2_distance_sq(circle[0], vec2),
        r = circle[1],
        r2 = r * r;

    return distance_to_center <= r2;
}
/**
 * @param {Vec2} vec2
 * @param {Circle} circle
 * @return {Boolean}
 */
function vec2_circle(vec2, circle) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    circle_vec2(circle, vec2);
}
/**
 * @param {Triangle} tri
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function triangle_vec2(tri, vec2) {
if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    // Compute vectors
    ca = vec2_sub(tri[2], tri[0]); // v0 = C - A
    ba = vec2_sub(tri[1], tri[0]); // v1 = B - A
    pa = vec2_sub(vec2, tri[0]); // v2 = P - A

    // Compute dot products
    var dot00 = vec2_dot(ca, ca); //dot00 = dot(v0, v0)
    var dot01 = vec2_dot(ca, ba); //dot01 = dot(v0, v1)
    var dot02 = vec2_dot(ca, pa); //dot02 = dot(v0, v2)
    var dot11 = vec2_dot(ba, ba); //dot11 = dot(v1, v1)
    var dot12 = vec2_dot(ba, pa); //dot12 = dot(v1, v2)

    // Compute barycentric coordinates
    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // Check if point is in triangle
    return (u >= 0) && (v >= 0) && (u + v < 1);

}
/**
 * @param {Vec2} vec2
 * @param {Triangle} tri
 * @return {Boolean}
 */
function vec2_triangle(vec2, tri) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    return triangle_vec2(tri, vec2)
}

/**
 * @param {Vec2} vec2
 * @param {Vec2} vec2_2
 * @return {Boolean}
 */
function vec2_vec2(vec2, vec2_2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (!Array.isArray(vec2_2) || vec2_2[0] == undefined || Number.isNaN(vec2_2[0]) || 'number' !== typeof vec2_2[0] || vec2_2[1] == undefined || Number.isNaN(vec2_2[1]) || 'number' !== typeof vec2_2[1]) {
    throw new Error("invalid Vec2 vec2_2")
}

    return _near(vec2[0], vec2_2[0], EPS) &&
        _near(vec2[1], vec2_2[1], EPS);
}

var Collide = {
    circle_circle: circle_circle,

    //
    // vec2 against the world!
    //
    bb2_vec2: bb2_vec2,
    vec2_bb2: vec2_bb2,

    rectangle_vec2: rectangle_vec2,
    vec2_rectangle: vec2_rectangle,

    segment2_vec2: segment2_vec2,
    vec2_segment2: vec2_segment2,

    circle_vec2: circle_vec2,
    vec2_circle: vec2_circle,

    vec2_line2: vec2_line2,
    line2_vec2: line2_vec2,

    triangle_vec2: triangle_vec2,
    vec2_triangle: vec2_triangle,

    vec2_vec2: vec2_vec2,
};

module.exports = Collide;

/*
var primitives = ["circle", "rectangle", "vec2", "line2", "segment2", "bb2", "triangle"],
    i,
    j,
    fn;
for (i = 0; i < primitives.length; ++i) {
    for (j = 0; j < primitives.length; ++j) {
        fn = primitives[i] + "_" + primitives[j];
        if (!Collisions[fn]) {
            console.log("todo: Collisions.", fn);
        }
    }

}

console.log(vec2_line2([1, 1], [[0,0], 1]));
console.log(vec2_line2([1, 2], [[0,0], 2]));

*/
},{"./segment2.js":27,"./vec2.js":30}],7:[function(require,module,exports){
/**
 * @reference http://www.codezealot.org/archives/180
 * @reference https://github.com/LSFN/dyn4go/blob/383474ee3924d626a1c106bc717f07deb76b9635/collision/narrowphase/EPA.go
 * @reference https://github.com/BrandonLittell/PinballGL/blob/d2678f0e916cdb8b8a234243feeda03a196e5bc8/Group3_FinalProject/Collision.cpp
 */

var Vec2 = require("../vec2.js"),
    vec2_sub = Vec2.sub,
    vec2_cross = Vec2.cross,
    vec2_tripleProduct = Vec2.tripleProduct,
    vec2_normalize = Vec2.normalize,
    vec2_dot = Vec2.dot,
    Polygon = require("../polygon.js"),
    clear = require("./response.js").clear,
    polygon_furthestMinkowski = Polygon.furthestMinkowski;

var gw_aux = [0, 0];
var gw_aux2 = [0, 0];
/**
 * @param {Polygon} simplex
 * @return {Number}
 */
function _getWinding(simplex) {
    vec2_sub(gw_aux, simplex[1], simplex[0]);
    vec2_sub(gw_aux2, simplex[2], simplex[1]);
    return vec2_cross(gw_aux, gw_aux2);


    var len = simplex.length,
        i = 0,
        j,
        f;

    for (; i < len; ++i) {
        j = i + 1;
        if (j === len) {
            j = 0;
        }
        f = vec2_cross(simplex[i], simplex[j]);

        if (f > 0) {
            return 1;
        } else if (f < 0) {
            return -1;
        }
    }
    return 0;
}

var edge = [0, 0];
/**
 * @param {Polygon} simplex
 * @param {Number} winding
 */
function _findClosestEdge(simplex, winding) {
if (winding == undefined || Number.isNaN(winding) || 'number' !== typeof winding) {
    throw new Error("winding is undefined or null")
}

    // prime the distance of the edge to the max
    var distance = Infinity,
        a,
        i,
        j,
        d,
        n = [0, 0],
        normal = [0, 0],
        index,
        len = simplex.length,
        lenm1 = len - 1;

    // simplex is the passed in simplex
    for (i = 0; i < len; i++) {
        // compute the next points index
        j = i === lenm1 ? 0 : i + 1;
        // get the current point and the next one
        a = simplex[i];
        // b = simplex[j];
        // create the edge vector
        vec2_sub(edge, simplex[j], a); // or a.to(b);
        // console.log("edge", edge, "@", i, j, a, simplex[j]);
        // get the vector from the origin to a
        //Vector oa = a; // or a - ORIGIN

        // get the vector from the edge towards the origin
        //vec2_tripleProduct(n, edge, a, edge);
        //----------------------------------------------------------------------
        // @llafuente: winding method seems to be more reliable to find MTV
        if (winding > 0) {
            Vec2.rotateCW(n, edge);
        } else {
            Vec2.rotateCCW(n, edge);
        }
        // normalize the vector
        //----------------------------------------------------------------------

        vec2_normalize(n, n);
        // console.log("tripleProduct", n, edge, a, edge);
        // calculate the distance from the origin to the edge
        d = vec2_dot(a, n); // could use b or a here
        // check the distance against the other distances
        // console.log("d = a.dot(n) =", d, distance);
        if (d < distance) {
            // if this edge is closer then use it
            distance = d;
            normal[0] = n[0];
            normal[1] = n[1];
            index = j;
        }
    }
    // return the closest edge we found
    return {
        distance: distance,
        normal: normal,
        index: index,
    };
}

/**
 * @TODO the current implementation has no max iterations, but seems to work review edge cases
 *
 * @param {Response} out_response
 * @param {Polygon} A
 * @param {Polygon} B
 * @param {Polygon} simplex result of GJK
 */
function EPA(out_response, A, B, simplex) {
    //simplex = [[4, 2], [-8, -2], [-1, -2]];
    clear(out_response);

    var edge,
        depth,
        p,
        winding = _getWinding(simplex);
    console.log("winding", winding);

    //redo the simplex
    if (winding <= 0) {
        simplex.reverse();
    }

    // loop to find the collision information
    while (true) {
        // console.log("***************************", Polygon.toString(simplex));
        // obtain the feature (edge for 2D) closest to the origin on the Minkowski Difference
        edge = _findClosestEdge(simplex, winding);
        // console.log("_findClosestEdge", edge);
        // obtain a new support point in the direction of the edge normal
        p = polygon_furthestMinkowski([0, 0], A, B, edge.normal);
        // check the distance from the origin to the edge against the
        // distance p is along edge.normal
        depth = vec2_dot(p, edge.normal);
        // console.log(max, "distance", depth, edge.distance);
        if (depth - edge.distance < Math.EPS) {
            // the tolerance should be something positive close to zero (ex. 0.00001)

            // if the difference is less than the tolerance then we can
            // assume that we cannot expand the simplex any further and
            // we have our solution
            out_response.mtv = edge.normal;
            out_response.depth = depth;

            return true;
        } else {
            // we haven't reached the edge of the Minkowski Difference
            // so continue expanding by adding the new point to the simplex
            // in between the points that made the closest edge
            // console.log(simplex[edge.index], p);
            simplex.splice(edge.index, 0, p);
        }
    }
}


module.exports = EPA;

},{"../polygon.js":25,"../vec2.js":30,"./response.js":11}],8:[function(require,module,exports){
/**
*
* Copyright (c) 2013 Jasper Palfree http://wellcaffeinated.net/PhysicsJS/
*
* Adapted and optimized by Luis Lafuente <llafuente@noboxout.com>
*
* @todo stress test
* @source https://github.com/wellcaffeinated/PhysicsJS
* @reference https://github.com/felipetavares/bomberman/blob/master/web/modules/collision.js
* @reference http://www.codezealot.org/archives/88
* @reference http://mollyrocket.com/849
*/


// the algorithm doesn't always converge for curved shapes.
// need these constants to dictate how accurate we want to be.
var EPS = Math.EPS,
    abs = Math.abs,
    gjkMaxIterations = 100,
    Vec2 = require("../vec2.js"),
    vec2_lengthSq = Vec2.lengthSq,
    vec2_dot = Vec2.dot,
    vec2_negate = Vec2.negate,
    vec2_sub = Vec2.sub,
    vec2_perp = Vec2.perp,
    vec2_rperp = Vec2.rperp,
    vec2_copy = Vec2.copy,
    vec2_near = Vec2.near,
    vec2_ZERO = Vec2.ZERO,
    vec2_scale = Vec2.scale,
    vec2_add = Vec2.add,
    vec2_normalize = Vec2.normalize,
    vec2_swap = Vec2.swap,
    vec2_cross = Vec2.cross,
    Polygon = require("../polygon.js");

// get the next search direction from two simplex points
/**
 * @param {Vec2} ptA
 * @param {Vec2} ptB
 * @param {Vec2} dir
 */
function _getNextSearchDir(ptA, ptB, dir) {
if (!Array.isArray(ptA) || ptA[0] == undefined || Number.isNaN(ptA[0]) || 'number' !== typeof ptA[0] || ptA[1] == undefined || Number.isNaN(ptA[1]) || 'number' !== typeof ptA[1]) {
    throw new Error("invalid Vec2 ptA")
}

if (!Array.isArray(ptB) || ptB[0] == undefined || Number.isNaN(ptB[0]) || 'number' !== typeof ptB[0] || ptB[1] == undefined || Number.isNaN(ptB[1]) || 'number' !== typeof ptB[1]) {
    throw new Error("invalid Vec2 ptB")
}

if (!Array.isArray(dir) || dir[0] == undefined || Number.isNaN(dir[0]) || 'number' !== typeof dir[0] || dir[1] == undefined || Number.isNaN(dir[1]) || 'number' !== typeof dir[1]) {
    throw new Error("invalid Vec2 dir")
}


    var ABdotB = vec2_lengthSq(ptB) - vec2_dot(ptB, ptA),
        ABdotA = vec2_dot(ptB, ptA) - vec2_lengthSq(ptA);

    // if the origin is farther than either of these points
    // get the direction from one of those points to the origin
    if (ABdotB < 0) {
        return vec2_negate(dir, ptB);
    } else if (ABdotA > 0) {
        return vec2_negate(dir, ptA);
    // otherwise, use the perpendicular direction from the simplex
    }

    // dir = AB = B - A
    vec2_sub(dir, ptB, ptA);
    // if (left handed coordinate system)
    // A cross AB < 0 then get perpendicular counterclockwise
    //return dir.perp( (ptA.cross( dir ) > 0) );
    return vec2_perp(dir, dir);
}


var gcp_A = [0, 0],
    gcp_L = [0, 0],
    gcp_aux = [0, 0];

/** hide
* _getClosestPoints( simplex ) -> Object
* - simplex (Array): The simplex
*
* Figure out the closest points on the original objects
* from the last two entries of the simplex
* @param {Polygon} simplex
* @return {Object}
**/
function _getClosestPoints(simplex) {

    // see http://www.codezealot.org/archives/153
    // for algorithm details

    // we know that the position of the last point
    // is very close to the previous. (by nature of the distance test)
    // this won't give great results for the closest
    // points algorithm, so let's use the previous two
    var len = simplex.length,
        last = simplex[len - 2],
        prev = simplex[len - 3],
        lambdaB,
        lambdaA;

    vec2_copy(gcp_A, last);

    // L = B - A
    vec2_sub(gcp_L, prev, gcp_A);

    if (vec2_near(gcp_L, vec2_ZERO, EPS)) {
        // oh.. it's a zero vector. So A and B are both the closest.
        // just use one of them
        return {
            a: last.a,
            b: last.b
        };
    }

    lambdaB = - vec2_dot(gcp_L, gcp_A) / vec2_lengthSq(gcp_L);
    lambdaA = 1 - lambdaB;

    if (lambdaA <= 0) {
        // woops.. that means the closest simplex point
        // isn't on the line it's point B itself
        return {
            a: prev.a,
            b: prev.b
        };
    } else if (lambdaB <= 0) {
        // vice versa
        return {
            a: last.a,
            b: last.b
        };
    }

    // guess we'd better do the math now...
    var a = [0, 0],
        b = [0, 0];

    vec2_scale(a, last.a, lambdaA);
    vec2_scale(gcp_aux, prev.a, lambdaB);
    vec2_add(a, a, gcp_aux);

    vec2_scale(b, last.b, lambdaA);
    vec2_scale(gcp_aux, prev.b, lambdaB);
    vec2_add(b, b, gcp_aux);

    return {
        // a closest = lambdaA * Aa + lambdaB * Ba
        a: a,
        // b closest = lambdaA * Ab + lambdaB * Bb
        b: b
    };
}

/**
*
* Implementation of GilbertJohnsonKeerthi (GJK)
*
*
* Returned object
*
* ```javascript
* {
*   overlap: Boolean,
*   simplex: Polygon,
*   distance: Number,
*   closest: Vec2
* }
* ```
* @todo distance seem to be not 100% right
* @param {Polygon} a_points
* @param {Polygon} b_points
* @return {Object}
**/
function getPolygonPolygon(a_points, b_points) {

    var overlap = false,
        noOverlap = false, // if we're sure we're not overlapping
        distance = false,
        simplex = [],
        simplexLen = 1,
        // use seed as starting direction or use x axis
        dir = [0, 1],
        last = [0, 0],
        lastlast = [0, 0],
        // some temp vectors
        ab,
        ac,
        sign,
        tmp,
        iterations = 0,
        dead = [],
        deadlen;

    // get the first Minkowski Difference point
    //tmp = support(dir);
    tmp = Polygon.furthestMinkowski([0, 0], a_points, b_points, dir);
    simplexLen = simplex.push(tmp);
    vec2_copy(last, tmp);
    // negate d for the next point
    vec2_negate(dir, dir);

    //console.log("simplex", Polygon.toString(simplex));

    // start looping
    gjk_end:
    while (++iterations) {

        // swap last and lastlast, to save on memory/speed
        vec2_swap(last, lastlast);
        // push a new point to the simplex because we haven't terminated yet
        //tmp = support(dir);
        tmp = Polygon.furthestMinkowski([0, 0], a_points, b_points, dir);
        simplexLen = simplex.push(tmp);
        vec2_copy(last, tmp);

        //<debug>
        //Draw.polygon(ctx, simplex, "rgba(255, 0, 0, 0.1)", true);
        //console.log("simplex", iterations, Polygon.toString(simplex), "last", Vec2.toString(last));
        //@TODO history!
        //</debug>

        // @TODO experimental, seems to work, confirm it!
        if (dead.length) {
            deadlen = dead.length - 1;
            while (deadlen--) {
                if (dead[deadlen][0] === last[0] && dead[deadlen][1] === last[1]) {
                    break gjk_end;
                }
            }
        }


        if (vec2_near(last, vec2_ZERO, EPS)) {
            // we happened to pick the origin as a support point... lucky.
            overlap = true;
            break;
        }

        // check if the last point we added actually passed the origin
        if (!noOverlap && vec2_dot(last, dir) <= 0.0) {
            // if the point added last was not past the origin in the direction of d
            // then the Minkowski difference cannot possibly contain the origin since
            // the last point added is on the edge of the Minkowski Difference

            noOverlap = true;
        }

        // if it's a line...
        if (simplexLen === 2) {

            // otherwise we need to determine if the origin is in
            // the current simplex and act accordingly

            dir = _getNextSearchDir(last, lastlast, dir);
            // continue...

        // if it's a triangle... and we're looking for the distance
        } else if (noOverlap) {

            // if we know there isn't any overlap and
            // we're just trying to find the distance...
            // make sure we're getting closer to the origin
            vec2_normalize(dir, dir);
            tmp = vec2_dot(lastlast, dir);

            if (abs(tmp - vec2_dot(last, dir)) < EPS) {
                distance = -tmp;
                break;
            }

            // if we are still getting closer then only keep
            // the points in the simplex that are closest to
            // the origin (we already know that last is closer
            // than the previous two)
            // the norm is the same as distance(origin, a)
            // use norm squared to avoid the sqrt operations
            if (vec2_lengthSq(lastlast) < vec2_lengthSq(simplex[0])) {
                dead.push(simplex.shift());
            } else {
                dead.push(simplex.splice(1, 1)[0]);
            }

            dir = _getNextSearchDir(simplex[1], simplex[0], dir);
            // continue...

        // if it's a triangle
        } else {

            // we need to trim the useless point...

            ab = ab || [0, 0];
            ac = ac || [0, 0];

            // get the edges AB and AC
            vec2_sub(ab, lastlast, last);
            vec2_sub(ac, simplex[0], last);

            // here normally people think about this as getting outward facing
            // normals and checking dot products. Since we're in 2D
            // we can be clever...
            sign = vec2_cross(ab, ac) > 0;

            if (sign ^ (vec2_cross(last, ab) > 0)) {

                // ok... so there's an XOR here... don't freak out
                // remember last = A = -AO
                // if AB cross AC and AO cross AB have the same sign
                // then the origin is along the outward facing normal of AB
                // so if AB cross AC and A cross AB have _different_ (XOR) signs
                // then this is also the case... so we proceed...

                // point C is dead to us now...
                dead.push(simplex.shift());

                // if we haven't deduced that we've enclosed the origin
                // then we know which way to look...
                // morph the ab vector into its outward facing normal

                //ab.perp( !sign );
                //// swap
                //dir.swap( ab );

                sign ? vec2_perp(dir, ab) : vec2_rperp(dir, ab);


                // continue...

                // if we get to this if, then it means we can continue to look along
                // the other outward normal direction (ACperp)
                // if we don't see the origin... then we must have it enclosed
            } else if (sign ^ (vec2_cross(ac, last) > 0)) {
                // then the origin is along the outward facing normal
                // of AC; (ACperp)

                // point B is dead to us now...
                dead.push(simplex.splice(1, 1)[0]);

                //ac.perp( sign );
                //// swap
                //dir.swap( ab );

                sign ? vec2_rperp(dir, ac) : vec2_perp(dir, ac);

                // continue...

            } else {

                // we have enclosed the origin!
                overlap = true;
                // fewf... take a break
                break;
            }
        }

        // woah nelly... that's a lot of iterations.
        // Stop it!
        if (iterations > gjkMaxIterations) {
            return {
                simplex: simplex,
                iterations: iterations,
                distance: 0,
                maxIterationsReached: true
            };
        }
    }

    tmp = {
        overlap: overlap,
        simplex: simplex,
        iterations: iterations
    };

    if (distance !== false) {

        tmp.distance = distance;
        tmp.closest = _getClosestPoints(simplex);
    }

    return tmp;
}

module.exports = {
    getPolygonPolygon: getPolygonPolygon
};
},{"../polygon.js":25,"../vec2.js":30}],9:[function(require,module,exports){
/**
 * @todo NORMALIZE OUTPUT
 */
var Vec2 = require("../vec2.js"),
    Polygon = require("../polygon.js"),
    polygon_furthestPoint = Polygon.furthestPoint,
    sqrt = Math.sqrt,
    abs = Math.abs,
    vec2_sub = Vec2.sub,
    vec2_add = Vec2.add,
    vec2_clone = Vec2.clone,
    vec2_dot = Vec2.dot,
    vec2_scale = Vec2.scale,
    vec2_negate = Vec2.negate,
    vec2_normalize = Vec2.normalize,
    vec2_perp = Vec2.perp,
    vec2_lengthSq = Vec2.lengthSq,
    vec2_div = Vec2.div;

var l = [0, 0],
    r = [0, 0],
    v = [0, 0];

/**
 * Find the separating edge for the given direction
 * @param {Polygon} polygon
 * @param {Vec2} n normal
 */
function _findSeparationEdge(polygon, n) {
if (!Array.isArray(n) || n[0] == undefined || Number.isNaN(n[0]) || 'number' !== typeof n[0] || n[1] == undefined || Number.isNaN(n[1]) || 'number' !== typeof n[1]) {
    throw new Error("invalid Vec2 n")
}


    // Compute farthest polygon point in particular direction.
    var index = polygon_furthestPoint(v, polygon, n);

    var index_prev = (index + polygon.length - 1) % polygon.length;
    var index_next = (index + 1) % polygon.length;

    var v_prev = vec2_clone(polygon[index_prev]);
    var v_next = vec2_clone(polygon[index_next]);
    vec2_sub(l, v, v_next);
    vec2_sub(r, v, v_prev);

    if (vec2_dot(r, n) <= vec2_dot(l, n)) {
        return [v_prev, vec2_clone(v)];
    }

    return [vec2_clone(v), v_next];
}

var delta = [0, 0],
    _p = [0, 0];
/**
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @param {Vec2} n
 * @param {Number} o
 */
function _clipLineSegment(v1, v2, n, o) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

if (!Array.isArray(n) || n[0] == undefined || Number.isNaN(n[0]) || 'number' !== typeof n[0] || n[1] == undefined || Number.isNaN(n[1]) || 'number' !== typeof n[1]) {
    throw new Error("invalid Vec2 n")
}

if (o == undefined || Number.isNaN(o) || 'number' !== typeof o) {
    throw new Error("o is undefined or null")
}

    var d1 = vec2_dot(n, v1) - o;
    var d2 = vec2_dot(n, v2) - o;
    var cp = [];

    if (d1 >= 0) {
        cp.push(v1);
    }

    if (d2 >= 0) {
        cp.push(v2);
    }

    if (d1 * d2 < 0) {
        vec2_sub(delta, v2, v1);
        var p = vec2_add([0, 0], v1, vec2_scale(_p, delta, d1 / (d1 - d2)));
        cp.push(p);
    }

    return cp;
}
var ccp_nn = [0, 0],
    e1d = [0, 0],
    e2d = [0, 0],
    ref_n = [0, 0],
    ref_nn = [0, 0],
    ref_perp = [0, 0];
/**
 * @source https://github.com/juhl/collision-detection-2d
 * @param {Polygon} a_points
 * @param {Polygon} b_points
 * @param {Vec2} n normal
 * @return {Object}
 */
function EdgeClipping(a_points, b_points, n) {
if (!Array.isArray(n) || n[0] == undefined || Number.isNaN(n[0]) || 'number' !== typeof n[0] || n[1] == undefined || Number.isNaN(n[1]) || 'number' !== typeof n[1]) {
    throw new Error("invalid Vec2 n")
}

    var e1 = _findSeparationEdge(a_points, n);
    vec2_negate(ccp_nn, n);
    var e2 = _findSeparationEdge(b_points, ccp_nn);


    vec2_sub(e1d, e1[1], e1[0]);
    vec2_sub(e2d, e2[1], e2[0]);

    var ref;
    var inc;
    var flip;

    // The reference edge is the edge most perpendicular to the separation normal.
    // So as to separate both polygons as little as possible.
    var en1 = abs(vec2_dot(e1d, n));
    var en2 = abs(vec2_dot(e2d, n));
    if (en1 <= en2) {
        ref = e1;
        vec2_normalize(ref_n, e1d);
        inc = e2;
        flip = false;
    } else {
        ref = e2;
        vec2_normalize(ref_n, e2d);
        inc = e1;
        flip = true;
    }

    // Clip incident edge vertices using reference edge v1
    var o1 = vec2_dot(ref_n, ref[0]);
    var v = _clipLineSegment(inc[0], inc[1], ref_n, o1);
    if (v.length < 2) {
        return null;
    }

    // Clip incident edge vertices using reference edge v2
    var o2 = vec2_dot(ref_n, ref[1]);
    vec2_negate(ref_nn, ref_n);
    v = _clipLineSegment(v[0], v[1], ref_nn, -o2);
    if (v.length < 2) {
        return null;
    }

    vec2_perp(ref_perp, ref_n);

    if (flip) {
        vec2_negate(ref_perp, ref_perp);
    }

    var cp = [];
    var max = vec2_dot(ref_perp, ref[0]);
    var depth0 = vec2_dot(ref_perp, v[0]) - max;
    var depth1 = vec2_dot(ref_perp, v[1]) - max;

    if (depth0 >= 0) {
        cp.push({point: vec2_clone(v[0]), normal: vec2_clone(n), depth: -depth0});
    }

    if (depth1 >= 0) {
        cp.push({point: vec2_clone(v[1]), normal: vec2_clone(n), depth: -depth1});
    }

    return { contacts: cp, incident_edge: inc, reference_edge: ref };
}


var cc_n = [0, 0];
/**
 * @source http://www.randygaul.net/2013/03/28/custom-physics-engine-part-2-manifold-generation/
 * @param {Circle} a_circle
 * @param {Circle} b_circle
 */
function CircleCircle(a_circle, b_circle) {
    // Setup a couple pointers to each object

    // Vector from A to B
    vec2_sub(cc_n, b_circle[0], a_circle[0]);

    var r = b_circle[1] + a_circle[1];
    r *= r;

    var length_sq = vec2_lengthSq(cc_n);
    if (length_sq > r) {
        return false;
    }

    // Circles have collided, now compute manifold
    var d = sqrt(length_sq); // perform actual sqrt

    // If distance between circles is not zero
    if (d !== 0) {
        // Distance is difference between radius and distance
        var normal = vec2_div([0, 0], cc_n, d);
        var position = vec2_scale([0, 0], normal * a_circle[1]);
        vec2_add(position, position, a_circle[0]);

        return {
            penetration: r - d,
            position: position,
            normal: normal
        };
    }

    // Circles are on same position
    // Choose random (but consistent) values
    return {
        position: a_circle[0],
        penetration: a_circle[1],
        normal: [1, 0]
    };
}

/*
EdgeClipping(
    [[8, 4], [14, 4], [8, 10], [14, 10]],
    [[12, 5], [4, 5], [12, 0], [4, 0]],
    [0, -1]
);

process.exit();
*/
module.exports = EdgeClipping;


module.exports = {
    EdgeClipping: EdgeClipping,
    CircleCircle: CircleCircle,


    // alias
    PolygonPolygon: EdgeClipping
};

},{"../polygon.js":25,"../vec2.js":30}],10:[function(require,module,exports){
var Vec2 = require("../vec2.js"),
    vec2_scale = Vec2.scale,
    vec2_dot = Vec2.dot,
    vec2_sub = Vec2.sub,
    abs = Math.abs,
    max = Math.max,
    sqrt = Math.sqrt,
    atan2 = Math.atan2,
    cos = Math.cos,
    sin = Math.sin,
    HALF_PI = Math.HALF_PI;

var mtv_v = [0, 0];
/**
 * Keep your object outside the other
 *
 * @param {Vec2} out_position
 * @param {Vec2} out_velocity
 * @param {Number} penetration_depth
 * @param {Vec2} mtv
 */
function outside(out_position, out_velocity, penetration_depth, mtv) {
if (!Array.isArray(out_position) || out_position[0] == undefined || Number.isNaN(out_position[0]) || 'number' !== typeof out_position[0] || out_position[1] == undefined || Number.isNaN(out_position[1]) || 'number' !== typeof out_position[1]) {
    throw new Error("invalid Vec2 out_position")
}

if (!Array.isArray(out_velocity) || out_velocity[0] == undefined || Number.isNaN(out_velocity[0]) || 'number' !== typeof out_velocity[0] || out_velocity[1] == undefined || Number.isNaN(out_velocity[1]) || 'number' !== typeof out_velocity[1]) {
    throw new Error("invalid Vec2 out_velocity")
}

if (penetration_depth == undefined || Number.isNaN(penetration_depth) || 'number' !== typeof penetration_depth) {
    throw new Error("penetration_depth is undefined or null")
}

if (!Array.isArray(mtv) || mtv[0] == undefined || Number.isNaN(mtv[0]) || 'number' !== typeof mtv[0] || mtv[1] == undefined || Number.isNaN(mtv[1]) || 'number' !== typeof mtv[1]) {
    throw new Error("invalid Vec2 mtv")
}

    vec2_scale(mtv_v, mtv, penetration_depth);
    // left-right penetration
    if (mtv_v[0] !== 0) {
        out_position[0] = mtv_v[0];
        out_velocity[0] = 0;
    }

    // up-down penetration
    if (mtv_v[1] !== 0) {
        out_position[1] = mtv_v[1];
        out_velocity[1] = max(out_velocity[1], 0);
    }
}

var aux_vec2 = [0, 0],
    col_impulse = [0, 0],
    fric_impulse = [0, 0],
    impulse = [0, 0],
    tangent_vel = [0, 0],
    rv = [0, 0];
/**
 * @param {Vec2} out_a_velocity Velocity of A
 * @param {Number} a_restitution Coefficient of restitution of A
 * @param {Number} a_imass Inverse mass of A
 * @param {Number} a_point Point of collision in A
 * @param {Vec2} out_b_velocity Velocity of B
 * @param {Number} b_restitution Coefficient of restitution of B
 * @param {Number} b_imass Inverse mass of B
 * @param {Number} b_point Point of collision in B
 * @param {Vec2} normal collision

 * @return {Boolean} is the velocity modified ?
 */
function linear(out_a_velocity, a_restitution, a_imass, a_point, out_b_velocity, b_restitution, b_imass, b_point, normal) {
if (!Array.isArray(out_a_velocity) || out_a_velocity[0] == undefined || Number.isNaN(out_a_velocity[0]) || 'number' !== typeof out_a_velocity[0] || out_a_velocity[1] == undefined || Number.isNaN(out_a_velocity[1]) || 'number' !== typeof out_a_velocity[1]) {
    throw new Error("invalid Vec2 out_a_velocity")
}

if (a_restitution == undefined || Number.isNaN(a_restitution) || 'number' !== typeof a_restitution) {
    throw new Error("a_restitution is undefined or null")
}

if (a_imass == undefined || Number.isNaN(a_imass) || 'number' !== typeof a_imass) {
    throw new Error("a_imass is undefined or null")
}

if (a_point == undefined || Number.isNaN(a_point) || 'number' !== typeof a_point) {
    throw new Error("a_point is undefined or null")
}

if (!Array.isArray(out_b_velocity) || out_b_velocity[0] == undefined || Number.isNaN(out_b_velocity[0]) || 'number' !== typeof out_b_velocity[0] || out_b_velocity[1] == undefined || Number.isNaN(out_b_velocity[1]) || 'number' !== typeof out_b_velocity[1]) {
    throw new Error("invalid Vec2 out_b_velocity")
}

if (b_restitution == undefined || Number.isNaN(b_restitution) || 'number' !== typeof b_restitution) {
    throw new Error("b_restitution is undefined or null")
}

if (b_imass == undefined || Number.isNaN(b_imass) || 'number' !== typeof b_imass) {
    throw new Error("b_imass is undefined or null")
}

if (b_point == undefined || Number.isNaN(b_point) || 'number' !== typeof b_point) {
    throw new Error("b_point is undefined or null")
}

if (!Array.isArray(normal) || normal[0] == undefined || Number.isNaN(normal[0]) || 'number' !== typeof normal[0] || normal[1] == undefined || Number.isNaN(normal[1]) || 'number' !== typeof normal[1]) {
    throw new Error("invalid Vec2 normal")
}

    // Calculate relative velocity
    vec2_sub(rv, out_b_velocity, out_a_velocity);

    // Calculate relative velocity in terms of the normal direction
    var normal_vel = vec2_dot(rv, normal);

    // Do not resolve if velocities are separating
    if (normal_vel > 0) {
        return false;
    }

    // Calculate restitution
    var e = Math.min(a_restitution, b_restitution);

    // Calculate impulse scalar
    var j = -(1 + e) * normal_vel;
    j /= a_imass + b_imass;

    // Apply impulse
    Vec2.scale(col_impulse, normal, j);

    //rv - Dot( rv, normal ) * normal
    vec2_sub(tangent_vel, rv, Vec2.scale(tangent_vel, normal, normal_vel));
    Vec2.normalize(tangent_vel, tangent_vel);

    // Solve for magnitude to apply along the friction vector
    var jt = -vec2_dot(rv, tangent_vel);
    jt /= a_imass + b_imass;

    var a_sfriction = 0.2;
    var b_sfriction = 0.2;

    var a_dfriction = 0.2;
    var b_dfriction = 0.2;

    // PythagoreanSolve = A^2 + B^2 = C^2, solving for C given A and B
    // Use to approximate mu given friction coefficients of each body
    var mu = sqrt(a_sfriction * a_sfriction + b_sfriction * b_sfriction);

    // Clamp magnitude of friction and create impulse vector
    if (abs(jt) < j * mu) {
        Vec2.scale(fric_impulse, tangent_vel, jt);
    } else {
        var dynamicFriction = sqrt(a_dfriction * a_dfriction + b_dfriction * b_dfriction);
        //frictionImpulse = -j * t * dynamicFriction
        Vec2.scale(fric_impulse, tangent_vel, -jt * dynamicFriction);
    }

    Vec2.add(impulse, col_impulse, fric_impulse);

    if (a_imass !== 0) {
        vec2_sub(out_a_velocity, out_a_velocity, Vec2.scale(aux_vec2, impulse, a_imass));
    }

    if (b_imass !== 0) {
        Vec2.add(out_b_velocity, out_b_velocity, Vec2.scale(aux_vec2, impulse, b_imass));
    }


    return true;
}


/*
 * Perform a fully elastic collision between the two objects
 * @reference http://en.wikipedia.org/wiki/Elastic_collision
 * @source https://github.com/benmurrell/node-multiplayer-asteroids
 *
 * @param {Vec2} a_pos
 * @param {Vec2} out_a_velocity
 * @param {Number} a_mass
 * @param {Vec2} b_pos
 * @param {Vec2} out_b_velocity
 * @param {Number} b_mass
 */
function elastic(a_pos, out_a_velocity, a_mass, b_pos, out_b_velocity, b_mass) {
if (!Array.isArray(a_pos) || a_pos[0] == undefined || Number.isNaN(a_pos[0]) || 'number' !== typeof a_pos[0] || a_pos[1] == undefined || Number.isNaN(a_pos[1]) || 'number' !== typeof a_pos[1]) {
    throw new Error("invalid Vec2 a_pos")
}

if (!Array.isArray(out_a_velocity) || out_a_velocity[0] == undefined || Number.isNaN(out_a_velocity[0]) || 'number' !== typeof out_a_velocity[0] || out_a_velocity[1] == undefined || Number.isNaN(out_a_velocity[1]) || 'number' !== typeof out_a_velocity[1]) {
    throw new Error("invalid Vec2 out_a_velocity")
}

if (a_mass == undefined || Number.isNaN(a_mass) || 'number' !== typeof a_mass) {
    throw new Error("a_mass is undefined or null")
}

if (!Array.isArray(b_pos) || b_pos[0] == undefined || Number.isNaN(b_pos[0]) || 'number' !== typeof b_pos[0] || b_pos[1] == undefined || Number.isNaN(b_pos[1]) || 'number' !== typeof b_pos[1]) {
    throw new Error("invalid Vec2 b_pos")
}

if (!Array.isArray(out_b_velocity) || out_b_velocity[0] == undefined || Number.isNaN(out_b_velocity[0]) || 'number' !== typeof out_b_velocity[0] || out_b_velocity[1] == undefined || Number.isNaN(out_b_velocity[1]) || 'number' !== typeof out_b_velocity[1]) {
    throw new Error("invalid Vec2 out_b_velocity")
}

if (b_mass == undefined || Number.isNaN(b_mass) || 'number' !== typeof b_mass) {
    throw new Error("b_mass is undefined or null")
}

    // Determine contact angle
    var contactAngle = atan2(a_pos[1] - b_pos[1], a_pos[0] - b_pos[0]);

    // Determine velocities after collision
    var vLeft = sqrt(out_a_velocity[0] * out_a_velocity[0] + out_a_velocity[1] * out_a_velocity[1]);
    var thetaLeft = atan2(out_a_velocity[1], out_a_velocity[0]);

    var vRight = sqrt(out_b_velocity[0] * out_b_velocity[0] + out_b_velocity[1] * out_b_velocity[1]);
    var thetaRight = atan2(out_b_velocity[1], out_b_velocity[0]);

    var lc_tca = cos(thetaLeft - contactAngle),
        rc_tca = cos(thetaRight - contactAngle),
        ls_tca = sin(thetaLeft - contactAngle),
        rs_tca = sin(thetaRight - contactAngle),
        cContactAngle = cos(contactAngle),
        sContactAngle = sin(contactAngle),
        mass_sum = (a_mass + b_mass),
        lmass_dif = (a_mass - b_mass),
        rmass_dif = (b_mass - a_mass),
        left_num = (vLeft * lc_tca * lmass_dif + 2 * b_mass * vRight * rc_tca),
        right_num = (vRight * rc_tca * rmass_dif + 2 * a_mass * vLeft * lc_tca);

    // elastic collision with mass
    out_a_velocity[0] = left_num / mass_sum * cContactAngle + vLeft * ls_tca * cos(contactAngle + HALF_PI);
    out_a_velocity[1] = left_num / mass_sum * sContactAngle + vLeft * ls_tca * sin(contactAngle + HALF_PI);

    out_b_velocity[0] = right_num / mass_sum * cContactAngle + vRight * rs_tca * cos(contactAngle + HALF_PI);
    out_b_velocity[1] = right_num / mass_sum * sContactAngle + vRight * rs_tca * sin(contactAngle + HALF_PI);
}

module.exports = {
    elastic: elastic,
    outside: outside,
    linear: linear
};

},{"../vec2.js":30}],11:[function(require,module,exports){
/**
 * Result of an intersection.
 * Use create or new, instances support instanceof Collision.Response
 *
 * * **a** first object participating
 * * **b** second object participating
 * * **aInB** Is a inside a (only SAT)
 * * **bInA** Is b inside a (only SAT)
 * * **depth** penetration amount
 * * **mtv** Minimum translate vector (**normalized**). If you subtract mtv * depth to a, there will be no collision.
 * * **normal** No used at this moment. This will be used in manifold generation.
 * * **poc** No used at this moment. Point of collision. This will be used in manifold generation.
 */
var Vec2 = require("../vec2.js"),
    vec2_scale = Vec2.scale;

function Response() {
    this.normal = [0, 0];
    this.mtv = [0, 0];
}

Response.prototype.a = null;
Response.prototype.b = null;
Response.prototype.aInB = true;
Response.prototype.bInA = true;
Response.prototype.depth = Number.MAX_VALUE;
Response.prototype.normal = null;
Response.prototype.mtv = null;
/**
 * equivalent to new Collision.Response()
 */
function create() {
    return new Response();
}

/**
 * Restore default values
 *
 * @param {Response} out_response
 * @return {Response}
 */
function clear(out_response) {
    out_response.aInB = true;
    out_response.bInA = true;
    out_response.depth = Number.MAX_VALUE;

    out_response.normal[0] = 0;
    out_response.normal[1] = 0;

    out_response.mtv[0] = 0;
    out_response.mtv[1] = 0;

    return out_response;
}
/**
 * Compute real mtv scaling response.mtv * response.depth
 *
 * @param {Vec2} out_vec2
 * @param {Response} response
 * @return {Vec2}
 */
function mtv(out_vec2, response) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

    vec2_scale(out_vec2, response.mtv, response.depth);
}


module.exports = Response;

Response.create = create;
Response.clear = clear;
Response.mtv = mtv;

},{"../vec2.js":30}],12:[function(require,module,exports){
/**!
* @source https://github.com/jriecken/sat-js
* @reference http://physics2d.com/content/separation-axis
*
* Version 0.4.1 - Copyright 2014 -  Jim Riecken <jimr@jimr.ca>
* Released under the MIT License
* Adapted to js-2dmath by Luis Lafuente <llafuente@noboxout.com>
*
* A simple library for determining intersections of circles and polygons using the Separating Axis Theorem.
*/

var Vec2 = require("../vec2.js"),
    Polygon = require("../polygon.js"),
    Response = require("./response.js"),
    response_clear = Response.clear,
    vec2_dot = Vec2.dot,
    vec2_sub = Vec2.sub,
    vec2_length = Vec2.length,
    vec2_lengthSq = Vec2.lengthSq,
    vec2_copy = Vec2.copy,
    vec2_normalize = Vec2.normalize,
    vec2_negate = Vec2.negate,
    vec2_scale = Vec2.scale,
    vec2_perp = Vec2.perp,

    abs = Math.abs,
    sqrt = Math.sqrt;



// Unit square polygon used for polygon hit detection.
/**
 * @type {Polygon}
 */
var UNIT_SQUARE = [[1, 0], [1, 1], [0, 1], [0, 0]],
    UNIT_SQUARE_MOVED = [[1, 0], [1, 1], [0, 1], [0, 0]];

// ## Helper Functions

/**
 * Flattens the specified array of points onto a unit vector axis,
 * resulting in a one dimensional range of the minimum and
 * maximum value on that axis.
 *
 * @param {Array.<Vec2>} points The points to flatten.
 * @param {Vec2} normal The unit vector axis to flatten on.
 * @param {Array.<number>} result An array. After calling this function, result[0] will be the minimum value, result[1] will be the maximum value.
 */
function _flattenPointsOn(points, normal, result) {
if (!Array.isArray(normal) || normal[0] == undefined || Number.isNaN(normal[0]) || 'number' !== typeof normal[0] || normal[1] == undefined || Number.isNaN(normal[1]) || 'number' !== typeof normal[1]) {
    throw new Error("invalid Vec2 normal")
}

    var min = Number.MAX_VALUE,
        max = -Number.MAX_VALUE,
        len = points.length,
        i = 0,
        dot;

    for (; i < len; ++i) {
        // The magnitude of the projection of the point onto the normal
        dot = vec2_dot(points[i], normal);
        if (dot < min) { min = dot; }
        if (dot > max) { max = dot; }
    }

    result[0] = min;
    result[1] = max;
}

var rangeA = [0, 0],
    rangeB = [0, 0],
    offsetV = [0, 0];

/**
 * Check whether two convex polygons are separated by the specified
 * axis (must be a unit vector).
 *
 * @param {Response} out_response A Response object which will be populated if the axis is not a separating axis.
 * @param {Vec2} a_pos The position of the first polygon.
 * @param {Vec2} b_pos The position of the second polygon.
 * @param {Array.<Vec2>} a_points The points in the first polygon.
 * @param {Array.<Vec2>} b_points The points in the second polygon.
 * @param {Vec2} axis The axis (unit sized) to test against.  The points of both polygons will be projected onto this axis.
 * @return {Boolean} true if it is a separating axis, false otherwise.  If false, and a response is passed in, information about how much overlap and the direction of the overlap will be populated.
 */
function _isSeparatingAxis(out_response, a_pos, b_pos, a_points, b_points, axis) {
if (!Array.isArray(a_pos) || a_pos[0] == undefined || Number.isNaN(a_pos[0]) || 'number' !== typeof a_pos[0] || a_pos[1] == undefined || Number.isNaN(a_pos[1]) || 'number' !== typeof a_pos[1]) {
    throw new Error("invalid Vec2 a_pos")
}

if (!Array.isArray(b_pos) || b_pos[0] == undefined || Number.isNaN(b_pos[0]) || 'number' !== typeof b_pos[0] || b_pos[1] == undefined || Number.isNaN(b_pos[1]) || 'number' !== typeof b_pos[1]) {
    throw new Error("invalid Vec2 b_pos")
}

if (!Array.isArray(axis) || axis[0] == undefined || Number.isNaN(axis[0]) || 'number' !== typeof axis[0] || axis[1] == undefined || Number.isNaN(axis[1]) || 'number' !== typeof axis[1]) {
    throw new Error("invalid Vec2 axis")
}

    // The magnitude of the offset between the two polygons
    vec2_sub(offsetV, b_pos, a_pos);
    var projectedOffset = vec2_dot(offsetV, axis);
    // Project the polygons onto the axis.
    _flattenPointsOn(a_points, axis, rangeA);
    _flattenPointsOn(b_points, axis, rangeB);
    // Move B's range to its position relative to A.
    rangeB[0] += projectedOffset;
    rangeB[1] += projectedOffset;
    // Check if there is a gap. If there is, this is a separating axis and we can stop
    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
        return true;
    }
    // This is not a separating axis. If we're calculating a response, calculate the overlap.

    var overlap = 0,
        option1,
        option2;
    // A starts further left than B
    if (rangeA[0] < rangeB[0]) {
        out_response.aInB = false;
        // A ends before B does. We have to pull A out of B
        if (rangeA[1] < rangeB[1]) {
            overlap = rangeA[1] - rangeB[0];
            out_response.bInA = false;
        // B is fully inside A.  Pick the shortest way out.
        } else {
            option1 = rangeA[1] - rangeB[0];
            option2 = rangeB[1] - rangeA[0];
            overlap = option1 < option2 ? option1 : -option2;
        }
    // B starts further left than A
    } else {
        out_response.bInA = false;
        // B ends before A ends. We have to push A out of B
        if (rangeA[1] > rangeB[1]) {
            overlap = rangeA[0] - rangeB[1];
            out_response.aInB = false;
        // A is fully inside B.  Pick the shortest way out.
        } else {
            option1 = rangeA[1] - rangeB[0];
            option2 = rangeB[1] - rangeA[0];
            overlap = option1 < option2 ? option1 : -option2;
        }
    }
    // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.
    var absOverlap = abs(overlap);
    if (absOverlap < out_response.depth) {
        out_response.depth = absOverlap;
        vec2_copy(out_response.mtv, axis);
        if (overlap < 0) {
            vec2_negate(out_response.mtv, out_response.mtv);
        }
    }

    return false;
}

// Calculates which Vornoi region a point is on a line segment.
// It is assumed that both the line and the point are relative to `(0,0)`
//
//            |       (0)      |
//     (-1)  [S]--------------[E]  (1)
//            |       (0)      |
/**
 * @param {Vec2} line The line segment.
 * @param {Vec2} point The point.
 * @return  {Number} LEFT_VORNOI_REGION (-1) if it is the left region, MIDDLE_VORNOI_REGION (0) if it is the middle region, RIGHT_VORNOI_REGION (1) if it is the right region.
 */
function _vornoiRegion(line, point) {
if (!Array.isArray(line) || line[0] == undefined || Number.isNaN(line[0]) || 'number' !== typeof line[0] || line[1] == undefined || Number.isNaN(line[1]) || 'number' !== typeof line[1]) {
    throw new Error("invalid Vec2 line")
}

if (!Array.isArray(point) || point[0] == undefined || Number.isNaN(point[0]) || 'number' !== typeof point[0] || point[1] == undefined || Number.isNaN(point[1]) || 'number' !== typeof point[1]) {
    throw new Error("invalid Vec2 point")
}

    var len2 = vec2_lengthSq(line),
        dp = vec2_dot(point, line);
    // If the point is beyond the start of the line, it is in the
    // left vornoi region.
    if (dp < 0) { return LEFT_VORNOI_REGION; }
    // If the point is beyond the end of the line, it is in the
    // right vornoi region.
    else if (dp > len2) { return RIGHT_VORNOI_REGION; }
    // Otherwise, it's in the middle one.
    else { return MIDDLE_VORNOI_REGION; }
}
// Constants for Vornoi regions
/**
 * @const
 */
var LEFT_VORNOI_REGION = -1;
/**
 * @const
 */
var MIDDLE_VORNOI_REGION = 0;
/**
 * @const
 */
var RIGHT_VORNOI_REGION = 1;

// ## Collision Tests

var pic_differenceV = [0, 0];
/**
 * Check if a point is inside a circle.
 *
 * @param {Vec2} vec2 The point to test.
 * @param {Circle} circle The circle to test.
 * @return {Boolean} true if the point is inside the circle, false if it is not.
 */
function getPointInCircle(vec2, circle) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    vec2_sub(pic_differenceV, vec2, circle[0]);

    // If the distance between is smaller than the radius then the point is inside the circle.
    return vec2_lengthSq(pic_differenceV) <= (circle[1] * circle[1]);
}

/**
 * Check if a point is inside a convex polygon.
 *
 * @param {Response} out_response
 * @param {Vec2} vec2 The point to test.
 * @param {Polygon} poly The polygon to test.
 * @return {Boolean} true if the point is inside the polygon, false if it is not.
 */
function getPointInPolygon(out_response, vec2, poly) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    Polygon.translate(UNIT_SQUARE_MOVED, UNIT_SQUARE, vec2);
    response_clear(out_response);

    var result = getPolygonPolygon(out_response, UNIT_SQUARE_MOVED, poly);
    if (result) {
        result = out_response.aInB;
    }
    return result;
}

var cic_differenceV = [0, 0];
/**
 * Check if two circles collide.
 *
 * @param {Response} out_response Response object that will be populated if the circles intersect.
 * @param {Circle} a_circle The first circle.
 * @param {Circle} b_circle The second circle.
 * @return {Boolean} true if the circles intersect, false if they don't.
 */
function getCircleCircle(out_response, a_circle, b_circle) {
    response_clear(out_response);

    // Check if the distance between the centers of the two
    // circles is greater than their combined radius.
    vec2_sub(cic_differenceV, b_circle[0], a_circle[0]);
    var totalRadius = a_circle[1] + b_circle[1],
        totalRadiusSq = totalRadius * totalRadius,
        distanceSq = vec2_lengthSq(cic_differenceV),
        dist;

    // If the distance is bigger than the combined radius, they don't intersect.
    if (distanceSq > totalRadiusSq) {
        return false;
    }

    // They intersect.  If we're calculating a response, calculate the overlap.
    dist = sqrt(distanceSq);
    out_response.a = a_circle;
    out_response.b = b_circle;
    out_response.depth = totalRadius - dist;

    vec2_normalize(out_response.mtv, cic_differenceV);

    out_response.aInB = a_circle[1] <= b_circle[1] && dist <= b_circle[1] - a_circle[1];
    out_response.bInA = b_circle[1] <= a_circle[1] && dist <= a_circle[1] - b_circle[1];

    return true;
}

var pc_circlePos = [0, 0],
    edge =  [0, 0],
    point =  [0, 0],
    point2 =  [0, 0],
    normal = [0, 0];

/**
 * Check if a polygon and a circle collide.
 *
 * @param {Response} out_response Response object that will be populated if they interset.
 * @param {Polygon} poly_points The polygon.
 * @param {Polygon} poly_edges The polygon edges
 * @param {Vec2} poly_pos The polygon position
 * @param {Circle} circle The circle.
 * @return {Boolean} true if they intersect, false if they don't.
 */
function getPolygonCircle(out_response, poly_points, poly_edges, poly_pos, circle) {
if (!Array.isArray(poly_pos) || poly_pos[0] == undefined || Number.isNaN(poly_pos[0]) || 'number' !== typeof poly_pos[0] || poly_pos[1] == undefined || Number.isNaN(poly_pos[1]) || 'number' !== typeof poly_pos[1]) {
    throw new Error("invalid Vec2 poly_pos")
}

    response_clear(out_response);

    // Get the position of the circle relative to the polygon.
    vec2_sub(pc_circlePos, circle[0], poly_pos);

    var radius = circle[1],
        radius2 = radius * radius,
        len = poly_points.length,
        dist,
        i = 0;

    // For each edge in the polygon:
    for (; i < len; i++) {
        var next = i === len - 1 ? 0 : i + 1;
        var prev = i === 0 ? len - 1 : i - 1;
        var overlap = 0;
        var overlapN = null;

        // Get the edge.
        vec2_copy(edge, poly_edges[i]);
        // Calculate the center of the circle relative to the starting point of the edge.
        vec2_sub(point, pc_circlePos, poly_points[i]);

        // If the distance between the center of the circle and the point
        // is bigger than the radius, the polygon is definitely not fully in
        // the circle.
        if (vec2_lengthSq(point) > radius2) {
            out_response.aInB = false;
        }

        // Calculate which Vornoi region the center of the circle is in.
        var region = _vornoiRegion(edge, point);
        // If it's the left region:
        if (region === LEFT_VORNOI_REGION) {
            // We need to make sure we're in the RIGHT_VORNOI_REGION of the previous edge.
            vec2_copy(edge, poly_edges[prev]);
            // Calculate the center of the circle relative the starting point of the previous edge
            vec2_sub(point2, pc_circlePos, poly_points[prev]);
            region = _vornoiRegion(edge, point2);
            if (region === RIGHT_VORNOI_REGION) {
                // It's in the region we want.  Check if the circle intersects the point.
                dist = vec2_length(point);
                if (dist > radius) {
                    // No intersection
                    return false;
                } else {
                    // It intersects, calculate the overlap.
                    out_response.bInA = false;
                    overlapN = [0, 0];
                    vec2_normalize(overlapN, point);
                    overlap = radius - dist;
                }
            }
        // If it's the right region:
        } else if (region === RIGHT_VORNOI_REGION) {
            // We need to make sure we're in the left region on the next edge
            vec2_copy(edge, poly_edges[next]);
            // Calculate the center of the circle relative to the starting point of the next edge.
            vec2_sub(point, pc_circlePos, poly_points[next]);
            region = _vornoiRegion(edge, point);
            if (region === LEFT_VORNOI_REGION) {
                // It's in the region we want.  Check if the circle intersects the point.
                dist = vec2_length(point);
                if (dist > radius) {
                    // No intersection
                    return false;
                } else {
                    // It intersects, calculate the overlap.
                    out_response.bInA = false;
                    overlapN = [0, 0];
                    vec2_normalize(overlapN, point);
                    overlap = radius - dist;
                }
            }
        // Otherwise, it's the middle region:
        } else {
            // Need to check if the circle is intersecting the edge,
            // Change the edge into its "edge normal".
            vec2_normalize(normal, vec2_perp(edge, edge));
            // Find the perpendicular distance between the center of the
            // circle and the edge.
            dist = vec2_dot(point, normal);
            var distAbs = abs(dist);
            // If the circle is on the outside of the edge, there is no intersection.
            if (dist > 0 && distAbs > radius) {
                // No intersection
                return false;
            } else {
                // It intersects, calculate the overlap.
                overlapN = normal;
                overlap = radius - dist;
                // If the center of the circle is on the outside of the edge, or part of the
                // circle is on the outside, the circle is not fully inside the polygon.
                if (dist >= 0 || overlap < 2 * radius) {
                    out_response.bInA = false;
                }
            }
        }

        // If this is the smallest overlap we've seen, keep it.
        // (overlapN may be null if the circle was in the wrong Vornoi region).
        if (overlapN && abs(overlap) < abs(out_response.depth)) {
            out_response.depth = overlap;
            vec2_copy(out_response.mtv, overlapN);
        }
    }

    // Calculate the final overlap vector - based on the smallest overlap.
    out_response.a = poly_points;
    out_response.b = circle;

    return true;
}

/**
 * Check if a circle and a polygon collide.
 *
 * @note This is slightly less efficient than polygonCircle as it just runs polygonCircle and reverses everything at the end.
 * @param {Response} out_response Response object that will be populated if they interset.
 * @param {Circle} circle The circle.
 * @param {Polygon} poly The polygon.
 * @return {Boolean} true if they intersect, false if they don't.
 */
function getCirclePolygon(out_response, circle, poly) {
    response_clear(out_response);

    // Test the polygon against the circle.
    var result = getPolygonCircle(out_response, poly, circle);

    if (result) {
        // Swap A and B in the response.
        var a = out_response.a;
        var aInB = out_response.aInB;
        vec2_negate(out_response.mtv, out_response.mtv);
        out_response.a = out_response.b;
        out_response.b = a;
        out_response.aInB = out_response.bInA;
        out_response.bInA = aInB;
    }
    return result;
}

/**
 * Checks whether polygons collide.
 *
 * @param {Response} out_response Response object that will be populated if they interset.
 * @param {Polygon} a_points The first polygon points
 * @param {Polygon} a_normals The first polygon normals
 * @param {Polygon} a_pos The first polygon position
 * @param {Polygon} b_points The second polygon points
 * @param {Polygon} b_normals The second polygon normals
 * @param {Polygon} b_pos The second polygon position
 * @return {Boolean} true if they intersect, false if they don't.
 */
function getPolygonPolygon(out_response, a_points, a_normals, a_pos, b_points, b_normals, b_pos) {
    response_clear(out_response);

    var aLen = a_points.length,
        bLen = b_points.length,
        i;

    // If any of the edge normals of A is a separating axis, no intersection.
    for (i = 0; i < aLen; ++i) {
        if (_isSeparatingAxis(out_response, a_pos, b_pos, a_points, b_points, a_normals[i])) {
            return false;
        }
    }

    // If any of the edge normals of B is a separating axis, no intersection.
    for (i = 0;i < bLen; ++i) {
        if (_isSeparatingAxis(out_response, a_pos, b_pos, a_points, b_points, b_normals[i])) {
            return false;
        }
    }

    return true;
}

var SAT = {
    Response: Response,
    getPointInCircle: getPointInCircle,
    getPointInPolygon: getPointInPolygon,
    getCircleCircle: getCircleCircle,
    getPolygonCircle: getPolygonCircle,
    getCirclePolygon: getCirclePolygon,
    getPolygonPolygon: getPolygonPolygon
};

module.exports = SAT;

},{"../polygon.js":25,"../vec2.js":30,"./response.js":11}],13:[function(require,module,exports){
/**
 * Stability: 0 (Anything could happen)
 */

var sqrt = Math.sqrt,
    abs = Math.abs,
    min = Math.min,
    Rectangle = require("./rectangle.js"),
    x = 0,
    y = 0;

function fourPoints(x1, y1, x2, y2) {
    x = x1 - x2;
    y = y1 - y2;

    return sqrt(x * x + y * y);
}

function sqrFourPoints(x1, y1, x2, y2) {
    x = x1 - x2;
    y = y1 - y2;

    return x * x + y * y;
}

function line2_vec2(line2, vec2) {
    var __x1 = line2[0][0],
        __y1 = line2[0][1],
        __x2 = line2[0][0] + line2[1],
        __y2 = line2[0][1] + line2[1],
        __px = vec2[0],
        __py = vec2[1],
        r_numerator = (__x1 - __x2) * (__px - __x2) + (__y1 - __y2) * (__py - __y2),
        r_denomenator = (__px - __x2) * (__px - __x2) + (__py - __y2) * (__py - __y2),
        r = r_denomenator === 0 ? 0 : (r_numerator / r_denomenator),
        distanceLine,
        px,
        py,
        s;


    if ((r >= 0) && (r <= 1)) {
        return 0;
    }

    //
    px = __x2 + r * (__px - __x2);
    py = __y2 + r * (__py - __y2);
    //
    s = ((__y2 - __y1) * (__px - __x2) - (__x2 - __x1) * (__py - __y2)) / r_denomenator;
    distanceLine = abs(s) * sqrt(r_denomenator);

    return distanceLine;
}

function segment2_vec2(seg2, vec2) {
    var A = vec2[0] - seg2[0],
        B = vec2[1] - seg2[1],
        C = seg2[2] - seg2[0],
        D = seg2[3] - seg2[1],
        dot = A * C + B * D,
        len_sq = C * C + D * D,
        param = dot / len_sq,
        xx,
        yy;

    if (param < 0) {
        xx = seg2[0];
        yy = seg2[1];
    } else if (param > 1) {
        xx = seg2[2];
        yy = seg2[3];
    } else {
        xx = seg2[0] + param * C;
        yy = seg2[1] + param * D;
    }

    return fourPoints(vec2[0], vec2[1], xx, yy);
}

function rectangle_vec2(rect, vec2) {
    Rectangle.normalize(rect, rect);

    /*
    @TODO: Optimize, i cant find the right combination
    var hcat = vec2.x < rect.v1.x ? 0 : ( vec2.x > rect.v2.x ? 2 : 1 );
    var vcat = vec2.y > rect.v1.y ? 0 : ( vec2.y < rect.v2.y ? 2 : 1 );

    if(hcat == 0 && vcat == 0) return distance_vec2_vs_vec2(rect.v1, vec2);
    if(hcat == 2 && vcat == 2) return distance_vec2_vs_vec2(rect.v2, vec2);

    if(hcat == 0 && vcat == 2) return distance_vec2_vs_vec2(new Vec2(rect.v2.x, rect.v1.y), vec2);
    if(hcat == 2 && vcat == 0) return distance_vec2_vs_vec2(new Vec2(rect.v1.x, rect.v2.y), vec2);

    if(hcat == 0 && vcat == 1) return distance_segment2_vs_vec2(new Vec2(rect.v1.x, rect.v1.y), new Vec2(rect.v1.x, rect.v2.y));
    if(hcat == 1 && vcat == 0) return distance_segment2_vs_vec2(new Vec2(rect.v1.x, rect.v1.y), new Vec2(rect.v2.x, rect.v1.y));

    if(hcat == 2 && vcat == 1) return distance_segment2_vs_vec2(new Vec2(rect.v2.x, rect.v1.y), new Vec2(rect.v2.x, rect.v2.y));
    if(hcat == 1 && vcat == 2) return distance_segment2_vs_vec2(new Vec2(rect.v1.x, rect.v2.y), new Vec2(rect.v2.x, rect.v2.y));
    */

    var s1 = [rect[0][0], rect[0][1], rect[0][0], rect[1][1]],
        s2 = [rect[0][0], rect[0][1], rect[1][0], rect[0][1]],

        s3 = [rect[0][0], rect[1][1], rect[1][0], rect[1][1]],
        s4 = [rect[1][0], rect[0][1], rect[1][0], rect[1][1]];

    return min(
        segment2_vec2(s1, vec2),
        segment2_vec2(s2, vec2),
        segment2_vec2(s3, vec2),
        segment2_vec2(s4, vec2)
    );
}
/*
 * Figure 26.1
 * http://pomax.github.io/bezierinfo/
 * @todo
 */

function beizer_vec2() {

}

/**
 * @class Distance
 */
var Distance = {
    fourPoints: fourPoints,
    sqrFourPoints: sqrFourPoints,
    line2_vec2: line2_vec2,
    segment2_vec2: segment2_vec2,
    rectangle_vec2: rectangle_vec2,

    //alias
    fourPointsSq: sqrFourPoints
};


module.exports = Distance;
},{"./rectangle.js":26}],14:[function(require,module,exports){
/**
 * Utilities for rendering in CanvasElement
 */

/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Rectangle} rect
 * @param {String} style strokeStyle
 */
function rectangle(context2d, rect, style) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

    if (style !== undefined) {
        context2d.strokeStyle = style;
    }

    context2d.strokeRect(rect[0][0], rect[0][1], rect[1][0] - rect[0][0], rect[1][1] - rect[0][1]);
}

if ("undefined" !== typeof CanvasRenderingContext2D) {
    var fillText = CanvasRenderingContext2D.prototype.fillText;
    function invertFillText(a, b, c) {
        this.save();
        //ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.transform(1, 0, 0, -1, 0, 0);
        fillText.call(this, a, b, -c);
        this.restore();
    }

    window.requestAnimFrame = (function () {
        return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
    })();
}



/**
 * calling this override fillText so you didn"t see inverted text
 * You must not modify the transformation matrix without the proper save/restore.
 * @param {CanvasElement} canvas
 * @param {CanvasRenderingContext2D} context2d
 */
function invertAxis(canvas, context2d) {
    context2d.setTransform(1, 0, 0, -1, 0, canvas.height);
    context2d.fillText = invertFillText;
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Number=} coords
 * @param {Number=} count
 */
function cartesianAxis(context2d, coords, count) {
if (coords !== undefined) {
if (coords == undefined || Number.isNaN(coords) || 'number' !== typeof coords) {
    throw new Error("coords is undefined or null")
}

}
if (count !== undefined) {
if (count == undefined || Number.isNaN(count) || 'number' !== typeof count) {
    throw new Error("count is undefined or null")
}

}
    context2d.save();

    context2d.strokeStyle = "rgba(0,0,0, 0.25)";
    //context2d.strokeStyle = "red";

    context2d.font = "6pt Consolas";


    coords = coords || 320;
    count = count || 16;

    context2d.beginPath();
    context2d.moveTo(-coords, 0);
    context2d.lineTo(coords, 0);
    context2d.stroke();

    context2d.beginPath();
    context2d.moveTo(0, -coords);
    context2d.lineTo(0, coords);
    context2d.stroke();


    if (context2d.setLineDash) {
        context2d.setLineDash([1, 2]);
    } else {
        context2d.strokeStyle = "rgba(0,0,0, 0.125)";
    }

    context2d.beginPath();
    context2d.moveTo(-coords, coords * 0.5);
    context2d.lineTo(coords, coords * 0.5);
    context2d.stroke();

    context2d.beginPath();
    context2d.moveTo(-coords, -coords * 0.5);
    context2d.lineTo(coords, -coords * 0.5);
    context2d.stroke();

    context2d.beginPath();
    context2d.moveTo(coords * 0.5, -coords);
    context2d.lineTo(coords * 0.5, coords);
    context2d.stroke();

    context2d.beginPath();
    context2d.moveTo(-coords * 0.5, -coords);
    context2d.lineTo(-coords * 0.5, coords);
    context2d.stroke();


    context2d.setLineDash([]);


    context2d.strokeStyle = "rgba(0,0,0, 0.25)";

    var i,
        inc = coords * 2 / count,
        max = count,
        x,
        y;

    context2d.textAlign = "center";
    for (i = 0; i <= max; ++i) {
        x = -coords + i * inc;
        context2d.beginPath();
        context2d.moveTo(x, 4);
        context2d.lineTo(x, -4);
        context2d.stroke();

        if (x !== 0) {
            context2d.fillText(x, x, -12);
        }
    }

    context2d.fillText("(0,0)", 0, -12);

    context2d.textAlign = "left";
    for (i = 0; i <= max; ++i) {
        y = -coords + i * inc;
        context2d.beginPath();
        context2d.moveTo(4, y);
        context2d.lineTo(-4, y);
        context2d.stroke();

        if (y !== 0) {
            context2d.fillText(y, +12, y - 4);
        }
    }

    context2d.restore();
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Circle} circle
 * @param {String} style strokeStyle/fillStyle
 * @param {Boolean=} fill
 */
function circle(context2d, circle, style, fill) {
if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

if (fill !== undefined) {
if ('boolean' !== typeof fill) {
    throw new Error("fill is not a boolean")
}

}
    context2d.save();

    if (style !== undefined) {
        fill ? context2d.fillStyle = style : context2d.strokeStyle = style;
    }

    context2d.beginPath();
    context2d.arc(circle[0][0], circle[0][1], circle[1], 0, 2 * Math.PI, false);
    context2d.stroke();

    context2d.beginPath();
    context2d.arc(circle[0][0], circle[0][1], 1, 0, 2 * Math.PI, false);
    fill ? context2d.fill() : context2d.stroke();

    context2d.restore();
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Line2} line2
 * @param {String} style strokeStyle
 * @param {Number=} length
 */
function line2(context2d, line2, style, length) {
if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

if (length !== undefined) {
if (length == undefined || Number.isNaN(length) || 'number' !== typeof length) {
    throw new Error("length is undefined or null")
}

}
    context2d.save();

    if (style !== undefined) {
        context2d.strokeStyle = style;
    }

    context2d.beginPath();
    var m = line2[1];
    length = length || 100;

    context2d.moveTo(line2[0][0] - (length * m), line2[0][1] - length);
    context2d.lineTo(line2[0][0] + (length * m), line2[0][1] + length);
    context2d.stroke();

    context2d.restore();
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Vec2} vec2
 * @param {String} style strokeStyle
 * @param {Number=} length
 */
function vec2(context2d, vec2, style, length) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

if (length !== undefined) {
if (length == undefined || Number.isNaN(length) || 'number' !== typeof length) {
    throw new Error("length is undefined or null")
}

}
    context2d.save();

    length = length || 2;

    if (style !== undefined) {
        context2d.strokeStyle = style;
    }

    context2d.beginPath();
    context2d.moveTo(vec2[0] + length, vec2[1] + length);
    context2d.lineTo(vec2[0] - length, vec2[1] - length);
    context2d.stroke();

    context2d.beginPath();
    context2d.moveTo(vec2[0] - length, vec2[1] + length);
    context2d.lineTo(vec2[0] + length, vec2[1] - length);
    context2d.stroke();

    context2d.restore();
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Vec2} origin
 * @param {Vec2} vec2
 * @param {Number=} length
 * @param {String} style strokeStyle
 */
function vec2dir(context2d, origin, vec2, length, style) {
if (!Array.isArray(origin) || origin[0] == undefined || Number.isNaN(origin[0]) || 'number' !== typeof origin[0] || origin[1] == undefined || Number.isNaN(origin[1]) || 'number' !== typeof origin[1]) {
    throw new Error("invalid Vec2 origin")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (length !== undefined) {
if (length == undefined || Number.isNaN(length) || 'number' !== typeof length) {
    throw new Error("length is undefined or null")
}

}
if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

    context2d.save();

    length = length || 2;

    if (style !== undefined) {
        context2d.strokeStyle = style;
    }

    context2d.beginPath();
    context2d.moveTo(origin[0], origin[1]);
    context2d.lineTo(origin[0] + vec2[0] * length, origin[1] + vec2[1] * length);
    context2d.stroke();

    context2d.restore();
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Vec2} vec2
 * @param {Number} angle
 * @param {String} style strokeStyle
 * @param {Number=} length
 */
function angle(context2d, vec2, angle, style, length) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (angle == undefined || Number.isNaN(angle) || 'number' !== typeof angle) {
    throw new Error("angle is undefined or null")
}

if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

if (length !== undefined) {
if (length == undefined || Number.isNaN(length) || 'number' !== typeof length) {
    throw new Error("length is undefined or null")
}

}
    context2d.save();

    length = length || 10;

    if (style !== undefined) {
        context2d.strokeStyle = style;
    }

    context2d.beginPath();
    context2d.moveTo(vec2[0] + 2, vec2[1] + 2);
    context2d.lineTo(vec2[0] - 2, vec2[1] - 2);
    context2d.stroke();

    context2d.beginPath();
    context2d.moveTo(vec2[0], vec2[1]);
    context2d.lineTo(vec2[0] + Math.cos(angle) * length, vec2[1] + Math.sin(angle) * length);
    context2d.stroke();

    context2d.restore();
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Segment2} seg2
 * @param {String} style strokeStyle
 */
function segment2(context2d, seg2, style) {
if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

    context2d.save();

    if (style !== undefined) {
        context2d.strokeStyle = style;
    }

    context2d.beginPath();
    context2d.moveTo(seg2[0], seg2[1]);
    context2d.lineTo(seg2[2], seg2[3]);
    context2d.stroke();


    context2d.beginPath();
    context2d.arc(seg2[0], seg2[1], 1, 0, 2 * Math.PI, false);
    context2d.stroke();

    context2d.beginPath();
    context2d.arc(seg2[2], seg2[3], 1, 0, 2 * Math.PI, false);
    context2d.stroke();

    context2d.restore();

}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Triangle} tri
 * @param {String} style strokeStyle/fillStyle
 * @param {Boolean=} fill
 */
function triangle(context2d, tri, style, fill) {
if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

if (fill !== undefined) {
if ('boolean' !== typeof fill) {
    throw new Error("fill is not a boolean")
}

}
    context2d.save();

    if (style !== undefined) {
        fill ? context2d.fillStyle = style : context2d.strokeStyle = style;
    }

    context2d.beginPath();
    context2d.lineTo(tri[1][0], tri[1][1]);
    context2d.lineTo(tri[2][0], tri[2][1]);
    context2d.lineTo(tri[0][0], tri[0][1]);
    context2d.lineTo(tri[1][0], tri[1][1]);
    fill ? context2d.fill() : context2d.stroke();

    context2d.restore();
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {AABB2} aabb2
 * @param {String} style strokeStyle/fillStyle
 * @param {Boolean=} fill
 */
function aabb2(context2d, aabb2, style, fill) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

if (fill !== undefined) {
if ('boolean' !== typeof fill) {
    throw new Error("fill is not a boolean")
}

}
    context2d.save();


    if (style !== undefined) {
        fill ? context2d.fillStyle = style : context2d.strokeStyle = style;
    }

    context2d.strokeRect(aabb2[0], aabb2[1], aabb2[2] - aabb2[0], aabb2[3] - aabb2[1]);

    context2d.restore();
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Polygon} poly
 * @param {String} style strokeStyle/fillStyle
 * @param {Boolean=} fill
 */
function polygon(context2d, poly, style, fill) {
if ('string' !== typeof style) {
    throw new Error("style is undefined or null")
}

if (fill !== undefined) {
if ('boolean' !== typeof fill) {
    throw new Error("fill is not a boolean")
}

}
    context2d.save();

    if (poly.length < 3) {
        fill = false;
    }

    if (style !== undefined) {
        fill ? context2d.fillStyle = style : context2d.strokeStyle = style;
    }

    context2d.beginPath();
    context2d.moveTo(poly[0][0], poly[0][1]);
    var i,
        max;

    for (i = 1, max = poly.length; i < max; ++i) {
        context2d.lineTo(poly[i][0], poly[i][1]);
    }

    context2d.lineTo(poly[0][0], poly[0][1]);
    fill ? context2d.fill() : context2d.stroke();

    context2d.restore();
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {String} text
 * @param {Vec2} vec2 position
 * @param {String=} font
 */
function text(context2d, text, vec2, font) {
if ('string' !== typeof text) {
    throw new Error("text is undefined or null")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (font !== undefined) {
if ('string' !== typeof font) {
    throw new Error("font is undefined or null")
}

}
    font = font || "10pt Consolas";
    context2d.font = font;

    context2d.fillText(text, vec2[0], vec2[1]);
}
/**
 * @param {CanvasRenderingContext2D} context2d
 * @param {Matrix23} m2d
 */
function applyMatrix23(context2d, m2d) {
if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

    context2d.setTransform(m2d[0], m2d[1], m2d[2], m2d[3], m2d[4], m2d[5]);
}


var Draw = {
    invertAxis: invertAxis,
    cartesianAxis: cartesianAxis,

    vec2: vec2,
    vec2dir: vec2dir,
    rectangle: rectangle,
    circle: circle,
    line2: line2,
    triangle: triangle,
    angle: angle,
    segment2: segment2,
    aabb2: aabb2,
    polygon: polygon,

    applyMatrix23: applyMatrix23,

    text: text
};

module.exports = Draw;

},{}],15:[function(require,module,exports){
var Rectangle = require("./rectangle.js"),
    Distance = require("./distance.js"),
    Segment2 = require("./segment2.js"),
    segment2$inside = Segment2.$inside,
    AABB2 = require("./aabb2.js"),
    Vec2 = require("./vec2.js"),
    abs = Math.abs,
    sqrt = Math.sqrt,
    max = Math.max,
    min = Math.min,
    EPS = Math.EPS,
    aux_vec2 = [0, 0],

    //cache
    OUTSIDE = 1, // no collision
    PARALLEL = 2, // no collision
    INSIDE = 4, // no collision
    COLLIDE = 8, // collision
    COINCIDENT = 16,  // collision
    TANGENT = 32; // collision

/**
 * @param {Number} num
 * @param {Number} num2
 * @return {Boolean}
 */
function near(num, num2) {
if (num == undefined || Number.isNaN(num) || 'number' !== typeof num) {
    throw new Error("num is undefined or null")
}

if (num2 == undefined || Number.isNaN(num2) || 'number' !== typeof num2) {
    throw new Error("num2 is undefined or null")
}

    return num > num2 - EPS && num < num2 + EPS;
}

//
// helpers
//

/**
 * x1 < x3
 *
 * @TODO distance
 * @TODO segment collision, maybe using segment-segment collision, this could slow down things!
 *
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Number} x3
 * @param {Number} y3
 * @param {Number} x4
 * @param {Number} y4
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function $rectangle_rectangle(x1, y1, x2, y2, x3, y3, x4, y4, collision, distance) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

if (x3 == undefined || Number.isNaN(x3) || 'number' !== typeof x3) {
    throw new Error("x3 is undefined or null")
}

if (y3 == undefined || Number.isNaN(y3) || 'number' !== typeof y3) {
    throw new Error("y3 is undefined or null")
}

if (x4 == undefined || Number.isNaN(x4) || 'number' !== typeof x4) {
    throw new Error("x4 is undefined or null")
}

if (y4 == undefined || Number.isNaN(y4) || 'number' !== typeof y4) {
    throw new Error("y4 is undefined or null")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    var points,
        x_inside,
        y_inside;

    if (x2 < x3 || y1 > y4 || y2 < y3) {
        return {reason : OUTSIDE};
    }

    x_inside = x1 < x3 && x2 > x4;
    y_inside = y1 < y3 && y2 > y4;

    if (x_inside && y_inside) {
        return {reason : INSIDE};
    }

    if (collision === false) {
        return {reason: COLLIDE};
    }

    // complex cases, 4 point collision
    if (y1 > y3 && (x_inside || y_inside)) {
        points = [
            [max(x1, x3), max(y1, y3)],
            [min(x2, x4), min(y2, y4)],
            [min(x2, x4), max(y1, y3)],
            [max(x1, x3), min(y2, y4)]
        ];
    } else {
        //base case
        points = [
            [min(x2, x4), max(y1, y3)],
            [max(x1, x3), min(y2, y4)]
        ];
    }

    return {reason: COLLIDE, points : points};
}
/**
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Number} x3
 * @param {Number} y3
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function $rectangle_vec2(x1, y1, x2, y2, x3, y3, collision, distance) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

if (x3 == undefined || Number.isNaN(x3) || 'number' !== typeof x3) {
    throw new Error("x3 is undefined or null")
}

if (y3 == undefined || Number.isNaN(y3) || 'number' !== typeof y3) {
    throw new Error("y3 is undefined or null")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    if (x1 > x3 || x2 < x3 || y1 > y3 || y2 < y3) {
        return {reason: OUTSIDE};
        // TODO distance: distance ? Distance.rectangle_vec2(rectangle, vec2) : null
    }

    //if (bb[0] <= v[0] && bb[2] >= v[0] && bb[1] <= v[1] && bb[3] >= v[1]);
    if (x1 < x3 && x2 > x3 && y1 < y3 && y2 > y3) {
        return {reason: INSIDE};
        // TODO distance: distance ? Distance.rectangle_vec2(rectangle, vec2) : null
    }

    return {reason: COLLIDE, points : [[x3, y3]]};
}
/**
 * @param {Number} cx
 * @param {Number} cy
 * @param {Number} r
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function $circle_segment2(cx, cy, r, x1, y1, x2, y2, collision, distance) {
if (cx == undefined || Number.isNaN(cx) || 'number' !== typeof cx) {
    throw new Error("cx is undefined or null")
}

if (cy == undefined || Number.isNaN(cy) || 'number' !== typeof cy) {
    throw new Error("cy is undefined or null")
}

if (r == undefined || Number.isNaN(r) || 'number' !== typeof r) {
    throw new Error("r is undefined or null")
}

if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}


    var cx1 = x1 - cx,
        cy1 = y1 - cy,
        cx2 = x2 - cx,
        cy2 = y2 - cy,

        dx = cx2 - cx1,
        dy = cy2 - cy1,
        a = dx * dx + dy * dy,
        b = 2 * ((dx * cx1) + (dy * cy1)),
        c = (cx1 * cx1) + (cy1 * cy1) - (r * r),
        delta = b * b - (4 * a * c),
        u,
        u1,
        u2,
        deltasqrt,
        p,
        points;

    if (delta < 0) {
        // No intersection
        return {reason: OUTSIDE};
    }

    if (delta === 0) {
        // One intersection
        if (collision === false) {
            return {reason: TANGENT};
        }

        u = -b / (2 * a);

        p = [x1 + (u * dx), y1 + (u * dy)];

        if (segment2$inside(x1, y1, x2, y2, p[0], p[1])) {
            return {reason: TANGENT, points: [p]};
        }

        return {reason: OUTSIDE};


        /* Use LineP1 instead of LocalP1 because we want our answer in global
           space, not the circle's local space */
    }

    // NOTE do not test collision === false, here, there is no performance gain here.
    if (delta > 0) {
        // Two intersections
        deltasqrt = sqrt(delta);

        u1 = (-b + deltasqrt) / (2 * a);
        u2 = (-b - deltasqrt) / (2 * a);

        points = [];

        p = [x1 + (u1 * dx), y1 + (u1 * dy)];

        if (segment2$inside(x1, y1, x2, y2, p[0], p[1])) {
            points.push(p);
        }

        p = [x1 + (u2 * dx), y1 + (u2 * dy)];

        if (segment2$inside(x1, y1, x2, y2, p[0], p[1])) {
            points.push(p);
        }

        if (points.length) {
            return {reason: COLLIDE, points: points};
        }

        return {reason: OUTSIDE};
    }

}
/**
 * @param {Number} cx
 * @param {Number} cy
 * @param {Number} r
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function $circle_rectangle(cx, cy, r, x1, y1, x2, y2, collision, distance) {
if (cx == undefined || Number.isNaN(cx) || 'number' !== typeof cx) {
    throw new Error("cx is undefined or null")
}

if (cy == undefined || Number.isNaN(cy) || 'number' !== typeof cy) {
    throw new Error("cy is undefined or null")
}

if (r == undefined || Number.isNaN(r) || 'number' !== typeof r) {
    throw new Error("r is undefined or null")
}

if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    var points = [],
        r2,
        collide = false;

    // TODO inside test

    r2 = $circle_segment2(cx, cy, r, x1, y1, x2, y1, collision, distance);

    if (r2.reason >= COLLIDE) {
        collide = true;
        if (collision === true) {
            points.push(r2.points[0]);
            if (r2.points.length === 2) {
                points.push(r2.points[1]);
            }
        }
    }

    r2 = $circle_segment2(cx, cy, r, x1, y1, x1, y2, collision, distance);

    if (r2.reason >= COLLIDE) {
        collide = true;
        if (collision === true) {
            points.push(r2.points[0]);
            if (r2.points.length === 2) {
                points.push(r2.points[1]);
            }
        }
    }

    r2 = $circle_segment2(cx, cy, r, x1, y2, x2, y2, collision, distance);

    if (r2.reason >= COLLIDE) {
        collide = true;
        if (collision === true) {
            points.push(r2.points[0]);
            if (r2.points.length === 2) {
                points.push(r2.points[1]);
            }
        }
    }

    r2 = $circle_segment2(cx, cy, r, x2, y1, x2, y2, collision, distance);

    if (r2.reason >= COLLIDE) {
        collide = true;
        if (collision === true) {
            points.push(r2.points[0]);
            if (r2.points.length === 2) {
                points.push(r2.points[1]);
            }
        }
    }

    if (collide) {
        if (points === false) {
            return {reason: COLLIDE};
        }

        return {reason: COLLIDE, points: points};
    }

    return {reason: OUTSIDE};
}
/**
 * @param {AABB2} bb2_1
 * @param {AABB2} bb2_2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function bb2_bb2(bb2_1, bb2_2, collision, distance) {
if (!Array.isArray(bb2_1) || bb2_1[0] == undefined || Number.isNaN(bb2_1[0]) || 'number' !== typeof bb2_1[0] || bb2_1[1] == undefined || Number.isNaN(bb2_1[1]) || 'number' !== typeof bb2_1[1] || bb2_1[2] == undefined || Number.isNaN(bb2_1[2]) || 'number' !== typeof bb2_1[2] || bb2_1[3] == undefined || Number.isNaN(bb2_1[3]) || 'number' !== typeof bb2_1[3]) {
    throw new Error("invalid AABB2 bb2_1")
}

if (!Array.isArray(bb2_2) || bb2_2[0] == undefined || Number.isNaN(bb2_2[0]) || 'number' !== typeof bb2_2[0] || bb2_2[1] == undefined || Number.isNaN(bb2_2[1]) || 'number' !== typeof bb2_2[1] || bb2_2[2] == undefined || Number.isNaN(bb2_2[2]) || 'number' !== typeof bb2_2[2] || bb2_2[3] == undefined || Number.isNaN(bb2_2[3]) || 'number' !== typeof bb2_2[3]) {
    throw new Error("invalid AABB2 bb2_2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    AABB2.normalize(bb2_1, bb2_1);
    AABB2.normalize(bb2_2, bb2_2);

    // x1 should be further left!
    if (bb2_2[0] < bb2_1[0]) {
        return $rectangle_rectangle(
            bb2_2[0], bb2_2[1], bb2_2[2], bb2_2[3],
            bb2_1[0], bb2_1[1], bb2_1[2], bb2_1[3],
            collision === true,
            distance === true
        );
    }

    return $rectangle_rectangle(
        bb2_1[0], bb2_1[1], bb2_1[2], bb2_1[3],
        bb2_2[0], bb2_2[1], bb2_2[2], bb2_2[3],
        collision === true,
        distance === true
    );
}
/**
 * @param {AABB2} bb2
 * @param {Vec2} vec2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function bb2_vec2(bb2, vec2, collision, distance) {
if (!Array.isArray(bb2) || bb2[0] == undefined || Number.isNaN(bb2[0]) || 'number' !== typeof bb2[0] || bb2[1] == undefined || Number.isNaN(bb2[1]) || 'number' !== typeof bb2[1] || bb2[2] == undefined || Number.isNaN(bb2[2]) || 'number' !== typeof bb2[2] || bb2[3] == undefined || Number.isNaN(bb2[3]) || 'number' !== typeof bb2[3]) {
    throw new Error("invalid AABB2 bb2")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $rectangle_vec2(bb2[0], bb2[1], bb2[2], bb2[3], vec2[0], vec2[1], collision === true, distance === true);
}
/**
 * @param {Vec2} vec2
 * @param {AABB2} bb2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function vec2_bb2(vec2, bb2, collision, distance) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (!Array.isArray(bb2) || bb2[0] == undefined || Number.isNaN(bb2[0]) || 'number' !== typeof bb2[0] || bb2[1] == undefined || Number.isNaN(bb2[1]) || 'number' !== typeof bb2[1] || bb2[2] == undefined || Number.isNaN(bb2[2]) || 'number' !== typeof bb2[2] || bb2[3] == undefined || Number.isNaN(bb2[3]) || 'number' !== typeof bb2[3]) {
    throw new Error("invalid AABB2 bb2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $rectangle_vec2(bb2[0], bb2[1], bb2[2], bb2[3], vec2[0], vec2[1], collision === true, distance === true);
}

/**
 * @TODO segments of collision
 *
 * @param {Rectangle} rect1
 * @param {Rectangle} rect2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function rectangle_rectangle(rect1, rect2, collision, distance) {
if (!Array.isArray(rect1) || rect1[0][0] == undefined || Number.isNaN(rect1[0][0]) || 'number' !== typeof rect1[0][0] || rect1[0][1] == undefined || Number.isNaN(rect1[0][1]) || 'number' !== typeof rect1[0][1] || rect1[1][0] == undefined || Number.isNaN(rect1[1][0]) || 'number' !== typeof rect1[1][0] || rect1[1][1] == undefined || Number.isNaN(rect1[1][1]) || 'number' !== typeof rect1[1][1]) {
    throw new Error("invalid Rectangle rect1")
}

if (!Array.isArray(rect2) || rect2[0][0] == undefined || Number.isNaN(rect2[0][0]) || 'number' !== typeof rect2[0][0] || rect2[0][1] == undefined || Number.isNaN(rect2[0][1]) || 'number' !== typeof rect2[0][1] || rect2[1][0] == undefined || Number.isNaN(rect2[1][0]) || 'number' !== typeof rect2[1][0] || rect2[1][1] == undefined || Number.isNaN(rect2[1][1]) || 'number' !== typeof rect2[1][1]) {
    throw new Error("invalid Rectangle rect2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    Rectangle.normalize(rect1, rect1);
    Rectangle.normalize(rect2, rect2);

    // r1 should be further left!
    if (rect2[0][0] < rect1[0][0]) {
        return $rectangle_rectangle(
            rect2[0][0], rect2[0][1], rect2[1][0], rect2[1][1],
            rect1[0][0], rect1[0][1], rect1[1][0], rect1[1][1],
            collision === true,
            distance === true
        );
    }

    return $rectangle_rectangle(
        rect1[0][0], rect1[0][1], rect1[1][0], rect1[1][1],
        rect2[0][0], rect2[0][1], rect2[1][0], rect2[1][1],
        collision === true,
        distance === true
    );

}

/**
 * @TODO segments of collision
 *
 * @param {AABB2} bb2
 * @param {AABB2} rect
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function bb2_rectangle(bb2, rect, collision, distance) {
if (!Array.isArray(bb2) || bb2[0] == undefined || Number.isNaN(bb2[0]) || 'number' !== typeof bb2[0] || bb2[1] == undefined || Number.isNaN(bb2[1]) || 'number' !== typeof bb2[1] || bb2[2] == undefined || Number.isNaN(bb2[2]) || 'number' !== typeof bb2[2] || bb2[3] == undefined || Number.isNaN(bb2[3]) || 'number' !== typeof bb2[3]) {
    throw new Error("invalid AABB2 bb2")
}

if (!Array.isArray(rect) || rect[0] == undefined || Number.isNaN(rect[0]) || 'number' !== typeof rect[0] || rect[1] == undefined || Number.isNaN(rect[1]) || 'number' !== typeof rect[1] || rect[2] == undefined || Number.isNaN(rect[2]) || 'number' !== typeof rect[2] || rect[3] == undefined || Number.isNaN(rect[3]) || 'number' !== typeof rect[3]) {
    throw new Error("invalid AABB2 rect")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    AABB2.normalize(bb2, bb2);
    Rectangle.normalize(rect, rect);

    // r1 should be further left!
    if (bb2[0] < rect[0][0]) {
        return $rectangle_rectangle(
            rect[0][0], rect[0][1], rect[1][0], rect[1][1],
            bb2[0], bb2[1], bb2[2], bb2[3],
            collision === true,
            distance === true
        );
    }

    return $rectangle_rectangle(
        bb2[0], bb2[1], bb2[2], bb2[3],
        rect[0][0], rect[0][1], rect[1][0], rect[1][1],
        collision === true,
        distance === true
    );
}
/**
 *
 * @param {AABB2} rect
 * @param {AABB2} bb2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function rectangle_bb2(rect, bb2, collision, distance) {
if (!Array.isArray(rect) || rect[0] == undefined || Number.isNaN(rect[0]) || 'number' !== typeof rect[0] || rect[1] == undefined || Number.isNaN(rect[1]) || 'number' !== typeof rect[1] || rect[2] == undefined || Number.isNaN(rect[2]) || 'number' !== typeof rect[2] || rect[3] == undefined || Number.isNaN(rect[3]) || 'number' !== typeof rect[3]) {
    throw new Error("invalid AABB2 rect")
}

if (!Array.isArray(bb2) || bb2[0] == undefined || Number.isNaN(bb2[0]) || 'number' !== typeof bb2[0] || bb2[1] == undefined || Number.isNaN(bb2[1]) || 'number' !== typeof bb2[1] || bb2[2] == undefined || Number.isNaN(bb2[2]) || 'number' !== typeof bb2[2] || bb2[3] == undefined || Number.isNaN(bb2[3]) || 'number' !== typeof bb2[3]) {
    throw new Error("invalid AABB2 bb2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return bb2_rectangle(bb2, rect, collision, distance);
}


/**
 *
 * @param {AABB2} rect
 * @param {Vec2} vec2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function rectangle_vec2(rect, vec2, collision, distance) {
if (!Array.isArray(rect) || rect[0] == undefined || Number.isNaN(rect[0]) || 'number' !== typeof rect[0] || rect[1] == undefined || Number.isNaN(rect[1]) || 'number' !== typeof rect[1] || rect[2] == undefined || Number.isNaN(rect[2]) || 'number' !== typeof rect[2] || rect[3] == undefined || Number.isNaN(rect[3]) || 'number' !== typeof rect[3]) {
    throw new Error("invalid AABB2 rect")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $rectangle_vec2(rect[0][0], rect[0][1], rect[1][0], rect[1][1], vec2[0], vec2[1], collision === true, distance === true);
}
/**
 *
 * @param {Vec2} vec2
 * @param {AABB2} rect
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function vec2_rectangle(vec2, rect, collision, distance) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (!Array.isArray(rect) || rect[0] == undefined || Number.isNaN(rect[0]) || 'number' !== typeof rect[0] || rect[1] == undefined || Number.isNaN(rect[1]) || 'number' !== typeof rect[1] || rect[2] == undefined || Number.isNaN(rect[2]) || 'number' !== typeof rect[2] || rect[3] == undefined || Number.isNaN(rect[3]) || 'number' !== typeof rect[3]) {
    throw new Error("invalid AABB2 rect")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $rectangle_vec2(rect[0][0], rect[0][1], rect[1][0], rect[1][1], vec2[0], vec2[1], collision === true, distance === true);
}

/**
 *
 * @param {Circle} circle
 * @param {Vec2} vec2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function circle_vec2(circle, vec2, collision, distance) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    collision = collision === true;
    distance = distance === true;

    var distance_to_center = Vec2.distance(circle[0], vec2);

    if (near(distance_to_center, circle[1])) {
        return {reason: COLLIDE, points: [vec2]};
    }

    if (distance_to_center < circle[1]) {
        return {reason: INSIDE, distance: abs(distance_to_center - circle[1])};
    }
    return {reason: OUTSIDE, distance: abs(distance_to_center - circle[1])};
}
/**
 *
 * @param {Vec2} vec2
 * @param {Circle} circle
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function vec2_circle(vec2, circle, collision, distance) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    circle_vec2(circle, vec2, collision, distance);
}
/**
 *
 * @param {Circle} a_circle
 * @param {Circle} b_circle
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function circle_circle(a_circle, b_circle, collision, distance) {
if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    collision = collision === true;
    distance = distance === true;

    var c1 = a_circle[0],
        c2 = b_circle[0],
        r1 = a_circle[1],
        r2 = b_circle[1],
        r1sq = r1 * r1,
        r2sq = r2 * r2,
        // Determine minimum and maximum radius where circles can intersect
        r_max = r1 + r2,
        r_min,
        // Determine actual distance between circle circles
        c_dist_sq = Vec2.distanceSq(c1, c2),
        c_dist,
        a,
        h,
        b,
        points,
        z;

    if (c_dist_sq > r_max * r_max) {
        return {reason: OUTSIDE};
    }

    r_min = r1 - r2;

    if (c_dist_sq < r_min * r_min) {
        return {reason: INSIDE};
    }

    if (collision === false) {
        return {reason: COLLIDE};
    }

    points = [];

    c_dist = sqrt(c_dist_sq);

    a = (r1sq - r2sq + c_dist_sq) / (2 * c_dist);
    z = r1sq - a * a;
    h = sqrt(z > 0 ? z : -z);

    Vec2.lerp(aux_vec2, c1, c2, a / c_dist);

    b = h / c_dist;

    points.push([aux_vec2[0] - b * (c2[1] - c1[1]), aux_vec2[1] + b * (c2[0] - c1[0])]);
    points.push([aux_vec2[0] + b * (c2[1] - c1[1]), aux_vec2[1] - b * (c2[0] - c1[0])]);

    return {reason: COLLIDE, points: points};
}
/**
 *
 * @param {Circle} circle
 * @param {AABB2} bb2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function circle_bb2(circle, bb2, collision, distance) {
if (!Array.isArray(bb2) || bb2[0] == undefined || Number.isNaN(bb2[0]) || 'number' !== typeof bb2[0] || bb2[1] == undefined || Number.isNaN(bb2[1]) || 'number' !== typeof bb2[1] || bb2[2] == undefined || Number.isNaN(bb2[2]) || 'number' !== typeof bb2[2] || bb2[3] == undefined || Number.isNaN(bb2[3]) || 'number' !== typeof bb2[3]) {
    throw new Error("invalid AABB2 bb2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $circle_rectangle(circle[0][0], circle[0][1], circle[1],
        bb2[0], bb2[1], bb2[2], bb2[3],
        collision === true, distance === true);
}
/**
 *
 * @param {AABB2} bb2
 * @param {Circle} circle
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function bb2_circle(bb2, circle, collision, distance) {
if (!Array.isArray(bb2) || bb2[0] == undefined || Number.isNaN(bb2[0]) || 'number' !== typeof bb2[0] || bb2[1] == undefined || Number.isNaN(bb2[1]) || 'number' !== typeof bb2[1] || bb2[2] == undefined || Number.isNaN(bb2[2]) || 'number' !== typeof bb2[2] || bb2[3] == undefined || Number.isNaN(bb2[3]) || 'number' !== typeof bb2[3]) {
    throw new Error("invalid AABB2 bb2")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $circle_rectangle(circle[0][0], circle[0][1], circle[1],
        bb2[0], bb2[1], bb2[2], bb2[3],
        collision === true, distance === true);
}
/**
 *
 * @param {Circle} circle
 * @param {Rectangle} rect
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function circle_rectangle(circle, rect, collision, distance) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $circle_rectangle(circle[0][0], circle[0][1], circle[1],
        rect[0][0], rect[0][1], rect[1][0], rect[1][1],
        collision === true, distance === true);
}
/**
 *
 * @param {Rectangle} rect
 * @param {Circle} circle
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function rectangle_circle(rect, circle, collision, distance) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $circle_rectangle(circle[0][0], circle[0][1], circle[1],
        rect[0][0], rect[0][1], rect[1][0], rect[1][1],
        collision === true, distance === true);
}
/**
 *
 * @param {Circle} circle
 * @param {Segment2} seg2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function circle_segment2(circle, seg2, collision, distance) {
if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $circle_segment2(
        circle[0][0], circle[0][1], circle[1],
        seg2[0], seg2[1], seg2[2], seg2[3],
        collision === true,
        distance === true
    );
}
/**
 *
 * @param {Segment2} seg2
 * @param {Circle} circle
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function segment2_circle(seg2, circle, collision, distance) {
if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    return $circle_segment2(
        circle[0][0], circle[0][1], circle[1],
        seg2[0], seg2[1], seg2[2], seg2[3],
        collision === true,
        distance === true
    );
}
/**
 *
 * @param {Line2} line2_2
 * @param {Line2} line2_1
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function line2_line2(line2_1, line2_2, collision, distance) {
if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    collision = collision === true;
    distance = distance === true;

    var a1 = [line2_1[0][0], line2_1[0][1]],
        a2 = [0, 0], // XXX check! m,1 ??
        b1 = [line2_2[0][0], line2_2[0][1]],
        b2 = [0, 0],
        ua_t,
        ub_t,
        u_b,
        ua,
        ub;

    Vec2.add(a2, a1, [line2_1[1], 1]);
    Vec2.add(b2, b1, [line2_2[1], 1]);

    ua_t = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
    ub_t = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
    u_b  = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);

    if (u_b !== 0) {
        ua = ua_t / u_b;
        ub = ub_t / u_b;

        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
            if (collision === false) {
                return {reason: COLLIDE};
            }
            return {reason: COLLIDE, points: [[a1[0] + ua * (a2[0] - a1[0]), a1[1] + ua * (a2[1] - a1[1])]]};
        }
        return {reason: OUTSIDE};
    }
    if (ua_t === 0 || ub_t === 0) {
        return {reason: COINCIDENT};
    }
    return {reason: PARALLEL};
}
/**
 *
 * @param {Segment2} seg2_2
 * @param {Segment2} seg2_1
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function segment2_segment2(seg2_1, seg2_2, collision, distance) {
if ('boolean' !== typeof collision) {
    throw new Error("collision is not a boolean")
}

if ('boolean' !== typeof distance) {
    throw new Error("distance is not a boolean")
}

    collision = collision === true;
    distance = distance === true;

    var mua,
        mub,
        denom,
        numera,
        numerb,
        points,
        i,
        max,
        minp,
        maxp,
        dist;

    denom  = (seg2_2[3] - seg2_2[1]) * (seg2_1[2] - seg2_1[0]) - (seg2_2[2] - seg2_2[0]) * (seg2_1[3] - seg2_1[1]);
    numera = (seg2_2[2] - seg2_2[0]) * (seg2_1[1] - seg2_2[1]) - (seg2_2[3] - seg2_2[1]) * (seg2_1[0] - seg2_2[0]);
    numerb = (seg2_1[2] - seg2_1[0]) * (seg2_1[1] - seg2_2[1]) - (seg2_1[3] - seg2_1[1]) * (seg2_1[0] - seg2_2[0]);

    /* Are the line coincident? */
    if (Math.abs(numera) < Math.EPS && Math.abs(numerb) < Math.EPS && Math.abs(denom) < Math.EPS) {

        if (collision === false) {
            return {
                reason : COLLIDE
            };
        }

        // check if the intersections is a line!
        points = [];
        points.push(segment2_vec2(seg2_2, [seg2_1[0], seg2_1[1]]));
        points.push(segment2_vec2(seg2_2, [seg2_1[2], seg2_1[3]]));
        points.push(segment2_vec2(seg2_1, [seg2_2[0], seg2_2[1]]));
        points.push(segment2_vec2(seg2_1, [seg2_2[2], seg2_2[3]]));
        // now check those intersections, remove no intersections!
        max = points.length;
        minp = { distance: false, point: null};
        maxp = { distance: false, point: null};


        for (i = 0; i < max; ++i) {
            if (points[i].reason <= COLLIDE) { // no collision
                points.splice(i, 1);
                --i;
                max = points.length;
            } else {

                dist = Vec2.lengthSq(points[i].points[0]);

                if (minp.distance === false || minp.distance > dist) {
                    minp.distance = dist;
                    minp.point = points[i].points[0];
                }

                if (maxp.distance === false || minp.distance < dist) {
                    maxp.distance = dist;
                    maxp.point = points[i].points[0];
                }
            }
        }

        if (points.length > 1) {
            //line intersection!
            return {
                reason : COLLIDE,
                points: [],
                segments: [[minp.point[0], minp.point[1], maxp.point[0], maxp.point[1]]]
            };
        }

        return {
            reason : COINCIDENT
        };
    }

    /* Are the line parallel */
    if (Math.abs(denom) < Math.EPS) {
        return {reason: PARALLEL};
    }

    /* Is the intersection along the the segments */
    mua = numera / denom;
    mub = numerb / denom;
    if (mua < 0 || mua > 1 || mub < 0 || mub > 1) {
        return {reason: OUTSIDE};
    }

    if (collision === false) {
        return {reason: COLLIDE};
    }

    return {reason: COLLIDE, points: [[seg2_1[0] + mua * (seg2_1[2] - seg2_1[0]), seg2_1[1] + mua * (seg2_1[3] - seg2_1[1])]]};
}

/**
 *
 * @param {Segment2} seg2
 * @param {Vec2} vec2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function segment2_vec2(seg2, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var dis = Distance.segment2_vec2(seg2, vec2);

    if (dis === 0) {
        return {
            reason : COLLIDE,
            points: [vec2]
        };
    }

    return {
        reason : OUTSIDE,
        distance: dis
    };
}
/**
 *
 * @param {Vec2} vec2
 * @param {Segment2} seg2
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function vec2_segment2(vec2, seg2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return segment2_vec2(seg2, vec2);
}
/**
 * @TODO this is just a fast-code-version, no optimization no for real-time
 *
 * @param {Polygon} a_poly
 * @param {Polygon} b_poly
 * @param {Boolean} collision
 * @param {Boolean} distance
 */
function polygon_polygon(a_poly, b_poly) {
    var alen = a_poly.length,
        blen = b_poly.length,
        a,
        a2,
        b,
        b2,
        points = [];
    for (a = 0; a < alen; ++a) {
        a2 = a + 1;
        a2 = a2 == alen ? 0 : a2;
        for (b = 0; b < blen; ++b) {
            b2 = b + 1;
            b2 = b2 == blen ? 0 : b2;

            r = segment2_segment2(
                [a_poly[a][0], a_poly[a][1], a_poly[a2][0], a_poly[a2][1]],
                [b_poly[b][0], b_poly[b][1], b_poly[b2][0], b_poly[b2][1]],
                true,
                true
            );
            if (r.points) {
                points.push(r.points[0]);
            }

        }
    }

    if (points.length) {
        return {
            reason : COLLIDE,
            points: points,
        }
    }
    return {
        reason : OUTSIDE
    }
}

/**
 * @class Intersection
 */
var Intersection = {
    OUTSIDE: OUTSIDE,
    PARALLEL: PARALLEL,
    COLLIDE: COLLIDE,
    INSIDE: INSIDE,
    COINCIDENT: COINCIDENT,
    TANGENT: TANGENT,

    bb2_bb2: bb2_bb2,
    bb2_vec2: bb2_vec2,
    vec2_bb2: vec2_bb2,
    rectangle_rectangle: rectangle_rectangle,
    bb2_rectangle: bb2_rectangle,
    rectangle_bb2: rectangle_bb2,
    rectangle_vec2: rectangle_vec2,
    vec2_rectangle: vec2_rectangle,
    circle_vec2: circle_vec2,
    vec2_circle: vec2_circle,
    circle_circle: circle_circle,
    circle_bb2: circle_bb2,
    bb2_circle: bb2_circle,
    circle_rectangle: circle_rectangle,
    rectangle_circle: rectangle_circle,
    circle_segment2: circle_segment2,
    segment2_circle: segment2_circle,
    line2_line2: line2_line2,
    segment2_segment2: segment2_segment2,
    segment2_vec2: segment2_vec2,
    vec2_segment2: vec2_segment2,

    polygon_polygon: polygon_polygon,

    $rectangle_rectangle: $rectangle_rectangle,
    $rectangle_vec2: $rectangle_vec2,
    $circle_segment2: $circle_segment2,
    $circle_rectangle: $circle_rectangle
};


module.exports = Intersection;
},{"./aabb2.js":3,"./distance.js":13,"./rectangle.js":26,"./segment2.js":27,"./vec2.js":30}],16:[function(require,module,exports){
/*
 * Stability: 1 (Only additions & fixes)
 *
 * Point-Slope Equation of a Line: y - y1 = m(x - x1)
 */
var dx,
    dy,
    r,
    sqrt = Math.sqrt,
    tan = Math.tan,
    atan = Math.atan,
    sin = Math.sin,
    cos = Math.cos,
    near = Math.near;

/**
 * @param {Number} x
 * @param {Number} y
 * @param {Number} m
 * @return {Line2}
 */
function create(x, y, m) {
if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

if (m == undefined || Number.isNaN(m) || 'number' !== typeof m) {
    throw new Error("m is undefined or null")
}

    return [[x, y], m];
}
/**
 * @return {Line2}
 */
function zero() {
    return [[0, 0], 0];
}
/**
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Line2}
 */
function fromVec2(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    return [[v1[0], v1[1]], (v1[0] - v2[0]) / (v1[0] - v2[1])];
}
/**
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @return {Line2}
 */
function from2Points(x1, y1, x2, y2) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

    return [[x1, y1], (x1 - x2) / (y1 - y2)];
}
/**
 * @param {Segment2} seg2
 * @return {Line2}
 */
function fromSegment2(seg2) {
    return [[seg2[0], seg2[1]], (seg2[0] - seg2[2]) / (seg2[1] - seg2[3])];
}
/**
 * @param {Line2} out
 * @param {Line2} line2
 * @return {Line2}
 */
function copy(out, line2) {
    out[0][0] = line2[0][0];
    out[0][1] = line2[0][1];
    out[1] = line2[1];

    return out;
}
/**
 * @param {Line2} line2
 * @return {Line2}
 */
function clone(line2) {
    return [[line2[0][0], line2[0][1]], line2[1]];
}
/**
 * @param {Line2} out
 * @param {Line2} line2
 * @param {Vec2} v1
 * @return {Line2}
 */
function add(out, line2, v1) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    out[0][0] = line2[0][0] + v1[0];
    out[0][1] = line2[0][1] + v1[1];
    out[1] = line2[1];

    return out;
}
/**
 * @param {Line2} out
 * @param {Line2} line2
 * @param {Vec2} v1
 * @return {Line2}
 */
function subtract(out, line2, v1) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    out[0][0] = line2[0][0] - v1[0];
    out[0][1] = line2[0][1] - v1[1];
    out[1] = line2[1];

    return out;
}

/**
 * @param {Line2} out
 * @param {Line2} line2
 * @param {Vec2} offset
 * @return {Line2}
 */
function offset(out, line2, offset) {
if (!Array.isArray(offset) || offset[0] == undefined || Number.isNaN(offset[0]) || 'number' !== typeof offset[0] || offset[1] == undefined || Number.isNaN(offset[1]) || 'number' !== typeof offset[1]) {
    throw new Error("invalid Vec2 offset")
}

    out[0][0] = line2[0][0] + offset;
    out[0][1] = line2[0][1];
    out[1] = line2[1];

    return out;
}

/**
 * @param {Line2} out
 * @param {Line2} line2
 * @param {Number} radians
 * @return {Line2}
 */
function rotate(out, line2, radians) {
if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    out[0][0] = line2[0][0];
    out[0][1] = line2[0][1];

    out[1] = tan(atan(line2[1]) + radians);

    return out;
}

/**
 * @todo
 * @source http://mathcentral.uregina.ca/QQ/database/QQ.09.04/carly1.html
 * @param {Vec2} out_vec2
 * @param {Line2} line2
 * @param {Vec2} vec2
 * @return {Vec2}
 */
function closetPoint(out_vec2, line2, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var m = line2[1];
        mp = 1 / m; // optimization: do not negate

    // y = m*x + y1
    // (y - y2) = m' (x - x2)

    // m*x =  m' * x - m' * x2 + y2 - y1
    // (m - m') * x =  m' * x2 + y2 - y1
    // x =  (m' * x2 + y2 - y1) / (m - m')


    out_vec2[1] = (mp * vec2[0] + vec2[1] - line2[0][1]) / (m + mp);
    out_vec2[0] = m * out_vec2[1] + line2[0][1];

    return out_vec2;
}
/**
 * Over the line, has near check to avoid floating point errors.
 * @param {Line2} line2
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function isVec2Inside(line2, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var p = line2[0];
    return near(line2[1], (vec2[1] - p[1]) / (vec2[0] - p[0]));
}


/**
 * @class Line2
 */
var Line2 = {
    create: create,
    zero: zero,
    fromVec2: fromVec2,
    from2Points: from2Points,
    fromSegment2: fromSegment2,
    copy: copy,
    clone: clone,
    add: add,
    subtract: subtract,
    offset: offset,
    rotate: rotate,
    closetPoint: closetPoint,
    isVec2Inside: isVec2Inside,

    // alias
    translate: add,
    sub: subtract
};


module.exports = Line2;
},{}],17:[function(require,module,exports){
var clamp,
    sqrt = Math.sqrt,
    random = Math.random,
    ceil = Math.ceil,
    floor = Math.floor,
    log = Math.log,
    PI,
    QUATER_PI,
    HALF_PI,
    HALF_NPI,
    TWO_PI,
    TWO_HALF_PI,
    NPI,
    NQUATER_PI,
    NHALF_PI,
    NTWO_PI,
    NTWO_HALF_PI,
    EPS = 10e-3,
    LOG2;

PI = Math.PI;
QUATER_PI = Math.QUATER_PI = 0.25 * Math.PI;
HALF_PI = Math.HALF_PI = 0.5 * Math.PI;
HALF_NPI = Math.HALF_NPI = -0.5 * Math.PI;
TWO_PI = Math.TWO_PI = 2 * Math.PI;
TWO_HALF_PI = Math.TWO_HALF_PI = (2 * Math.PI) + Math.HALF_PI;
NPI = Math.NPI = -Math.PI;
NQUATER_PI = Math.NQUATER_PI = 0.25 * Math.NPI;
NHALF_PI = Math.NHALF_PI = 0.5 * Math.NPI;
NTWO_PI = Math.NTWO_PI = 2 * Math.NPI;
NTWO_HALF_PI = Math.NTWO_HALF_PI = (2 * Math.NPI) + Math.HALF_PI;
LOG2 = Math.LOG2 = log(2);

Math.INV_PI = 1 / Math.PI;

Math.RAD_TO_DEG = 180 / Math.PI;
Math.DEG_TO_RAD = Math.PI / 180;

// this could be useful to tweak in your app, depends on your world resolution
Math.EPS = EPS;

/**
 * Clamp @c f to be between @c min and @c max.
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 */
function near(a, b) {
if (a == undefined || Number.isNaN(a) || 'number' !== typeof a) {
    throw new Error("a is undefined or null")
}

if (b == undefined || Number.isNaN(b) || 'number' !== typeof b) {
    throw new Error("b is undefined or null")
}

    return a > b - EPS && a < b + EPS;
}

/**
 * Clamp @c f to be between @c min and @c max.
 * @param {Number} f
 * @param {Number} minv
 * @param {Number} maxv
 * @return {Number}
 */
function clamp(f, minv, maxv) {
if (f == undefined || Number.isNaN(f) || 'number' !== typeof f) {
    throw new Error("f is undefined or null")
}

if (minv == undefined || Number.isNaN(minv) || 'number' !== typeof minv) {
    throw new Error("minv is undefined or null")
}

if (maxv == undefined || Number.isNaN(maxv) || 'number' !== typeof maxv) {
    throw new Error("maxv is undefined or null")
}

    return f < minv ? minv : (f > maxv ? maxv : f);
};

/**
 * Clamp @c f to be between 0 and 1.
 * @param {Number} f
 * @return {Number}
 */
function clamp01(f) {
if (f == undefined || Number.isNaN(f) || 'number' !== typeof f) {
    throw new Error("f is undefined or null")
}

    return f < 0 ? 0 : (f > 1 ? 1 : f);
}

/**
 * Linearly interpolate (or extrapolate) between @c f1 and @c f2 by @c t percent.
 * @param {Number} f1
 * @param {Number} f2
 * @param {Number} t
 * @return {Number}
 */
function lerp(f1, f2, t) {
if (f1 == undefined || Number.isNaN(f1) || 'number' !== typeof f1) {
    throw new Error("f1 is undefined or null")
}

if (f2 == undefined || Number.isNaN(f2) || 'number' !== typeof f2) {
    throw new Error("f2 is undefined or null")
}

if (t == undefined || Number.isNaN(t) || 'number' !== typeof t) {
    throw new Error("t is undefined or null")
}

    return f1 * (1 - t) + f2 * t;
}

/**
 *
 * @param {Number} a
 * @param {Number} b
 * @param {Number} percent
 * @return {Number}
 */
function lerp2(a, b, percent) {
if (a == undefined || Number.isNaN(a) || 'number' !== typeof a) {
    throw new Error("a is undefined or null")
}

if (b == undefined || Number.isNaN(b) || 'number' !== typeof b) {
    throw new Error("b is undefined or null")
}

if (percent == undefined || Number.isNaN(percent) || 'number' !== typeof percent) {
    throw new Error("percent is undefined or null")
}

    return a + (b - a) * percent;
}

/**
 * Linearly interpolate from @c f1 to @c f2 by no more than @c d.
 *
 * @param {Number} f1
 * @param {Number} f2
 * @param {Number} d
 * @return {Number}
 */
function lerpconst(f1, f2, d) {
if (f1 == undefined || Number.isNaN(f1) || 'number' !== typeof f1) {
    throw new Error("f1 is undefined or null")
}

if (f2 == undefined || Number.isNaN(f2) || 'number' !== typeof f2) {
    throw new Error("f2 is undefined or null")
}

if (d == undefined || Number.isNaN(d) || 'number' !== typeof d) {
    throw new Error("d is undefined or null")
}

    return f1 + clamp(f2 - f1, -d, d);
}
/**
 *
 * @param {Number} min
 * @param {Number} max
 * @return {Number}
 */
function randInRange(min, max) {
if (min == undefined || Number.isNaN(min) || 'number' !== typeof min) {
    throw new Error("min is undefined or null")
}

if (max == undefined || Number.isNaN(max) || 'number' !== typeof max) {
    throw new Error("max is undefined or null")
}

    return lerp(min, max, random());
}
/**
 *
 * @param {Number} max
 * @param {Number} min
 * @return {Number}
 */
function randRange(max, min) {
if (max == undefined || Number.isNaN(max) || 'number' !== typeof max) {
    throw new Error("max is undefined or null")
}

if (min == undefined || Number.isNaN(min) || 'number' !== typeof min) {
    throw new Error("min is undefined or null")
}

    if (max === undefined) {
        return random();
    }
    min = min || 0;

    return random() * (max - min) + min;
}
/**
 *
 * @param {Number} max
 * @param {Number} min
 * @return {Number}
 */
function randInt(max, min) {
if (max == undefined || Number.isNaN(max) || 'number' !== typeof max) {
    throw new Error("max is undefined or null")
}

if (min == undefined || Number.isNaN(min) || 'number' !== typeof min) {
    throw new Error("min is undefined or null")
}

    min = min || 0;

    return floor(random() * (max - min + 1) + min);
}

/**
 *
 * @param {Number} value
 * @param {Number} snap_size
 * @return {Number}
 */
function snap(value, snap_size) {
if (value == undefined || Number.isNaN(value) || 'number' !== typeof value) {
    throw new Error("value is undefined or null")
}

if (snap_size == undefined || Number.isNaN(snap_size) || 'number' !== typeof snap_size) {
    throw new Error("snap_size is undefined or null")
}

    return floor(value / snap_size) * snap_size;
}

/**
 *
 * @param {Number} value
 * @param {Number} snap_size
 * @return {Number}
 */
function snapRound(value, snap_size) {
if (value == undefined || Number.isNaN(value) || 'number' !== typeof value) {
    throw new Error("value is undefined or null")
}

if (snap_size == undefined || Number.isNaN(snap_size) || 'number' !== typeof snap_size) {
    throw new Error("snap_size is undefined or null")
}

    var steps = value / snap_size | 0,
        remain = value - (steps * snap_size),
        rounder = remain > (snap_size / 2) ? ceil : floor;

    return rounder(value / snap_size) * snap_size;
}

/**
 * get the angle inside [-PI, +PI]
 * @param {Number} angle
 * @return {Number}
 */
function normalizeRotation(angle) {
if (angle == undefined || Number.isNaN(angle) || 'number' !== typeof angle) {
    throw new Error("angle is undefined or null")
}

    if (angle > NPI && angle < PI) {
        return angle;
    }

    angle = angle % (TWO_PI);

    if (angle < NPI) {
        angle += TWO_PI;
    } else if (angle > PI) {
        angle -= TWO_PI;
    }

    return angle;
}

/**
 * rotate the angle and return the normalized
 *
 * @param {Number} angle
 * @param {Number} target
 * @return {Number}
 */
function deltaRotation(angle, target) {
if (angle == undefined || Number.isNaN(angle) || 'number' !== typeof angle) {
    throw new Error("angle is undefined or null")
}

if (target == undefined || Number.isNaN(target) || 'number' !== typeof target) {
    throw new Error("target is undefined or null")
}

    return normalizeRotation(angle - target);
}


/**
 * Mathematical aproach rather than computaional/performance because JS Number representation is elusive
 *
 * @todo study bitwise operations can be used in all cases ?
 *
 * @param {Number} x
 * @return {Number}
 */
function powerOfTwo(x) {
if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

    next = pow(2, ceil(log(x)/LOG2));
}
/**
 * @credits Three.js
 * @param {Number} value
 * @return {Number}
 */
function isPowerOfTwo(value) {
if (value == undefined || Number.isNaN(value) || 'number' !== typeof value) {
    throw new Error("value is undefined or null")
}

   return ( value & ( value - 1 ) ) === 0 && value !== 0;
}

Math.clamp = clamp;
Math.near = near;
Math.clamp01 = clamp01;
Math.lerp = lerp;
Math.lerpconst = lerpconst;
Math.randRange = randRange;
Math.randInt = randInt;
Math.snap = snap;
Math.snapRound = snapRound;
Math.deltaRotation = deltaRotation;
Math.normalizeRadians = normalizeRotation;
Math.powerOfTwo = powerOfTwo;
Math.isPowerOfTwo = isPowerOfTwo;

},{}],18:[function(require,module,exports){
/**
 * Stability: 0 (Anything could happen)
 *
 * 2x2 matrix used for rotations 2D represented as a 5 coordinates array
 * [m11:Number, m12:Number, m21:Number, m22:Number, angle:Number]
 * Can be used to solve 2x2 matrices problems.
 *
 * @todo this need more work and testing...
 */

var cos = Math.cos,
    sin = Math.sin,
    acos = Math.acos;

/**
 * @param {Number} angle
 * @return {Matrix22}
 */
function create(angle) {
if (angle == undefined || Number.isNaN(angle) || 'number' !== typeof angle) {
    throw new Error("angle is undefined or null")
}

    return [1, 0, 0, 1, 0];
}
/**
 * @param {Number} angle
 * @return {Matrix22}
 */
function fromAngle(angle) {
if (angle == undefined || Number.isNaN(angle) || 'number' !== typeof angle) {
    throw new Error("angle is undefined or null")
}

    angle = angle || 0;
    var c = cos(angle),
        s = sin(angle);

    return [c, -s, s, c, angle];
}
/**
 * @param {Number} m11
 * @param {Number} m12
 * @param {Number} m21
 * @param {Number} m22
 * @return {Matrix22}
 */
function fromNumbers(m11, m12, m21, m22) {
if (m11 == undefined || Number.isNaN(m11) || 'number' !== typeof m11) {
    throw new Error("m11 is undefined or null")
}

if (m12 == undefined || Number.isNaN(m12) || 'number' !== typeof m12) {
    throw new Error("m12 is undefined or null")
}

if (m21 == undefined || Number.isNaN(m21) || 'number' !== typeof m21) {
    throw new Error("m21 is undefined or null")
}

if (m22 == undefined || Number.isNaN(m22) || 'number' !== typeof m22) {
    throw new Error("m22 is undefined or null")
}

    return [m11, m12, m21, m22, acos(m11)];
}
/**
 * @return {Matrix22}
 */
function zero() {
    return [0, 0, 0, 0, 0];
}
/**
 * @return {Matrix22}
 */
function identity() {
    return [1, 0, 0, 1, 0];
}
/**
 * @param {Matrix22} out
 * @param {Matrix22} mat22
 * @return {Matrix22}
 */
function copy(out, mat22) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid Matrix22 out")
}

if (!Array.isArray(mat22) || mat22[0] == undefined || Number.isNaN(mat22[0]) || 'number' !== typeof mat22[0] || mat22[1] == undefined || Number.isNaN(mat22[1]) || 'number' !== typeof mat22[1] || mat22[2] == undefined || Number.isNaN(mat22[2]) || 'number' !== typeof mat22[2] || mat22[3] == undefined || Number.isNaN(mat22[3]) || 'number' !== typeof mat22[3]) {
    throw new Error("invalid Matrix22 mat22")
}

    out[0] = mat22[0];
    out[1] = mat22[1];
    out[2] = mat22[2];
    out[3] = mat22[3];

    out[4] = mat22[4];

    return out;
}

/**
 * Solve A * x = b
 * @param {Vec2} out_vec2
 * @param {Matrix22} mat22
 * @param {Vec2} vec2
 * @return {Vec2}
 */
function solve(out_vec2, mat22, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(mat22) || mat22[0] == undefined || Number.isNaN(mat22[0]) || 'number' !== typeof mat22[0] || mat22[1] == undefined || Number.isNaN(mat22[1]) || 'number' !== typeof mat22[1] || mat22[2] == undefined || Number.isNaN(mat22[2]) || 'number' !== typeof mat22[2] || mat22[3] == undefined || Number.isNaN(mat22[3]) || 'number' !== typeof mat22[3]) {
    throw new Error("invalid Matrix22 mat22")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var x = vec2[0],
        y = vec2[1];

    var a11 = mat22[0],
        a12 = mat22[2],
        a21 = mat22[1],
        a22 = mat22[3],
        det = 1 / (a11 * a22 - a12 * a21);

    out_vec2[0] = det * (a22 * x - a12 * y);
    out_vec2[1] = det * (a11 * y - a21 * x);

    return out_vec2;
}
/**
 * @param {Matrix22} mat22
 * @return {Number}
 */
function determinant(mat22) {
if (!Array.isArray(mat22) || mat22[0] == undefined || Number.isNaN(mat22[0]) || 'number' !== typeof mat22[0] || mat22[1] == undefined || Number.isNaN(mat22[1]) || 'number' !== typeof mat22[1] || mat22[2] == undefined || Number.isNaN(mat22[2]) || 'number' !== typeof mat22[2] || mat22[3] == undefined || Number.isNaN(mat22[3]) || 'number' !== typeof mat22[3]) {
    throw new Error("invalid Matrix22 mat22")
}

    return mat22[0] * mat22[3] - mat22[1] * mat22[2];
}
/**
 * @param {Matrix22} out
 * @param {Number} radians
 * @return {Matrix22}
 */
function setRotation(out, radians) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid Matrix22 out")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    var c = cos(radians),
        s = sin(radians);

    out[0] = c;
    out[1] = -s;
    out[2] = s;
    out[3] = c;

    return out;
}
/**
 * @param {Vec2} out_vec2
 * @param {Matrix22} mat22
 * @param {Vec2} vec2
 * @return {Vec2}
 */
function rotate(out_vec2, mat22, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(mat22) || mat22[0] == undefined || Number.isNaN(mat22[0]) || 'number' !== typeof mat22[0] || mat22[1] == undefined || Number.isNaN(mat22[1]) || 'number' !== typeof mat22[1] || mat22[2] == undefined || Number.isNaN(mat22[2]) || 'number' !== typeof mat22[2] || mat22[3] == undefined || Number.isNaN(mat22[3]) || 'number' !== typeof mat22[3]) {
    throw new Error("invalid Matrix22 mat22")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out_vec2[0] = vec2[0] * mat22[0] - vec2[1] * mat22[3];
    out_vec2[1] = vec2[0] * mat22[3] + vec2[1] * mat22[0];

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Matrix22} mat22
 * @param {Vec2} vec2
 * @return {Vec2}
 */
function unrotate(out_vec2, mat22, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(mat22) || mat22[0] == undefined || Number.isNaN(mat22[0]) || 'number' !== typeof mat22[0] || mat22[1] == undefined || Number.isNaN(mat22[1]) || 'number' !== typeof mat22[1] || mat22[2] == undefined || Number.isNaN(mat22[2]) || 'number' !== typeof mat22[2] || mat22[3] == undefined || Number.isNaN(mat22[3]) || 'number' !== typeof mat22[3]) {
    throw new Error("invalid Matrix22 mat22")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out_vec2[0] = vec2[0] * mat22[0] + vec2[1] * mat22[3];
    out_vec2[1] = -vec2[0] * mat22[3] + vec2[1] * mat22[0];

    return out_vec2;
}
/**
 * @param {Matrix22} out
 * @param {Matrix22} mat22
 * @return {Matrix22}
 */
function invert(out, mat22) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3]) {
    throw new Error("invalid Matrix22 out")
}

if (!Array.isArray(mat22) || mat22[0] == undefined || Number.isNaN(mat22[0]) || 'number' !== typeof mat22[0] || mat22[1] == undefined || Number.isNaN(mat22[1]) || 'number' !== typeof mat22[1] || mat22[2] == undefined || Number.isNaN(mat22[2]) || 'number' !== typeof mat22[2] || mat22[3] == undefined || Number.isNaN(mat22[3]) || 'number' !== typeof mat22[3]) {
    throw new Error("invalid Matrix22 mat22")
}

    var a = mat22[0],
        b = mat22[2],
        c = mat22[1],
        d = mat22[3],

        det = 1 / (a * d - b * c);

    out[0] = det * d;
    out[2] = -det * b;
    out[1] = -det * c;
    out[3] = det * a;

    return out;
}

var Matrix22 = {
    create: create,
    fromAngle: fromAngle,
    fromNumbers: fromNumbers,
    zero: zero,
    identity: identity,
    copy: copy,
    solve: solve,
    determinant: determinant,
    setRotation: setRotation,
    rotate: rotate,
    unrotate: unrotate,
    invert: invert
};

module.exports = Matrix22;
},{}],19:[function(require,module,exports){
/**
 * Stability: 1 (Only additions & fixes)
 *
 * 2x3 Transformation matrix used in 2D (column-major) represented as a 8 coordinates array
 * [m11:Number, m12:Number, m13:Number, m21:Number, m22:Number, m23:Number, **cache**:Array(5), dirty:Boolean]
 * cache = [xScale:Number, yScale:Number, xSkew:Number, yScale:Number, rotation:Number]
 * * why cache? Speed improvements in exchange of memory to avoid tan/atan2/sqrt.
 * * why dirty? Matrix.transform could be expensive with large polygons, keep track of this variable to transform only when necessary.
 * @TODO dSetSkewX / dSetSkewY
 */

// cache variables
var DEG_TO_RAD = Math.DEG_TO_RAD,
    PI = Math.PI,
    cos = Math.cos,
    sin = Math.sin,
    tan = Math.tan,
    atan2 = Math.atan2,
    __x,
    __y,
    aux_vec = [0, 0],
    c = 0,
    s = 0,
    angle = 0,
    m11 = 0,
    m12 = 0,
    m21 = 0,
    m22 = 0,
    dx = 0,
    dy = 0;

/**
 * Creates a new identity 2x3 matrix
 * @return {Matrix23}
 */
function create() {
    return [1, 0, 0, 1, 0, 0, [1, 1, 0, 0, 0], false];
}

/**
 * Creates a new matrix given 4 points(a Rectangle)
 *
 * @todo
 * @see http://jsfiddle.net/dFrHS/1/
 * @return {Matrix23} a new 2x3 matrix
 */
function fromPoints() {
}

/**
 * Creates a new matrix given 4 points(a Rectangle)
 *
 * @todo
 * @see http://jsfiddle.net/dFrHS/1/
 * @return {Matrix23} a new 2x3 matrix
 */
function fromAngle() {
    return [1, 0, 0, 1, 0, 0, [1, 1, 0, 0, 0], false];
}

/**
 * Copy m2d into out
 *
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @return {Matrix23} out 2x3 matrix
 */
function copy(out, m2d) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

    out[0] = m2d[0];
    out[1] = m2d[1];
    out[2] = m2d[2];
    out[3] = m2d[3];
    out[4] = m2d[4];
    out[5] = m2d[5];

    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = m2d[6][2];
    out[6][3] = m2d[6][3];
    out[6][4] = m2d[6][4];

    out[7] = m2d[7];

    return out;
}
/**
 * Copy m2d into out
 *
 * @param {Matrix23} out destiny matrix
 * @return {Matrix23} out 2x3 matrix
 */
function identity(out) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;

    out[6][0] = 1;
    out[6][1] = 1;
    out[6][2] = 0;
    out[6][3] = 0;
    out[6][4] = 0;

    out[7] = false;

    return out;
}

/**
 * Rotates a Matrix23 by the given angle in degrees(increment rotation)
 * @note increment rotation
 *
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Number} degrees Degrees
 * @return {Matrix23} out 2x3 matrix
 */
function dRotate(out, m2d, degrees) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (degrees == undefined || Number.isNaN(degrees) || 'number' !== typeof degrees) {
    throw new Error("degrees is undefined or null")
}

    return rotate(out, m2d, degrees * DEG_TO_RAD);
}
/**
 * Rotates a Matrix23 by the given angle in radians(increment rotation)
 * @note increment rotation
 *
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Number} radians Radians
 * @return {Matrix23} out 2x3 matrix
 */
function rotate(out, m2d, radians) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    c = cos(radians);
    s = sin(radians);
    m11 = m2d[0] * c +  m2d[2] * s;
    m12 = m2d[1] * c +  m2d[3] * s;
    m21 = m2d[0] * -s + m2d[2] * c;
    m22 = m2d[1] * -s + m2d[3] * c;

    out[0] = m11;
    out[1] = m12;
    out[2] = m21;
    out[3] = m22;

    // copy
    out[4] = m2d[4];
    out[5] = m2d[5];
    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = m2d[6][2];
    out[6][3] = m2d[6][3];
    out[6][4] = m2d[6][4] + radians;

    out[7] = true;

    return out;
}

/**
 * Set rotation of a Matrix23 by the given angle in degrees(set rotation)
 * @note set rotation
 *
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Number} degrees Degrees
 * @return {Matrix23} out 2x3 matrix
 */
function dRotation(out, m2d, degrees) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (degrees == undefined || Number.isNaN(degrees) || 'number' !== typeof degrees) {
    throw new Error("degrees is undefined or null")
}

    return rotation(out, m2d, degrees * DEG_TO_RAD);
}

/**
 * Set rotation of a Matrix23 by the given angle in radians(set rotation)
 * @note set rotation
 *
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Number} radians Radians
 * @return {Matrix23} out 2x3 matrix
 */
function rotation(out, m2d, radians) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    c = radians - out[6][4];

    rotate(out, m2d, c);

    out[6][4] = radians;
    out[7] = true;

    return out;
}

/**
 * Translates given Matrix23 by the dimensions in the given vec2
 * @note This translation is affected by rotation/skew
 * @note increment position
 * @see gTranslate
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Vec2} vec2 amount to be translated
 * @return {Matrix23} out 2x3 matrix
 */
function translate(out, m2d, vec2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out[0] = m2d[0];
    out[1] = m2d[1];
    out[2] = m2d[2];
    out[3] = m2d[3];
    out[4] = m2d[4] + m2d[0] * vec2[0] + m2d[2] * vec2[1];
    out[5] = m2d[5] + m2d[1] * vec2[0] + m2d[3] * vec2[1];

    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = m2d[6][2];
    out[6][3] = m2d[6][3];
    out[6][4] = m2d[6][4];

    out[7] = true;

    return out;
}

/**
 * Translates given Matrix23 by the dimensions in the given vec2
 * @note This translation is NOT affected by rotation/skew
 * @note increment position
 * @see translate
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Vec2} vec2 amount to be translated
 * @return {Matrix23} out 2x3 matrix
 */
function gTranslate(out, m2d, vec2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out[0] = m2d[0];
    out[1] = m2d[1];
    out[2] = m2d[2];
    out[3] = m2d[3];
    out[4] = m2d[4] + vec2[0];
    out[5] = m2d[5] + vec2[1];

    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = m2d[6][2];
    out[6][3] = m2d[6][3];
    out[6][4] = m2d[6][4];

    out[7] = true;

    return out;
}

/**
 * Set Matrix23 position
 * @note This translation is NOT affected by rotation/skew
 * @note set position
 * @see gTranslate
 * @see translate
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Vec2} vec2 destiny position
 * @return {Matrix23} out 2x3 matrix
 */
function position(out, m2d, vec2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out[0] = m2d[0];
    out[1] = m2d[1];
    out[2] = m2d[2];
    out[3] = m2d[3];
    out[4] = vec2[0];
    out[5] = vec2[1];

    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = m2d[6][2];
    out[6][3] = m2d[6][3];
    out[6][4] = m2d[6][4];

    out[7] = true;

    return out;
}

/**
 * Scales the Matrix23 by the dimensions in the given vec2

 * @note incremental scale
 * @note do not affect position
 * @see scalation
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Vec2} vec2 destiny position
 * @return {Matrix23} out 2x3 matrix
 */
function scale(out, m2d, vec2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    __x = vec2[0];
    __y = vec2[1];

    out[0] = m2d[0] * __x;
    out[1] = m2d[1] * __x;
    out[2] = m2d[2] * __y;
    out[3] = m2d[3] * __y;
    out[4] = m2d[4];
    out[5] = m2d[5];

    out[6][0] = m2d[6][0] * __x;
    out[6][1] = m2d[6][1] * __y;
    out[6][2] = m2d[6][2];
    out[6][3] = m2d[6][3];
    out[6][4] = m2d[6][4];

    out[7] = true;

    return out;
}

/**
 * Set the Matrix23 scale by the dimensions in the given vec2

 * @note set scale
 * @note do not affect position
 * @see scale
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Vec2} vec2 destiny position
 * @return {Matrix23} out 2x3 matrix
 */
function scalation(out, m2d, vec2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return scale(out, m2d, [vec2[0] / m2d[6][0], vec2[1] / m2d[6][1]]);
}

/**
 * Increment the Matrix23 x-skew by given degrees
 *
 * @note increment skewX
 * @see skewX
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Number} degrees Degrees to skew
 * @return {Matrix23} out 2x3 matrix
 */
function dSkewX(out, m2d, degrees) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (degrees == undefined || Number.isNaN(degrees) || 'number' !== typeof degrees) {
    throw new Error("degrees is undefined or null")
}

    return skewX(out, m2d, degrees * DEG_TO_RAD);
}
/**
 * Increment the Matrix23 x-skew by given radians
 *
 * @note increment skewX
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Number} radians Radians to skew
 * @return {Matrix23} out 2x3 matrix
 */
function skewX(out, m2d, radians) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    angle = tan(radians);

    out[0] = m2d[0];
    out[1] = m2d[1];
    out[2] = m2d[2] + m2d[0] * angle;
    out[3] = m2d[3] + m2d[1] * angle;
    out[4] = m2d[4];
    out[5] = m2d[5];

    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = m2d[6][2] + radians;
    out[6][3] = m2d[6][3];
    out[6][4] = m2d[6][4];

    out[7] = true;

    return out;
}

/**
 * Increment the Matrix23 y-skew by given degrees
 *
 * @note increment skewY
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Number} degrees Degrees to skew
 * @return {Matrix23} out 2x3 matrix
 */
function dSkewY(out, m2d, degrees) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (degrees == undefined || Number.isNaN(degrees) || 'number' !== typeof degrees) {
    throw new Error("degrees is undefined or null")
}

    return skewY(out, m2d, degrees * DEG_TO_RAD);
}
/**
 * Increment the Matrix23 y-skew by given radians
 *
 * @note increment skewY
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Number} radians Radians to skew
 * @return {Matrix23} out 2x3 matrix
 */
function skewY(out, m2d, radians) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    angle = tan(radians);

    out[0] = m2d[0] + m2d[2] * angle;
    out[1] = m2d[1] + m2d[3] * angle;
    out[2] = m2d[2];
    out[3] = m2d[3];
    out[4] = m2d[4];
    out[5] = m2d[5];

    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = m2d[6][2];
    out[6][3] = m2d[6][3] + angle;
    out[6][4] = m2d[6][4];

    out[7] = true;

    return out;
}

/**
 * Increment the Matrix23 skew y by given degrees in vec2_degrees
 *
 * @note increment skew
 * @see dSetSkew
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Vec2} vec2_degrees Degrees to skew
 * @return {Matrix23} out 2x3 matrix
 */
function dSkew(out, m2d, vec2_degrees) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2_degrees) || vec2_degrees[0] == undefined || Number.isNaN(vec2_degrees[0]) || 'number' !== typeof vec2_degrees[0] || vec2_degrees[1] == undefined || Number.isNaN(vec2_degrees[1]) || 'number' !== typeof vec2_degrees[1]) {
    throw new Error("invalid Vec2 vec2_degrees")
}

    aux_vec[0] = vec2_degrees[0] * DEG_TO_RAD;
    aux_vec[1] = vec2_degrees[1] * DEG_TO_RAD;

    return skew(out, m2d, aux_vec);
}

/**
 * Increment the Matrix23 skew y by given radians in vec2
 *
 * @note increment skew
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Vec2} vec2_radians Radians to skew
 * @return {Matrix23} out 2x3 matrix
 */
function skew(out, m2d, vec2_radians) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2_radians) || vec2_radians[0] == undefined || Number.isNaN(vec2_radians[0]) || 'number' !== typeof vec2_radians[0] || vec2_radians[1] == undefined || Number.isNaN(vec2_radians[1]) || 'number' !== typeof vec2_radians[1]) {
    throw new Error("invalid Vec2 vec2_radians")
}

    c = tan(vec2_radians[0]);
    s = tan(vec2_radians[1]);

    out[0] = m2d[0] + m2d[2] * s;
    out[1] = m2d[1] + m2d[3] * s;
    out[2] = m2d[2] + m2d[0] * c;
    out[3] = m2d[3] + m2d[1] * c;
    out[4] = m2d[4];
    out[5] = m2d[5];

    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = m2d[6][2] + vec2_radians[0];
    out[6][3] = m2d[6][3] + vec2_radians[1];
    out[6][4] = m2d[6][4];

    out[7] = true;

    return out;
}
/**
 * Set the Matrix23 skew y by given degrees in vec2_degrees
 *
 * @note set skew
 * @see setSkew
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Vec2} vec2_degrees Degrees to skew
 * @return {Matrix23} out 2x3 matrix
 */
function dSetSkew(out, m2d, vec2_degrees) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2_degrees) || vec2_degrees[0] == undefined || Number.isNaN(vec2_degrees[0]) || 'number' !== typeof vec2_degrees[0] || vec2_degrees[1] == undefined || Number.isNaN(vec2_degrees[1]) || 'number' !== typeof vec2_degrees[1]) {
    throw new Error("invalid Vec2 vec2_degrees")
}

    aux_vec[0] = vec2_degrees[0] * DEG_TO_RAD;
    aux_vec[1] = vec2_degrees[1] * DEG_TO_RAD;

    return setSkew(out, m2d, aux_vec);
}

/**
 * Set the Matrix23 skew y by given radians in vec2
 *
 * @note set skew
 * @param {Matrix23} out destiny matrix
 * @param {Matrix23} m2d source matrix
 * @param {Vec2} vec2_radians Radians to skew
 * @return {Matrix23} out 2x3 matrix
 */
function setSkew(out, m2d, vec2_radians) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2_radians) || vec2_radians[0] == undefined || Number.isNaN(vec2_radians[0]) || 'number' !== typeof vec2_radians[0] || vec2_radians[1] == undefined || Number.isNaN(vec2_radians[1]) || 'number' !== typeof vec2_radians[1]) {
    throw new Error("invalid Vec2 vec2_radians")
}

    c = tan(vec2_radians[0] - m2d[6][2]);
    s = tan(vec2_radians[1] - m2d[6][3]);

    out[0] = m2d[0] + m2d[2] * s;
    out[1] = m2d[1] + m2d[3] * s;
    out[2] = m2d[2] + m2d[0] * c;
    out[3] = m2d[3] + m2d[1] * c;
    out[4] = m2d[4];
    out[5] = m2d[5];

    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = vec2_radians[0];
    out[6][3] = vec2_radians[1];
    out[6][4] = m2d[6][4];

    out[7] = true;

    return out;
}


/**
 * Multiplies two Matrix23's
 *
 * @param {Matrix23} out destiny matrix(A*B)
 * @param {Matrix23} m2d A matrix
 * @param {Matrix23} m2d_2 B matrix
 * @return {Matrix23} out 2x3 matrix
 */
function multiply(out, m2d, m2d_2) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(m2d_2) || m2d_2[0] == undefined || Number.isNaN(m2d_2[0]) || 'number' !== typeof m2d_2[0] || m2d_2[1] == undefined || Number.isNaN(m2d_2[1]) || 'number' !== typeof m2d_2[1] || m2d_2[2] == undefined || Number.isNaN(m2d_2[2]) || 'number' !== typeof m2d_2[2] || m2d_2[3] == undefined || Number.isNaN(m2d_2[3]) || 'number' !== typeof m2d_2[3] || m2d_2[4] == undefined || Number.isNaN(m2d_2[4]) || 'number' !== typeof m2d_2[4] || m2d_2[5] == undefined || Number.isNaN(m2d_2[5]) || 'number' !== typeof m2d_2[5]) {
    throw new Error("invalid Matrix23 m2d_2")
}

    m11 = m2d[0] * m2d_2[0] + m2d[2] * m2d_2[1];
    m12 = m2d[1] * m2d_2[0] + m2d[3] * m2d_2[1];

    m21 = m2d[0] * m2d_2[2] + m2d[2] * m2d_2[3];
    m22 = m2d[1] * m2d_2[2] + m2d[3] * m2d_2[3];

    dx = m2d[0] * m2d_2[4] + m2d[2] * m2d_2[5] + m2d[4];
    dy = m2d[1] * m2d_2[4] + m2d[3] * m2d_2[5] + m2d[5];

    out[0] = m11;
    out[1] = m12;
    out[2] = m21;
    out[3] = m22;
    out[4] = dx;
    out[5] = dy;


    out[6][0] = m2d[6][0];
    out[6][1] = m2d[6][1];
    out[6][2] = m2d[6][2];
    out[6][3] = m2d[6][3];
    out[6][4] = m2d[6][4];

    out[7] = true;

    return out;
}

/**
 * Multiplies a Matrix23 and a Vec2
 *
 * @param {Vec2} out_vec2 destiny Vec2
 * @param {Matrix23} m2d source Matrix23
 * @param {Vec2} vec2
 * @return {Vec2} out_vec2, result Vec2
 */
function multiplyVec2(out_vec2, m2d, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out_vec2[0] = vec2[0] * m2d[0] + vec2[0] * m2d[2] + vec2[0] * m2d[4];
    out_vec2[1] = vec2[1] * m2d[1] + vec2[1] * m2d[3] + vec2[1] * m2d[5];

    return out_vec2;
}

/**
 * Retrieve current position as Vec2
 *
 * @param {Vec2} out_vec2 destiny Vec2
 * @param {Matrix23} m2d source Matrix23
 * @return {Vec2} out_vec2, result Vec2
 */
function getPosition(out_vec2, m2d) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

    out_vec2[0] = m2d[4];
    out_vec2[1] = m2d[5];

    return out_vec2;
}

/**
 * Retrieve current scale as Vec2
 *
 * @param {Vec2} out_vec2 destiny Vec2
 * @param {Matrix23} m2d source Matrix23
 * @return {Vec2} out_vec2, result Vec2
 */
function getScale(out_vec2, m2d) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

    out_vec2[0] = m2d[6][0];
    out_vec2[1] = m2d[6][1];

    return out_vec2;
}

/**
 * Retrieve current skew as Vec2
 *
 * @param {Vec2} out_vec2 destiny Vec2
 * @param {Matrix23} m2d source Matrix23
 * @return {Vec2} out_vec2, result Vec2
 */
function getSkew(out_vec2, m2d) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

    out_vec2[0] = m2d[6][2];
    out_vec2[1] = m2d[6][3];

    return out_vec2;
}

/**
 * Alias of rotate 180(PI)
 *
 * @param {Matrix23} out destiny Matrix23
 * @param {Matrix23} m2d source Matrix23
 * @return {Matrix23} out 2x3 matrix
 */
function reflect(out, m2d) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

    return rotate(out, m2d, PI);
}

/**
 * @TODO needed ?
 * @param {Matrix23} out destiny Matrix23
 * @param {Matrix23} m2d source Matrix23
 */
function transpose(out, m2d) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

}

/**
 * @TODO review & test
 * @param {Matrix23} m2d source Matrix23
 * @return {Number}
 */
function determinant(m2d) {
if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

    var fCofactor00 = m2d[1][1] * m2d[2][2] - m2d[1][2] * m2d[2][1],
        fCofactor10 = m2d[1][2] * m2d[2][0] - m2d[1][0] * m2d[2][2],
        fCofactor20 = m2d[1][0] * m2d[2][1] - m2d[1][1] * m2d[2][0];

    return m2d[0][0] * fCofactor00 +
        m2d[0][1] * fCofactor10 +
        m2d[0][2] * fCofactor20;

}


/**
 * Returns a 3x2 2D column-major translation matrix for x and y.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Matrix23} a new 2x3 matrix
 */
function translationMatrix(x, y) {
if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

    return [ 1, 0, 0, 1, x, y ];
}

/**
 * Returns a 3x2 2D column-major y-skew matrix for the given degrees.
 *
 * @param {Number} degrees
 * @return {Matrix23} a new 2x3 matrix
 */
function dSkewXMatrix(degrees) {
if (degrees == undefined || Number.isNaN(degrees) || 'number' !== typeof degrees) {
    throw new Error("degrees is undefined or null")
}

    return [ 1, 0, tan(degrees * 0.017453292519943295769236907684886), 1, 0, 0 ];
}

/**
 * Returns a 3x2 2D column-major y-skew matrix for the given radians.
 *
 * @param {Number} radians
 * @return {Matrix23} a new 2x3 matrix
 */
function skewXMatrix(radians) {
if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    return [ 1, 0, tan(radians), 1, 0, 0 ];
}

/**
 * Returns a 3x2 2D column-major y-skew matrix for the given degrees.
 *
 * @param {Number} degrees
 * @return {Matrix23} a new 2x3 matrix
 */
function dSkewYMatrix(degrees) {
if (degrees == undefined || Number.isNaN(degrees) || 'number' !== typeof degrees) {
    throw new Error("degrees is undefined or null")
}

    return [ 1, tan(degrees * 0.017453292519943295769236907684886), 0, 1, 0, 0 ];
}

/**
 * Returns a 3x2 2D column-major y-skew matrix for the given radians.
 *
 * @param {Number} radians
 * @return {Matrix23} a new 2x3 matrix
 */
function skewYMatrix(radians) {
if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    return [ 1, tan(radians), 0, 1, 0, 0 ];
}

/**
 * Returns a 3x2 2D column-major y-skew matrix for the given radians.
 *
 * @param {Number} radians
 * @return {Matrix23} a new 2x3 matrix
 */
function rotationMatrix(radians) {
if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    var c = cos(radians),
        s = sin(radians);

    return [c, -s, s, c, 0, 0 ];
}


/**
 * Returns a 3x2 2D column-major scaling matrix for x and y.
 *
 * @param {Number} x
 * @param {Number} y
 */
function scalingMatrix(x, y) {
if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

    return [ x, 0, 0, y, 0, 0 ];
}


/**
 * Interpolate two matrixes by given factor.
 * Used in conjunction with Transitions and you will have nice transformations :)
 *
 * @param {Matrix23} out
 * @param {Matrix23} m2d first matrix
 * @param {Matrix23} m2d_2 second matrix
 * @param {Number} factor
 * @return {Matrix23}
 */
function interpolate(out, m2d, m2d_2, factor) {
if (!Array.isArray(out) || out[0] == undefined || Number.isNaN(out[0]) || 'number' !== typeof out[0] || out[1] == undefined || Number.isNaN(out[1]) || 'number' !== typeof out[1] || out[2] == undefined || Number.isNaN(out[2]) || 'number' !== typeof out[2] || out[3] == undefined || Number.isNaN(out[3]) || 'number' !== typeof out[3] || out[4] == undefined || Number.isNaN(out[4]) || 'number' !== typeof out[4] || out[5] == undefined || Number.isNaN(out[5]) || 'number' !== typeof out[5]) {
    throw new Error("invalid Matrix23 out")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(m2d_2) || m2d_2[0] == undefined || Number.isNaN(m2d_2[0]) || 'number' !== typeof m2d_2[0] || m2d_2[1] == undefined || Number.isNaN(m2d_2[1]) || 'number' !== typeof m2d_2[1] || m2d_2[2] == undefined || Number.isNaN(m2d_2[2]) || 'number' !== typeof m2d_2[2] || m2d_2[3] == undefined || Number.isNaN(m2d_2[3]) || 'number' !== typeof m2d_2[3] || m2d_2[4] == undefined || Number.isNaN(m2d_2[4]) || 'number' !== typeof m2d_2[4] || m2d_2[5] == undefined || Number.isNaN(m2d_2[5]) || 'number' !== typeof m2d_2[5]) {
    throw new Error("invalid Matrix23 m2d_2")
}

if (factor == undefined || Number.isNaN(factor) || 'number' !== typeof factor) {
    throw new Error("factor is undefined or null")
}

    out[0] = m2d[0] + ((m2d_2[0] - m2d[0]) * factor);
    out[1] = m2d[1] + ((m2d_2[1] - m2d[1]) * factor);
    out[2] = m2d[2] + ((m2d_2[2] - m2d[2]) * factor);
    out[3] = m2d[3] + ((m2d_2[3] - m2d[3]) * factor);
    out[4] = m2d[4] + ((m2d_2[4] - m2d[4]) * factor);
    out[5] = m2d[5] + ((m2d_2[5] - m2d[5]) * factor);

    var o = out[6],
        i1 = m2d[6],
        i2 = m2d_2[6];

    o[0] = i1[0] + ((i2[0] - i1[0]) * factor);
    o[1] = i1[1] + ((i2[1] - i1[1]) * factor);
    o[2] = i1[2] + ((i2[2] - i1[2]) * factor);
    o[3] = i1[3] + ((i2[3] - i1[3]) * factor);
    o[4] = i1[4] + ((i2[4] - i1[4]) * factor);

    out[7] = m2d[7];

    return out;
}

/**
 * For completeness because it's not need in the current implementation just get: m2d[6][4]
 *
 * @param {Matrix23} m2d
 */
function toAngle(m2d) {
if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

    return atan2(m2d[1], m2d[0]);
}
/**
 * Transform a vector by given matrix
 *
 * @param {Vec2} out_vec2
 * @param {Matrix23} m2d
 * @param {Vec2} vec2
 * @return {Vec2}
 */
function transform(out_vec2, m2d, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var x = vec2[0] * m2d[0] + vec2[1] * m2d[2] + m2d[4],
        y = vec2[0] * m2d[1] + vec2[1] * m2d[3] + m2d[5];

    out_vec2[0] = x;
    out_vec2[1] = y;

    return out_vec2;
}


var Matrix23 =  {
    create: create,
    fromPoints: fromPoints,
    copy: copy,
    identity: identity,
    dRotate: dRotate,
    rotate: rotate,
    dRotation: dRotation,
    rotation: rotation,
    translate: translate,
    gTranslate: gTranslate,
    position: position,
    scale: scale,
    scalation: scalation,
    dSkewX: dSkewX,
    skewX: skewX,
    dSkewY: dSkewY,
    skewY: skewY,
    dSkew: dSkew,
    skew: skew,
    dSetSkew: dSetSkew,
    setSkew: setSkew,
    multiply: multiply,
    multiplyVec2: multiplyVec2,
    getPosition: getPosition,
    getScale: getScale,
    getSkew: getSkew,
    reflect: reflect,
    transpose: transpose,
    determinant: determinant,
    translationMatrix: translationMatrix,
    dSkewXMatrix: dSkewXMatrix,
    skewXMatrix: skewXMatrix,
    dSkewYMatrix: dSkewYMatrix,
    skewYMatrix: skewYMatrix,
    scalingMatrix: scalingMatrix,
    rotationMatrix: rotationMatrix,

    interpolate: interpolate,
    transform: transform,

    toAngle: toAngle,

    // alias
    dSetRotation: dRotation,
    setRotation: rotation,
    setPosition: position,
    setScale: scalation,
};

module.exports = Matrix23;

},{}],20:[function(require,module,exports){
/**
 * Stability: 2 (fixes / performance improvements)
 * ~Quadtree implementation that allow to override the number of subdivision for the first level
 * This is specially useful for rectangular worlds
 *
 * @reference http://en.wikipedia.org/wiki/Quadtree
 */

var AABB2 = require("./aabb2.js"),
    AABB2_fromAABB2Division = AABB2.fromAABB2Division,
    AABB2_contains = AABB2.contains;

/**
 * Constructor
 * @param {AABB2} aabb2
 * @param {Number=} maxObjects
 * @param {Number=} maxLevels
 * @param {Vec2=} subdivisions
 */
function NMtree(aabb2, maxObjects, maxLevels, subdivisions) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

if (maxObjects !== undefined) {
if (maxObjects == undefined || Number.isNaN(maxObjects) || 'number' !== typeof maxObjects) {
    throw new Error("maxObjects is undefined or null")
}

}
if (maxLevels !== undefined) {
if (maxLevels == undefined || Number.isNaN(maxLevels) || 'number' !== typeof maxLevels) {
    throw new Error("maxLevels is undefined or null")
}

}
if (subdivisions !== undefined) {
if (!Array.isArray(subdivisions) || subdivisions[0] == undefined || Number.isNaN(subdivisions[0]) || 'number' !== typeof subdivisions[0] || subdivisions[1] == undefined || Number.isNaN(subdivisions[1]) || 'number' !== typeof subdivisions[1]) {
    throw new Error("invalid Vec2 subdivisions")
}

}
    this.objects = [];
    this.bounds = aabb2;
    this.maxObjects = maxObjects || 10;
    this.maxLevels = maxLevels || 4;
    this.subdivisions = subdivisions || [2, 2];
}

NMtree.prototype.level = 0;
NMtree.prototype.maxLevels = 4;
NMtree.prototype.maxObjects = 10;
NMtree.prototype.subtrees = null;
NMtree.prototype.bounds = null;
NMtree.prototype.objects = [];
NMtree.prototype.subdivisions = [2, 2];

NMtree.prototype.divide = function () {
    var objs = this.objects,
        i,
        j,
        max,
        bounds = AABB2_fromAABB2Division(this.bounds, this.subdivisions[0], this.subdivisions[1]),
        qt;

    this.subtrees = [];
    this.objects = [];

    for (j = 0, max = bounds.length; j < max; j++) {
        qt = new NMtree(bounds[j]),// this.maxObjects, this.maxLevels);

        qt.level = this.level + 1; // manually set
        this.subtrees.push(qt);
    }
    for (i = 0, max = objs.length; i < max; i++) {
        if (!this.subinsert(objs[i])) {
            this.objects.push(objs[i]);
        }
    }
};

/**
 * @param {Object}
 */
NMtree.prototype.subinsert = function (obj) {
    if (!this.subtrees) {
        return false;
    }

    var j = 0,
        max = this.subtrees.length;
    while (j < max && !this.subtrees[j].insert(obj.bounds, obj.userdata)) {
        ++j;
    }

    return j !== max;
};

/**
 * @param {AABB2} aabb2
 * @param {Mixed} userdata
 */
NMtree.prototype.insert = function (aabb2, userdata) {
    if (AABB2_contains(this.bounds, aabb2)) {
        var obj = {bounds: aabb2, userdata: userdata};

        if (!this.subinsert(obj)) {
            if (!this.subtrees && this.objects.length === this.maxObjects && this.level < this.maxLevels) {
                this.divide();
                if (this.subinsert(obj)) { //retry
                    return true;
                }
            }
            this.objects.push(obj);
        }
        return true;
    }
    return false;
};

/**
 * @param {Mixed} userdata
 * @param {Array} out
 */
NMtree.prototype.retrieve = function (userdata, out) {
    out = out || [];

    var i,
        max,
        objs = this.objects,
        found;

    if (objs && objs.length) {
        for (i = 0, max = objs.length; i < max && !found; i++) {
            if (objs[i].userdata === userdata) {
                found = true;
            }
        }
    }

    if (found) {
        this.iterate(function (qt) {
            if (qt.objects) {
                var i,
                    max;
                for (i = 0, max = qt.objects.length; i < max; ++i) {
                    out.push(qt.objects[i]);
                }
            }
        });

        return out;
    } else if (this.subtrees) {
        for (i = 0, max = this.subtrees.length; i < max; i++) {
            this.subtrees[i].retrieve(userdata, out);
        }
    }

    return out;
};

/**
 * @param {Function} callback
 */
NMtree.prototype.iterate = function (callback) {
    var i,
        max;

    callback(this);

    if (this.subtrees) {
        for (i = 0, max = this.subtrees.length; i < max; ++i) {
            this.subtrees[i].iterate(callback);
        }
    }
};

/**
 * @param {Mixed} userdata
 */
NMtree.prototype.remove = function (userdata) {
    var i,
        max,
        objs = this.objects,
        found;

    if (objs && objs.length) {
        for (i = 0, max = objs.length; i < max && !found; i++) {
            if (objs[i].userdata === userdata) {
                objs.splice(i, 1);
                return true;
            }
        }
    }

    if (this.subtrees) {
        for (i = 0, max = this.subtrees.length; i < max; i++) {
            if (this.subtrees[i].remove(userdata)) {
                return true;
            }
        }
    }
    return false;
};

module.exports = NMtree;
},{"./aabb2.js":3}],21:[function(require,module,exports){
var object = require("object-enhancements"),
    Xorshift = require("./xorshift.js"),
    GRAD3 = [
        [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
        [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
        [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
    ],

    GRAD4 = [
        [0, 1, 1, 1],  [0, 1, 1, -1],  [0, 1, -1, 1],  [0, 1, -1, -1],
        [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1],
        [1, 0, 1, 1],  [1, 0, 1, -1],  [1, 0, -1, 1],  [1, 0, -1, -1],
        [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1],
        [1, 1, 0, 1],  [1, 1, 0, -1],  [1, -1, 0, 1],  [1, -1, 0, -1],
        [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1],
        [1, 1, 1, 0],  [1, 1, -1, 0],  [1, -1, 1, 0],  [1, -1, -1, 0],
        [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]
    ],

    SIMPLEX = [
        [0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0],
        [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0],
        [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
        [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0],
        [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0],
        [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
        [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0],
        [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]
    ],
    sqrt = Math.sqrt,
    floor = Math.floor,
    random = Math.random,
    sqrt_of_3 = sqrt(3),

    Noise = {};

// from: http://jsdo.it/akm2/fhMC/js
// don't know the author, if you are contact me.
// I just lint the code (a little)... and adapt it to the lib philosophy (that means remove 3d noises)

//@TODO optimize, there is performance gain everywhere!


// Common helpers

function _dot2d(g, x, y) {
    return g[0] * x + g[1] * y;
}

function _dot3d(g, x, y, z) {
    return g[0] * x + g[1] * y + g[2] * z;
}

// Simplex helper

function _dot4d(g, x, y, z, w) {
    return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
}

// Classic helpers

function _mix(a, b, t) {
    return (1 - t) * a + t * b;
}

function _fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}



/*
 * @reference http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
 *
 * Tiling Example (heavy...)
 *
 * var perlinNoise = new PerlinNoise();
 *
 * function tilingNoise2d(x, y, w, h) {
 *     return (perlinNoise.noise(x, y) * (w - x) * (h - y) +
 *         perlinNoise.noise(x - w, y) * x * (h - y) +
 *         perlinNoise.noise(x - w, y - h) * x * y +
 *         perlinNoise.noise(x, y - h) * (w - x) * y) / (w * h);
 */


/**
 * @class ClassicNoise
 * @param {Number} seed
 */
function ClassicNoise(seed) {
if (seed == undefined || Number.isNaN(seed) || 'number' !== typeof seed) {
    throw new Error("seed is undefined or null")
}

    this.seed(seed);
}

ClassicNoise.prototype = {
    _octaves: 4,
    _fallout: 0.5,

    seed: function (seed) {
        var random = Xorshift.create(seed || new Date().getTime()).random,
            i,
            p = [],
            perm = [];

        for (i = 0; i < 256; i++) {
            p[i] = floor(random() * 256);
        }

        for (i = 0; i < 512; i++) {
            perm[i] = p[i & 255];
        }

        this._perm = perm;
    },

    octaves: function (octaves) {
        if (!arguments.length) {
            return this._octaves;
        }
        return this._octaves = octaves;
    },

    fallout: function (fallout) {
        if (!arguments.length) {
            return this._fallout;
        }
        return this._fallout = fallout;
    },

    noise: function (x, y) {
        var result = 0,
            noise,
            f = 1,
            oct = this._octaves,
            amp = 0.5,
            fallout = this._fallout,
            i;

        for (i = 0; i < oct; ++i) {
            result += (1 + this.noise2d(x * f, y * f)) * amp * 0.5;
            amp *= fallout;
            f *= 2;
        }

        return result;
    },

    noise2d: function (x, y) {
        var X = floor(x),
            Y = floor(y),
            perm = this._perm;

        x = x - X;
        y = y - Y;

        X = X & 255;
        Y = Y & 255;


        var gi00 = perm[X + perm[Y]] % 12,
            gi01 = perm[X + perm[Y + 1]] % 12,
            gi10 = perm[X + 1 + perm[Y]] % 12,
            gi11 = perm[X + 1 + perm[Y + 1]] % 12,

            n00 = _dot2d(GRAD3[gi00], x, y),
            n10 = _dot2d(GRAD3[gi10], x - 1, y),
            n01 = _dot2d(GRAD3[gi01], x, y - 1),
            n11 = _dot2d(GRAD3[gi11], x - 1, y - 1),

            u = _fade(x),
            v = _fade(y),

            nx0 = _mix(n00, n10, u),
            nx1 = _mix(n01, n11, u),

            nxy = _mix(nx0, nx1, v);

        return nxy;
    }
};


/**
 * SimplexNoise
 *
 * @super ClassicNoise
 * @param {Number} seed
 */
function SimplexNoise(seed) {
if (seed == undefined || Number.isNaN(seed) || 'number' !== typeof seed) {
    throw new Error("seed is undefined or null")
}

    this.seed(seed);
}

SimplexNoise.prototype = object.extend({}, ClassicNoise.prototype, {
    noise: function (x, y, z, w) {
        var result = 0,
            noise,
            f = 1,
            oct = this._octaves,
            amp = 0.5,
            fallout = this._fallout,
            i;

        for (i = 0; i < oct; ++i) {
            result += (1 + this.noise2d(x * f, y * f)) * amp * 0.5;
            amp *= fallout;
            f *= 2;
        }

        return result;
    },

    noise2d: function (x, y) {
        var n0,
            n1,
            n2,

            F2 = 0.5 * (sqrt_of_3 - 1),
            s = (x + y) * F2,
            i = floor(x + s),
            j = floor(y + s),

            G2 = (3 - sqrt_of_3) / 6,
            t = (i + j) * G2,
            X0 = i - t,
            Y0 = j - t,
            x0 = x - X0,
            y0 = y - Y0,

            i1,
            j1,

            perm = this._perm;

        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } else {
            i1 = 0;
            j1 = 1;
        }

        var x1 = x0 - i1 + G2,
            y1 = y0 - j1 + G2,

            x2 = x0 - 1 + 2 * G2,
            y2 = y0 - 1 + 2 * G2,

            ii = i & 255,
            jj = j & 255,

            gi0 = perm[ii + perm[jj]] % 12,
            gi1 = perm[ii + i1 + perm[jj + j1]] % 12,
            gi2 = perm[ii + 1 + perm[jj + 1]] % 12,

            t0 = 0.5 - x0 * x0 - y0 * y0;

        if (t0 < 0) {
            n0 = 0;
        } else {
            t0 *= t0;
            n0 = t0 * t0 * _dot2d(GRAD3[gi0], x0, y0);
        }

        var t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 < 0) {
            n1 = 0;
        } else {
            t1 *= t1;
            n1 = t1 * t1 * _dot2d(GRAD3[gi1], x1, y1);
        }

        var t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 < 0) {
            n2 = 0;
        } else {
            t2 *= t2;
            n2 = t2 * t2 * _dot2d(GRAD3[gi2], x2, y2);
        }

        return 70 * (n0 + n1 + n2);
    }
});

function createClassic(seed) {
    return new ClassicNoise(seed);
}

function createSimpleX(seed) {
    return new SimplexNoise(seed);
}

Noise = {
    GRAD3: GRAD3,
    GRAD4: GRAD4,
    SIMPLEX: SIMPLEX,

    ClassicNoise: ClassicNoise,
    SimplexNoise: SimplexNoise,

    createClassic: createClassic,
    createSimpleX: createSimpleX
};

module.exports = Noise;
},{"./xorshift.js":31,"object-enhancements":34}],22:[function(require,module,exports){
var Vec2 = require("../vec2.js"),
    vec2_add = Vec2.add,
    vec2_scale = Vec2.scale,
    aux = [0, 0];
/**
 * @param {Vec2} position
 * @param {Vec2} velocity
 * @param {Number} dt
 */
function euler(position, velocity, dt) {
if (!Array.isArray(position) || position[0] == undefined || Number.isNaN(position[0]) || 'number' !== typeof position[0] || position[1] == undefined || Number.isNaN(position[1]) || 'number' !== typeof position[1]) {
    throw new Error("invalid Vec2 position")
}

if (!Array.isArray(velocity) || velocity[0] == undefined || Number.isNaN(velocity[0]) || 'number' !== typeof velocity[0] || velocity[1] == undefined || Number.isNaN(velocity[1]) || 'number' !== typeof velocity[1]) {
    throw new Error("invalid Vec2 velocity")
}

if (dt == undefined || Number.isNaN(dt) || 'number' !== typeof dt) {
    throw new Error("dt is undefined or null")
}

    vec2_add(position, position, vec2_scale(aux, velocity, dt));
}

module.exports = euler;

},{"../vec2.js":30}],23:[function(require,module,exports){
/**
 * RungeKutta 4
 *
 * @reference http://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods
 * @reference http://www.gaffer.org/articles
 * @source https://github.com/wellcaffeinated/PhysicsJS/blob/master/src/integrators/verlet.js
 * @source http://mtdevans.com/2013/05/fourth-order-runge-kutta-algorithm-in-javascript-with-demo/
 * @source http://doswa.com/2009/01/02/fourth-order-runge-kutta-numerical-integration.html
 */

var k = 10;
var b = 1;

/**
* @param {Number} x position
* @param {Number} v velocity
* @param {Number} ni_mass negated inverse of mass (-1/m)
* @param {Number} stiffness
* @param {Number} damping
* @param {Number} dt
* @param {Number} hdt dt * 0.5
* @param {Number} idt dt / 0.5
* @return {Array} [new_position, new_velocity]
*/
function rk4(x, v, ni_mass, stiffness, damping, dt, hdt, idt) {
if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (v == undefined || Number.isNaN(v) || 'number' !== typeof v) {
    throw new Error("v is undefined or null")
}

if (ni_mass == undefined || Number.isNaN(ni_mass) || 'number' !== typeof ni_mass) {
    throw new Error("ni_mass is undefined or null")
}

if (stiffness == undefined || Number.isNaN(stiffness) || 'number' !== typeof stiffness) {
    throw new Error("stiffness is undefined or null")
}

if (damping == undefined || Number.isNaN(damping) || 'number' !== typeof damping) {
    throw new Error("damping is undefined or null")
}

if (dt == undefined || Number.isNaN(dt) || 'number' !== typeof dt) {
    throw new Error("dt is undefined or null")
}

if (hdt == undefined || Number.isNaN(hdt) || 'number' !== typeof hdt) {
    throw new Error("hdt is undefined or null")
}

if (idt == undefined || Number.isNaN(idt) || 'number' !== typeof idt) {
    throw new Error("idt is undefined or null")
}

  // Returns final (position, velocity) array after time dt has passed.
  //        x: initial position
  //        v: initial velocity
  //        a: acceleration function a(x,v,dt) (must be callable)
  //        dt: timestep
  var x1 = x;
  var v1 = v;
  var a1 = (stiffness * x1 + damping * v1) * ni_mass;

  var x2 = x + v1 * hdt;
  var v2 = v + a1 * hdt;
  var a2 = -(stiffness * x2 + damping * v2) * ni_mass;

  var x3 = x + v2 * hdt;
  var v3 = v + a2 * hdt;
  var a3 = (stiffness * x3 + damping * v3) * ni_mass;

  var x4 = x + v3 * dt;
  var v4 = v + a3 * dt;
  var a4 = (stiffness * x4 + damping * v4) * ni_mass;

  var xf = x + idt * (v1 + 2 * (v2 + v3) + v4);
  var vf = v + idt * (a1 + 2 * (a2 + a3) + a4);

  return [xf, vf];
}
/*
var ts = 0;
var max_ts = 50;
var dt = 0.1;
var state = [100, 0];
var stiffness = 1;
var damping = 0;

var interval = setInterval(function () {
    ts+=dt;

    state = rk4(state[0], state[1], -1, stiffness, damping, dt, dt * 0.5, dt * 0.166666667);

    console.log(state[0].toFixed(2), state[1].toFixed(2));
    //console.log(state2.position.toFixed(2), " - ", state2.velocity.toFixed(2));
    //console.log();

    if (ts > max_ts) {
        clearInterval(interval);
    }

}, dt * 10);
*/

// node lib/integrators.js > output.dat && gnuplot -e "set term png; set output 'printme.png'; set zeroaxis; plot 'output.dat' using 1:2 with lines; set term x11" && firefox printme.png


module.exports = rk4;
},{}],24:[function(require,module,exports){
var Vec2 = require("../vec2.js"),
    vec2_sub = Vec2.sub,
    vec2_add = Vec2.add,
    vec2_scale = Vec2.scale,
    aux = [0, 0];

/**
 * @param {Vec2} out_position
 * @param {Vec2} velocity
 * @param {Vec2} last_velocity
 * @param {Number} dt
 */
function verlet(out_position, velocity, last_velocity, dt) {
if (!Array.isArray(out_position) || out_position[0] == undefined || Number.isNaN(out_position[0]) || 'number' !== typeof out_position[0] || out_position[1] == undefined || Number.isNaN(out_position[1]) || 'number' !== typeof out_position[1]) {
    throw new Error("invalid Vec2 out_position")
}

if (!Array.isArray(velocity) || velocity[0] == undefined || Number.isNaN(velocity[0]) || 'number' !== typeof velocity[0] || velocity[1] == undefined || Number.isNaN(velocity[1]) || 'number' !== typeof velocity[1]) {
    throw new Error("invalid Vec2 velocity")
}

if (!Array.isArray(last_velocity) || last_velocity[0] == undefined || Number.isNaN(last_velocity[0]) || 'number' !== typeof last_velocity[0] || last_velocity[1] == undefined || Number.isNaN(last_velocity[1]) || 'number' !== typeof last_velocity[1]) {
    throw new Error("invalid Vec2 last_velocity")
}

if (dt == undefined || Number.isNaN(dt) || 'number' !== typeof dt) {
    throw new Error("dt is undefined or null")
}

    vec2_add(aux, last_velocity, velocity);
    vec2_scale(aux, aux, 0.5 * dt);

    return vec2_add(out_position, out_position, aux);
}


/**
 * maybe this implementation could be better, some test ?!
 * @source http://lonesock.net/article/verlet.html
 *
 * @param {Vec2} out_position
 * @param {Vec2} velocity
 * @param {Vec2} last_velocity
 * @param {Number} dt
 * @param {Number} last_dt
 */
function tc_verlet(out_position, velocity, last_velocity, dt, last_dt) {
if (!Array.isArray(out_position) || out_position[0] == undefined || Number.isNaN(out_position[0]) || 'number' !== typeof out_position[0] || out_position[1] == undefined || Number.isNaN(out_position[1]) || 'number' !== typeof out_position[1]) {
    throw new Error("invalid Vec2 out_position")
}

if (!Array.isArray(velocity) || velocity[0] == undefined || Number.isNaN(velocity[0]) || 'number' !== typeof velocity[0] || velocity[1] == undefined || Number.isNaN(velocity[1]) || 'number' !== typeof velocity[1]) {
    throw new Error("invalid Vec2 velocity")
}

if (!Array.isArray(last_velocity) || last_velocity[0] == undefined || Number.isNaN(last_velocity[0]) || 'number' !== typeof last_velocity[0] || last_velocity[1] == undefined || Number.isNaN(last_velocity[1]) || 'number' !== typeof last_velocity[1]) {
    throw new Error("invalid Vec2 last_velocity")
}

if (dt == undefined || Number.isNaN(dt) || 'number' !== typeof dt) {
    throw new Error("dt is undefined or null")
}

if (last_dt == undefined || Number.isNaN(last_dt) || 'number' !== typeof last_dt) {
    throw new Error("last_dt is undefined or null")
}

    vec2_sub(aux, velocity, last_velocity);
    vec2_scale(aux, aux, dt / last_dt);

    vec2_add(aux, velocity, aux);
    vec2_scale(aux, aux, 0.5 * dt);
    vec2_add(out_position, out_position, aux);
}

module.exports = verlet;

},{"../vec2.js":30}],25:[function(require,module,exports){
var Vec2 = require("./vec2.js"),
    vec2_add = Vec2.add,
    vec2_sub = Vec2.sub,
    vec2_dot = Vec2.dot,
    vec2_crossLength = Vec2.crossLength,
    vec2_cross = Vec2.cross,
    vec2_scale = Vec2.scale,
    vec2_negate = Vec2.negate,
    vec2_normalize = Vec2.normalize,
    vec2_lengthSq = Vec2.lengthSq,
    vec2_perp = Vec2.perp,

    Matrix23 = require("./matrix23.js"),

    Beizer = require("./beizer.js"),
    beizer_getPoints = Beizer.getPoints,
    f,
    sum = 0,
    cross = 0,
    x,
    y,
    o,
    p,
    sqrt = Math.sqrt,
    cos = Math.cos,
    abs = Math.abs,
    sin = Math.sin,
    EPS = Math.EPS;
/**
 * input are many Vec2(s)
 * @return {Polygon}
 */
function create() {
    var i,
        len = arguments.length,
        out = new Array(len);

    for (i = 0; i < len; ++i) {
        out[i] = arguments[i];
    }

    return out;
}

/*
 * Create the convex hull using the Gift wrapping algorithm
 * @source https://github.com/juhl/collision-detection-2d/blob/master/util.js
 * @reference http://en.wikipedia.org/wiki/Gift_wrapping_algorithm
 * @reference http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
 * @param {Vec2[]} vec2_list
 * @return {Polygon}
 */
function createConvexHull(vec2_list) {
    // Find the right most point on the hull
    var i0 = 0,
        x0 = vec2_list[0][0],
        i,
        x;

    for (i = 1; i < vec2_list.length; i++) {
        x = vec2_list[i][0];
        if (x > x0 || (x === x0 && vec2_list[i][1] < vec2_list[i0][1])) {
            i0 = i;
            x0 = x;
        }
    }

    var n = vec2_list.length,
        hull = [],
        m = 0,
        ih = i0,
        ie,
        j,
        r = [0, 0],
        v = [0, 0],
        c;

    do {
        hull[m] = ih;

        ie = 0;
        for (j = 1; j < n; ++j) {
            if (ie === ih) {
                ie = j;
                continue;
            }

            vec2_sub(r, vec2_list[ie], vec2_list[hull[m]]);
            vec2_sub(v, vec2_list[j], vec2_list[hull[m]]);
            c = Vec2.cross(r, v);
            if (c < 0) {
                ie = j;
            }

            // Collinearity check
            if (c === 0 && vec2_lengthSq(v) > vec2_lengthSq(r)) {
                ie = j;
            }
        }

        ++m;
        ih = ie;
    } while (ie !== i0);

    // Copy vertices
    var newPoints = [];
    for (i = 0; i < m; ++i) {
        newPoints.push(vec2_list[hull[i]]);
    }

    return newPoints;
}
/**
 * @param {AABB2} aabb2
 * @return {Polygon}
 */
function fromAABB(aabb2) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

    var out = new Array(4);
    out[0] = [aabb2[0], aabb2[1]];
    out[1] = [aabb2[0], aabb2[3]];
    out[2] = [aabb2[2], aabb2[3]];
    out[3] = [aabb2[2], aabb2[1]];

    return out;
}
/**
 * @param {Rectangle} rect
 * @return {Polygon}
 */
function fromRectangle(rect) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

    var out = new Array(4);
    out[0] = [rect[0][0], rect[0][1]];
    out[1] = [rect[0][0], rect[1][1]];
    out[2] = [rect[1][0], rect[1][1]];
    out[3] = [rect[1][0], rect[0][1]];

    return out;
}
/**
 * Create a polygon, the polygon is a line
 * @todo extrude this line
 * @param {Beizer} curve
 * @param {Number} npoints
 * @return {Polygon}
 */
function fromBeizer(curve, npoints) {
if (npoints == undefined || Number.isNaN(npoints) || 'number' !== typeof npoints) {
    throw new Error("npoints is undefined or null")
}

    return beizer_getPoints(curve, npoints);
}
/**
 * Create a polygon from a circle
 * start_radians rotate the given polygon
 * @param {Circle} circle
 * @param {Number} npoints
 * @param {Number} start_radians
 * @return {Polygon}
 */
function fromCircle(circle, npoints, start_radians) {
if (npoints == undefined || Number.isNaN(npoints) || 'number' !== typeof npoints) {
    throw new Error("npoints is undefined or null")
}

if (start_radians == undefined || Number.isNaN(start_radians) || 'number' !== typeof start_radians) {
    throw new Error("start_radians is undefined or null")
}

    var i = start_radians,
        max = Math.TWO_PI + start_radians,
        angle = Math.TWO_PI / npoints,
        out = [],
        cx = circle[0][0],
        cy = circle[0][1],
        r = circle[1],
        c,
        s;

    for (; i < max; i += angle) {
        c = cos(i);
        s = sin(i);
        out.push([cx + c * r, cy + s * r]);
    }

    return out;
}
/**
 *
 * @param {Polygon} out
 * @param {Polygon} poly
 * @param {Vec2} vec2
 * @return {Polygon}
 */
function translate(out, poly, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var len = poly.length - 1;

    x = vec2[0];
    y = vec2[1];

    do {
        p = poly[len];
        o = out[len] = out[len] || [0, 0];
        o[0] = p[0] + x;
        o[1] = p[1] + y;
    } while (len--);

    return out;
}
var cfactor,
    sfactor;
/**
 *
 * @param {Polygon} out
 * @param {Polygon} poly
 * @param {Number} radians
 * @return {Polygon}
 */
function rotate(out, poly, radians) {
if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    if (out.length > poly.length) {
        out.splice(poly.length);
    }

    var len = poly.length - 1;

    cfactor = cos(radians);
    sfactor = sin(radians);

    do {
        p = poly[len];
        o = out[len] = out[len] || [0, 0];
        x = p[0];
        y = p[1];

        o[0] = x * cfactor - y * sfactor;
        o[1] = x * sfactor + y * cfactor;
    } while (len--);

    return out;
}
/**
 *
 * @param {Polygon} out
 * @param {Polygon} poly
 * @param {Number} radians
 * @return {Polygon}
 */
function edges(out, poly) {
    if (out.length > poly.length) {
        out.splice(poly.length);
    }

    var i = 0,
        len = poly.length,
        lenm1 = len - 1;

    // Calculate the edges/normals
    for (; i < len; i++) {
        vec2_sub(out[i] = out[i] || [0, 0], poly[i < lenm1 ? i + 1 : 0], poly[i]);
    }

    return out;
}
/**
 *
 * @param {Polygon} out
 * @param {Polygon} edges
 * @return {Polygon}
 */
function normals(out, edges) {
    var i = 0,
        len = edges.length;

    if (out.length > edges.length) {
        out.splice(edges.length);
    }

    for (; i < len; i++) {
        out[i] = out[i] || [0, 0];
        vec2_perp(out[i], edges[i]);
        vec2_normalize(out[i], out[i]);
    }

    return out;
}

var c_aux = [0, 0],
    c_aux2 = [0, 0];
/**
 *
 * @param {Vec2} out_vec2
 * @param {Polygon} poly
 * @return {Vec2}
 */
function centroid(out_vec2, poly) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

    var i = 0,
        len = poly.length;

    sum = 0;
    out_vec2[0] = 0;
    out_vec2[1] = 1;

    for (; i < len; ++i) {
        c_aux[0] = poly[i][0];
        c_aux[1] = poly[i][1];
        f = (i === len) ? 0 : i;
        c_aux2[0] = poly[f][0];
        c_aux2[0] = poly[f][1];

        cross = vec2_cross(c_aux, c_aux2);

        sum += cross;
        vec2_add(c_aux, c_aux, c_aux2);
        vec2_scale(c_aux, c_aux, cross);
        vec2_add(out_vec2, out_vec2, c_aux);
    }

    return vec2_scale(out_vec2, out_vec2, 1 / (3 * sum));
}
var vec2_centroid = [0, 0];
/**
 *
 * @param {Polygon} out
 * @param {Polygon} poly
 * @return {Polygon}
 */
function recenter(out, poly) {
    var i = 0,
        len = poly.length;

    if (out.length > poly.length) {
        out.splice(poly.length);
    }

    centroid(vec2_centroid, poly);
    var x = vec2_centroid[0],
        y = vec2_centroid[1];

    for (; i < len; ++i) {
        out[i] = out[i] || [0, 0]; // create if needed...
        out[i][0] += x;
        out[i][1] += y;
    }
}
/*
* @TODO review, this doesn't seems to be right!
* Get the circumeter of polygon
* @param {Complex[]} p The polygon
function circumcenter(out, poly) {
    var circ = 0, i = 1;
    for (; i < poly.length; i++) {
      var dx = poly[i][0] - poly[i - 1][0];
      var dy = poly[i][1] - poly[i - 1][1];
      circ += sqrt(dx * dx + dy * dy);
    }
    return circ;
},
*/

/**
 *
 * @param {Polygon} poly
 * @return {Number}
 */
function area(poly) {
    var value = 0,
        i = 0,
        len = poly.length;

    for (; i < len; ++i) {
        f = (i === len) ? 0 : i;
        value -= (poly[i][0] * poly[f][0]) - (poly[i][1] * poly[f][1]);
    }

    return value * 0.5;
}

/**
 *
 * @param {Polygon} out
 * @param {Polygon} poly
 * @param {Matrix23} m2d
 * @return {Polygon}
 */
function transform(out, poly, m2d) {
if (!Array.isArray(m2d) || m2d[0] == undefined || Number.isNaN(m2d[0]) || 'number' !== typeof m2d[0] || m2d[1] == undefined || Number.isNaN(m2d[1]) || 'number' !== typeof m2d[1] || m2d[2] == undefined || Number.isNaN(m2d[2]) || 'number' !== typeof m2d[2] || m2d[3] == undefined || Number.isNaN(m2d[3]) || 'number' !== typeof m2d[3] || m2d[4] == undefined || Number.isNaN(m2d[4]) || 'number' !== typeof m2d[4] || m2d[5] == undefined || Number.isNaN(m2d[5]) || 'number' !== typeof m2d[5]) {
    throw new Error("invalid Matrix23 m2d")
}

    var i = 0,
        len = poly.length;

    if (out.length > poly.length) {
        out.splice(poly.length);
    }

    for (; i < len; ++i) {
        out[i] = out[i] || [0, 0];
        Matrix23.transform(out[i], m2d, poly[i]);
    }

    return out;
}

/**
 *
 * @param {Polygon} poly
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function isVec2Inside(poly, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    var i = 0,
        len = poly.length,
        j = len - 1,
        c = false;

    for (; i < len; j = i++) {
        if ((poly[i][1] >= vec2[1]) !== (poly[j][1] >= vec2[1]) &&
            (vec2[0] <= (poly[j][0] - poly[i][0]) * (vec2[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0])
        ) {
            c = !c;
        }
    }

    return c;
}

/**
 * Compute farthest polygon point in particular direction.
 * Return the index in the polygon and a clone in out_vec2
 *
 * @param {Vec2} out_vec2
 * @param {Polygon} poly
 * @param {Vec2} vec2_dir
 * @return {Number} index in the current poly
 */
function furthestPoint(out_vec2, poly, vec2_dir) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(vec2_dir) || vec2_dir[0] == undefined || Number.isNaN(vec2_dir[0]) || 'number' !== typeof vec2_dir[0] || vec2_dir[1] == undefined || Number.isNaN(vec2_dir[1]) || 'number' !== typeof vec2_dir[1]) {
    throw new Error("invalid Vec2 vec2_dir")
}

    var idx,
        i,
        max,
        max_dot = -Infinity,
        current_dot;

    for (i = 0, max = poly.length; i < max; ++i) {
        current_dot = Vec2.dot(poly[i], vec2_dir);
        if (current_dot > max_dot) {
            idx = i;
            max_dot = current_dot;
        }
    }

    out_vec2[0] = poly[idx][0];
    out_vec2[1] = poly[idx][1];

    return idx;
}

var fm_nd = [0, 0],
    fm_a = [0, 0],
    fm_b = [0, 0];

/*
 * furthest Point in the Minkowski diff between A and B polygons for a given direction
 *
 * @param {Vec2} out_vec2
 * @param {Polygon} poly_a
 * @param {Polygon} poly_b
 * @param {Vec2} vec2_dir
 * @return {Vec2}
 */
function furthestMinkowski(out_vec2, poly_a, poly_b, vec2_dir) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(vec2_dir) || vec2_dir[0] == undefined || Number.isNaN(vec2_dir[0]) || 'number' !== typeof vec2_dir[0] || vec2_dir[1] == undefined || Number.isNaN(vec2_dir[1]) || 'number' !== typeof vec2_dir[1]) {
    throw new Error("invalid Vec2 vec2_dir")
}

    // furthest point in poly_a for vec2_dir
    furthestPoint(fm_a, poly_a, vec2_dir);

    // furthest point in poly_b for -vec2_dir
    vec2_negate(fm_nd, vec2_dir);
    furthestPoint(fm_b, poly_b, fm_nd);

    return vec2_sub(out_vec2, fm_a, fm_b);
}

/**
 * Calculate Minkowski Difference
 *
 * @param {Polygon} poly_a
 * @param {Polygon} poly_b
 * @return {Polygon} a new one, because the size is random
 */
function MinkowskiDifference(poly_a, poly_b) {
    var i,
        imax = poly_a.length,
        j,
        jmax = poly_b.length,
        scale = imax * jmax,
        minkSum = new Array(scale),
        idx = 0;

    for (i = 0; i < imax; ++i) {
        for (j = 0; j < jmax; ++j) {
            minkSum[idx++] = [poly_a[i][0] - poly_b[j][0], poly_a[i][1] - poly_b[j][1]];
        }
    }

    return createConvexHull(minkSum);
}
/**
 * @source http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
 * @source http://www.physicsforums.com/showthread.php?t=25293&page=2&pp=15
 * @param {Polygon} poly
 * @param {Number} mass
 */
function momentOfInertia(poly, mass) {
if (mass == undefined || Number.isNaN(mass) || 'number' !== typeof mass) {
    throw new Error("mass is undefined or null")
}

    var denom = 0.0,
        numer = 0.0,
        len = poly.length,
        i = 0,
        j = len - 1,
        p0,
        p1,
        a,
        b;

    for (; i < len; j = i++) {
        p0 = poly[j];
        p1 = poly[i];
        a = abs(vec2_crossLength(p0, p1));
        b = vec2_dot(p1, p1) + vec2_dot(p1, p0) + vec2_dot(p0, p0);
        denom += a * b;
        numer += a;
    }
    return (mass / 6.0) * (denom / numer);
}

/**
 * @source http://paulbourke.net/geometry/polygonmesh/
 * @param {Polygon} poly
 */
function isConvex(poly) {
    var len = poly.length,
        i,
        j = 1,
        k = 2,
        flag = 0,
        z;

    if (len < 3) {
        return -1;
    }

    for (i = 0; i < len; ++i, ++j, ++k) {
        j = j % len;
        k = k % len;

        z  = (poly[j][0] - poly[i][0]) * (poly[k][1] - poly[j][1]) -
             (poly[j][1] - poly[i][1]) * (poly[k][0] - poly[j][0]);
        if (z < 0) {
            flag |= 1;
        } else if (z > 0) {
            flag |= 2;
        }

        if (flag === 3) {
            return false;
        }
    }

    if (flag !== 0) {
       return true;
    }

    return -1;
}

/**
 * @param {Polygon} poly
 */
function toString(poly) {
    var vec2s = [],
        i,
        len = poly.length;

    for (i = 0; i < len; ++i) {
        vec2s.push(Vec2.toString(poly[i]));
    }

    return "{" + vec2s.join(",") + "}";
}

/**
 * @class Polygon
 */
var Polygon = {
    create: create,
    createConvexHull: createConvexHull,
    fromAABB: fromAABB,
    fromRectangle: fromRectangle,
    fromBeizer: fromBeizer,
    fromCircle: fromCircle,
    translate: translate,
    isConvex: isConvex,
    rotate: rotate,
    centroid: centroid,
    recenter: recenter,
    //circumcenter: circumcenter,
    area: area,
    transform: transform,

    normals: normals,
    edges: edges,

    isVec2Inside: isVec2Inside,
    furthestPoint: furthestPoint,
    furthestMinkowski: furthestMinkowski,
    MinkowskiDifference: MinkowskiDifference,

    //physics
    momentOfInertia: momentOfInertia,

    toString: toString
};

module.exports = Polygon;

},{"./beizer.js":4,"./matrix23.js":19,"./vec2.js":30}],26:[function(require,module,exports){
/*
 * Stability: 1 (Only additions & fixes)
 *
 * Rectangle is represented as a three coordinates array
 * [a: Vec2, b: Vec2, normalized: Boolean]
 */

var Vec2 = "undefined" === typeof exports ? window.Vec2 : require("./vec2.js"),
    vec2_distance = Vec2.distance,
    max = Math.max,
    min = Math.min,
    aux_vec2_1 = [0, 0],
    aux_vec2_2 = [0, 0],
    a = 0,
    b = 0;
/**
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @return {Rectangle}
 */
function create(x1, y1, x2, y2) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

    var out = [[x1, y1], [x2, y2], false];
    normalize(out, out);
    return out;
}
/**
 * @param {AABB2} aabb2
 * @return {Rectangle}
 */
function fromBB(aabb2) {
if (!Array.isArray(aabb2) || aabb2[0] == undefined || Number.isNaN(aabb2[0]) || 'number' !== typeof aabb2[0] || aabb2[1] == undefined || Number.isNaN(aabb2[1]) || 'number' !== typeof aabb2[1] || aabb2[2] == undefined || Number.isNaN(aabb2[2]) || 'number' !== typeof aabb2[2] || aabb2[3] == undefined || Number.isNaN(aabb2[3]) || 'number' !== typeof aabb2[3]) {
    throw new Error("invalid AABB2 aabb2")
}

    return create(aabb2[0], aabb2[1], aabb2[2], aabb2[3]);
}
/**
 * @return {Rectangle}
 */
function zero() {
    return [[0, 0], [0, 0], true];
}
/**
 * @param {Rectangle} rect
 * @return {Rectangle}
 */
function clone(rect) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

    return [[rect[0][0], rect[0][1]], [rect[1][0], rect[1][1]], rect[2]];
}
/**
 * @param {Rectangle} out
 * @param {Rectangle} rect
 * @return {Rectangle}
 */
function copy(out, rect) {
if (!Array.isArray(out) || out[0][0] == undefined || Number.isNaN(out[0][0]) || 'number' !== typeof out[0][0] || out[0][1] == undefined || Number.isNaN(out[0][1]) || 'number' !== typeof out[0][1] || out[1][0] == undefined || Number.isNaN(out[1][0]) || 'number' !== typeof out[1][0] || out[1][1] == undefined || Number.isNaN(out[1][1]) || 'number' !== typeof out[1][1]) {
    throw new Error("invalid Rectangle out")
}

if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

    out[0][0] = rect[0][0];
    out[0][1] = rect[0][1];

    out[1][0] = rect[1][0];
    out[1][1] = rect[1][1];

    out[2] = rect[2];

    return out;
}

/**
 * a -> bottom-left
 * a -> top-right
 *
 * @param {Rectangle} out
 * @param {Rectangle} rect
 * @param {Boolean=} force
 * @return {Rectangle}
 */
function normalize(out, rect, force) {
if (!Array.isArray(out) || out[0][0] == undefined || Number.isNaN(out[0][0]) || 'number' !== typeof out[0][0] || out[0][1] == undefined || Number.isNaN(out[0][1]) || 'number' !== typeof out[0][1] || out[1][0] == undefined || Number.isNaN(out[1][0]) || 'number' !== typeof out[1][0] || out[1][1] == undefined || Number.isNaN(out[1][1]) || 'number' !== typeof out[1][1]) {
    throw new Error("invalid Rectangle out")
}

if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if (force !== undefined) {
if ('boolean' !== typeof force) {
    throw new Error("force is not a boolean")
}

}
    force = force || rect[2] === false || false;

    if (!force) {
        copy(out, rect);
        return out;
    }

    a = min(rect[0][0], rect[1][0]);
    b = max(rect[0][0], rect[1][0]);

    out[0][0] = a;
    out[1][0] = b;

    a = min(rect[0][1], rect[1][1]);
    b = max(rect[0][1], rect[1][1]);

    out[0][1] = a;
    out[1][1] = b;

    out[2] = true;

    return out;
}
/**
 * @param {Vec2} out_vec2
 * @param {Rectangle} rect
 * @return {Vec2}
 */
function center(out_vec2, rect) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

    out_vec2[0] = (rect[0][0] + rect[1][0]) * 0.5;
    out_vec2[1] = (rect[0][1] + rect[1][1]) * 0.5;

    return out_vec2;
}
/**
 * @param {Rectangle} out
 * @param {Rectangle} rect
 * @param {Vec2} vec2
 * @return {Rectangle}
 */
function translate(out, rect, vec2) {
if (!Array.isArray(out) || out[0][0] == undefined || Number.isNaN(out[0][0]) || 'number' !== typeof out[0][0] || out[0][1] == undefined || Number.isNaN(out[0][1]) || 'number' !== typeof out[0][1] || out[1][0] == undefined || Number.isNaN(out[1][0]) || 'number' !== typeof out[1][0] || out[1][1] == undefined || Number.isNaN(out[1][1]) || 'number' !== typeof out[1][1]) {
    throw new Error("invalid Rectangle out")
}

if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out[0][0] = rect[0][0] + vec2[0];
    out[0][1] = rect[0][1] + vec2[1];

    out[1][0] = rect[1][0] + vec2[0];
    out[1][1] = rect[1][1] + vec2[1];

    return out;
}
/**
 * @param {Rectangle} rect
 * @param {Rectangle} rect2
 * @return {Number}
 */
function distance(rect, rect2) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if (!Array.isArray(rect2) || rect2[0][0] == undefined || Number.isNaN(rect2[0][0]) || 'number' !== typeof rect2[0][0] || rect2[0][1] == undefined || Number.isNaN(rect2[0][1]) || 'number' !== typeof rect2[0][1] || rect2[1][0] == undefined || Number.isNaN(rect2[1][0]) || 'number' !== typeof rect2[1][0] || rect2[1][1] == undefined || Number.isNaN(rect2[1][1]) || 'number' !== typeof rect2[1][1]) {
    throw new Error("invalid Rectangle rect2")
}

    center(aux_vec2_1, rect);
    center(aux_vec2_2, rect2);

    return vec2_distance(aux_vec2_2, aux_vec2_1);
}
/**
 * @param {Rectangle} rect
 * @return {Number}
 */
function area(rect) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

    a = rect[0][0] - rect[1][0];
    b = rect[0][1] - rect[1][1];
    a *= b;

    return a < 0 ? -a : a; //needed id normalized ?
}
/**
 * @param {Rectangle} rect
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function isVec2Inside(rect, vec2) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return rect[0][0] < vec2[0] && rect[1][0] > vec2[0] && rect[0][1] < vec2[1] && rect[1][1] > vec2[1];
}
/**
 * @param {Rectangle} rect
 * @return {Number}
 */
function perimeter(rect) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

    return (rect[1][0] - rect[0][0]) * 2 + (rect[1][1] - rect[0][1]) * 2 ;
}
/**
 * @param {Rectangle} rect
 * @param {Number} mass
 */
function momentOfInertia(rect, mass) {
if (!Array.isArray(rect) || rect[0][0] == undefined || Number.isNaN(rect[0][0]) || 'number' !== typeof rect[0][0] || rect[0][1] == undefined || Number.isNaN(rect[0][1]) || 'number' !== typeof rect[0][1] || rect[1][0] == undefined || Number.isNaN(rect[1][0]) || 'number' !== typeof rect[1][0] || rect[1][1] == undefined || Number.isNaN(rect[1][1]) || 'number' !== typeof rect[1][1]) {
    throw new Error("invalid Rectangle rect")
}

if (mass == undefined || Number.isNaN(mass) || 'number' !== typeof mass) {
    throw new Error("mass is undefined or null")
}

    var w = rect[1][0] - rect[0][0],
        h = rect[1][1] - rect[0][1];

    // X/12
    return mass * (h*h + w*w) * 0.08333333333333333;
}
/**
 * @class Rectangle
 */
var Rectangle = {
    fromBB: fromBB,
    create: create,
    zero: zero,
    clone: clone,
    copy: copy,
    normalize: normalize,
    center: center,
    translate: translate,
    distance: distance,
    area: area,
    isVec2Inside: isVec2Inside,
    perimeter: perimeter,

    //physics
    momentOfInertia: momentOfInertia,
};


module.exports = Rectangle;
},{"./vec2.js":30}],27:[function(require,module,exports){
/**
 * Segment2 is represented by a 4 coordinates array
 * [x1:Number, y1:Number, x2:Number, y2:Number] normalized so x1 < x2
 */

var Vec2 = require("./vec2.js"),
    vec2_rotate = Vec2.rotate,
    aux_vec2 = [0, 0],
    aux,
    within = Vec2.$within,
    sqrt = Math.sqrt,
    atan2 = Math.atan2,
    PI = Math.PI,
    near = Math.near,
    __x,
    __y,
    u = 0;
/**
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @return {Segment2}
 */
function create(x1, y1, x2, y2) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

    if (x1 < x2) {
        return [x1, y1, x2, y2];
    }

    return [x2, y2, x1, y1];
}
/**
 * @param {Segment2} out
 * @param {Segment2} seg2
 * @return {Segment2}
 */
function normalize(out, seg2) {
    if (seg2[0] < seg2[1]) {
        out[0] = seg2[0];
        out[1] = seg2[1];
        out[2] = seg2[2];
        out[3] = seg2[3];
    } else {
        var x = seg2[0],
            y = seg2[1];

        out[0] = seg2[2];
        out[1] = seg2[3];
        out[2] = x;
        out[3] = y;
    }

    return out;
}
/**
 * @param {Segment2} seg2
 * @return {Segment2}
 */
function clone(seg2) {
    return [seg2[0], seg2[1], seg2[2], seg2[3]];
}
/**
 * @param {Segment2} out
 * @param {Segment2} seg2
 * @return {Segment2}
 */
function copy(out, seg2) {
    out[0] = seg2[0];
    out[1] = seg2[1];
    out[2] = seg2[2];
    out[3] = seg2[3];

    return out;
}
/**
 * @param {Segment2} out
 * @param {Segment2} seg2
 * @param {Vec2} vec2
 * @return {Segment2}
 */
function translate(out, seg2, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out[0] = seg2[0] + vec2[0];
    out[1] = seg2[1] + vec2[1];
    out[2] = seg2[2] + vec2[0];
    out[3] = seg2[3] + vec2[1];

    return out;
}
/**
 * @param {Segment2} seg2
 * @return {Number}
 */
function length(seg2) {
    __x = seg2[2] - seg2[0];
    __y = seg2[3] - seg2[1];

    return sqrt(__x * __x + __y * __y);
}
/**
 * @param {Segment2} seg2
 * @return {Number}
 */
function sqrLength(seg2) {
    __x = seg2[2] - seg2[0];
    __y = seg2[3] - seg2[1];

    return __x * __x + __y * __y;
}
/**
 * @param {Vec2} out_vec2
 * @param {Segment2} seg2
 * @return {Vec2}
 */
function midPoint(out_vec2, seg2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

    out_vec2[0] = (seg2[0] + seg2[2]) * 0.5;
    out_vec2[1] = (seg2[1] + seg2[3]) * 0.5;

    return out_vec2;
}
/**
 * @param {Segment2} seg2
 * @return {Number}
 */
function slope(seg2) {
    return (seg2[0] - seg2[2]) / (seg2[1] - seg2[3]);
}
/**
 * @param {Segment2} seg2
 * @return {Number}
 */
function angle(seg2) {
    return atan2(seg2[3] - seg2[1], seg2[2] - seg2[0]);
}
/**
 * @param {Segment2} seg2
 * @param {Vec2} vec2
 * @return {Number}
 */
function cross(seg2, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return (seg2[0] - vec2[0]) * (seg2[3] - vec2[1]) - (seg2[1] - vec2[1]) * (seg2[2] - vec2[0]);
}
/**
 * @param {Segment2} seg2
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function isCollinear(seg2, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return near((seg2[2] - seg2[0]) * (vec2[1] - vec2[1]), (vec2[0] - seg2[0]) * (seg2[3] - seg2[1]));
}
/**
 * @todo do it!
 * @return {Boolean}
 * @param {Segment2} seg2
 * @param {Segment2} seg2_2
 */
function isParallel(seg2, seg2_2) {
    throw new Error("todo");
}
/**
 * @param {Segment2} seg2
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function isVec2Inside(seg2, vec2) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return isCollinear(seg2, vec2) && within(seg2[0], seg2[1], vec2[0], vec2[1], seg2[2], seg2[3]);
}
/**
 * @param {Segment2} seg2
 * @param {Vec2} vec2
 * @param {Number=} cached_seg2_min_angle
 * @return {Boolean}
 */
function isAbove(seg2, vec2, cached_seg2_min_angle) {
if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (cached_seg2_min_angle !== undefined) {
if (cached_seg2_min_angle == undefined || Number.isNaN(cached_seg2_min_angle) || 'number' !== typeof cached_seg2_min_angle) {
    throw new Error("cached_seg2_min_angle is undefined or null")
}

}
    aux_vec2[0] = seg2[0];
    aux_vec2[1] = seg2[1];
    angle = Vec2.angleTo(vec2, aux_vec2);

    cached_seg2_min_angle = cached_seg2_min_angle || Segment2.angle(seg2);

    if (cached_seg2_min_angle >= 0) {
        aux = cached_seg2_min_angle;
        cached_seg2_min_angle = cached_seg2_min_angle - PI;
        cache_seg2_angle_max = aux;
        return angle > cached_seg2_min_angle && angle < cache_seg2_angle_max;
    }

    cache_seg2_angle_max = cached_seg2_min_angle + PI;

    return angle < cached_seg2_min_angle || angle > cache_seg2_angle_max;
}
/**
 * @param {Vec2} out_vec2
 * @param {Segment2} seg2
 * @return {Vec2}
 */
function leftNormal(out_vec2, seg2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

    out_vec2[0] = seg2[2] - seg2[0];
    out_vec2[1] = seg2[3] - seg2[1];

    vec2_rotate(out_vec2, out_vec2, -Math.HALF_PI);

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Segment2} seg2
 * @return {Vec2}
 */
function rightNormal(out_vec2, seg2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

    out_vec2[0] = seg2[2] - seg2[0];
    out_vec2[1] = seg2[3] - seg2[1];

    vec2_rotate(out_vec2, out_vec2, Math.HALF_PI);

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Segment2} seg2
 * @param {Vec2} vec2
 * @return {Vec2}
 */
function closestPoint(out_vec2, seg2, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    return $closestPoint(out_vec2, seg2[0], seg2[1], seg2[2], seg2[3], vec2[0], vec2[1]);
}

/**
 * @todo optimize, "inline the if/else"
 * @param {Vec2} out_vec2
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Number} x3
 * @param {Number} y3
 * @return {Vec2}
 */
function $closestPoint(out_vec2, x1, y1, x2, y2, x3, y3) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

if (x3 == undefined || Number.isNaN(x3) || 'number' !== typeof x3) {
    throw new Error("x3 is undefined or null")
}

if (y3 == undefined || Number.isNaN(y3) || 'number' !== typeof y3) {
    throw new Error("y3 is undefined or null")
}

    __x = x2 - x1;
    __y = y2 - y1;

    u = ((x3 - x1) * __x + (y3 - y1) * __y) / (__x * __x + __y * __y);

    if (u > 1) {
        u = 1;
    } else if (u < 0) {
        u = 0;
    }

    out_vec2[0] = (x1 + u * __x);
    out_vec2[1] = (y1 + u * __y);

    return out_vec2;
}

/**
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Number} x3
 * @param {Number} y3
 * @return {Boolean}
 */
function $collinear(x1, y1, x2, y2, x3, y3) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

if (x3 == undefined || Number.isNaN(x3) || 'number' !== typeof x3) {
    throw new Error("x3 is undefined or null")
}

if (y3 == undefined || Number.isNaN(y3) || 'number' !== typeof y3) {
    throw new Error("y3 is undefined or null")
}

    //strict return (x2 - x1) * (y3 - y1) === (x3 - x1) * (y2 - y1);
    return near((x2 - x1) * (y3 - y1), (x3 - x1) * (y2 - y1));
}
/**
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Number} x3
 * @param {Number} y3
 * @return {Boolean}
 */
function $inside(x1, x2, y1, y2, x3, y3) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

if (x3 == undefined || Number.isNaN(x3) || 'number' !== typeof x3) {
    throw new Error("x3 is undefined or null")
}

if (y3 == undefined || Number.isNaN(y3) || 'number' !== typeof y3) {
    throw new Error("y3 is undefined or null")
}

    return $collinear(x1, x2, y1, y2, x3, y3) && within(x1, x2, x3, y3, y1, y2);
}

/**
 * @class Segment2
 */
var Segment2 =  {
    create: create,
    clone: clone,
    copy: copy,
    normalize: normalize,
    translate: translate,
    length: length,
    sqrLength: sqrLength,
    midPoint: midPoint,
    slope: slope,
    angle: angle,
    cross: cross,
    closestPoint: closestPoint,
    isCollinear: isCollinear,
    isParallel: isParallel,
    isVec2Inside: isVec2Inside,
    isAbove: isAbove,
    leftNormal: leftNormal,
    rightNormal: rightNormal,

    // alias
    lengthSq: sqrLength,
    contains: isVec2Inside,

    $inside: $inside,
    $collinear: $collinear,
    $closestPoint: $closestPoint
};


module.exports = Segment2;
},{"./vec2.js":30}],28:[function(require,module,exports){
/*
 * Stability: 2 (fixes / performance improvements)
 *
 * @TODO expand all function, do not generate with loops
 */

var array = require("array-enhancements"),
    Beizer = require("./beizer.js"),
    beizer_cubic = Beizer.cubic,
    beizer_quadric = Beizer.quadric,
    beizer_solve = Beizer.solve,
    pow = Math.pow,
    sin = Math.sin,
    acos = Math.acos,
    cos = Math.cos,
    PI = Math.PI,
    t = {},
    k,
    Transitions = {},
    CHAIN = 1,
    STOP = 2,
    IGNORE = 3,
    CANCEL = 4;


function createCubic(cp1x, cp1y, cp2x, cp2y) {
    var curve = beizer_cubic(0, 0, cp1x, cp1y, cp2x, cp2y, 1, 1),
        aux = [0, 0];

    return function(t) {
        beizer_solve(aux, curve, t);

        return aux[1];
    }
}

function createQuadric(cp1x, cp1y) {
    var curve = beizer_quadric(0, 0, cp1x, cp1y, 1, 1),
        aux = [0, 0];

    return function(t) {
        beizer_solve(aux, curve, t);

        return aux[1];
    }
}

function Pow(pos, x) {
    return pow(pos, (x && x[0]) || 6);
}

function Expo(pos) {
    return pow(2, 8 * (pos - 1));
}

function Circ(pos) {
    return 1 - sin(acos(pos));
}

function Sine(pos) {
    return 1 - cos(pos * PI / 2);
}

function Back(pos, x) {
    x = (x && x[0]) || 1.618;
    return pow(pos, 2) * ((x + 1) * pos - x);
}

function Bounce(pos) {
    var value, a, b;
    for (a = 0, b = 1; true; a += b, b /= 2) {
        if (pos >= (7 - 4 * a) / 11) {
            value = b * b - pow((11 - 6 * a - 11 * pos) / 4, 2);
            break;
        }
    }
    return value;
}

function Elastic(pos, x) {
    return pow(2, 10 * --pos) * cos(20 * pos * PI * ((x && x[0]) || 1) / 3);
}



/**
 * Just return what you sent
 * @param {Number} pos
 */
function linear(pos) {
if (pos == undefined || Number.isNaN(pos) || 'number' !== typeof pos) {
    throw new Error("pos is undefined or null")
}

    return pos;
}

/**
 * Wrap your transaction with In/Out/InOut modifiers.
 * @param {String} name
 * @param {Function} transition
 */
function create(name, transition) {
if ('string' !== typeof name) {
    throw new Error("name is undefined or null")
}

if ('function' !== typeof transition) {
    throw new Error("transition is not a function")
}


    //Transitions[name] = function (pos) {
    //    return transition(pos);
    //};
    //Transitions[name + "In"] = Transitions[name];

    Transitions[name] = transition;

    Transitions[name + "In"] = transition;

    Transitions[name + "Out"] = function (pos) {
        return 1 - transition(1 - pos);
    };

    Transitions[name + "InOut"] = function (pos) {
        return (pos <= 0.5 ? transition(2 * pos) : (2 - transition(2 * (1 - pos)))) / 2;
    };
}

t = {
    Pow: Pow,
    Expo: Expo,
    Circ: Circ,
    Sine: Sine,
    Back: Back,
    Bounce: Bounce,
    Elastic: Elastic
};

for (k in t) {
    create(k, t[k]);
}

["Quad", "Cubic", "Quart", "Quint"].forEach(function (transition, i) {
    create(transition, function (p) {
        return pow(p, i + 2);
    });
});

// tween function

function _def_render(obj, prop, value) {
    obj[prop] = value;
}

function _def_parser(obj, prop) {
    return parseFloat(obj[prop], 10);
}

function _def_factor(k0, k1, rfactor) {
    return ((k1 - k0) * rfactor) + k0;
}

Transitions.LINK_CHAIN  = CHAIN;
Transitions.LINK_STOP   = STOP;
Transitions.LINK_IGNORE = IGNORE;
Transitions.LINK_CANCEL = CANCEL;

function _normalize(obj, input) {
    //get all props

    var keys = Object.keys(input).sort(function (a, b) { return parseFloat(a) - parseFloat(b); }),
        i,
        j,
        prop,
        key,
        fkey,
        prop_list = [],
        props = {},
        last;

    for (i = 0; i < keys.length; ++i) {
        prop_list = array.add(prop_list, Object.keys(input[keys[i]]));
    }
    prop_list = array.unique(prop_list);

    for (j = 0; j < prop_list.length; ++j) {
        prop = prop_list[j];
        props[prop] = {};

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            fkey = parseFloat(keys[i]);

            // first of the sorted list and is not 0%
            // set current value
            if (i === 0 && key !== "0%") {
                props[prop][0] = obj[prop];
            }

            if (input[key][prop] !== undefined) {
                props[prop][fkey] = last = input[key][prop];
            }
        }

        // check that has 100% if not set the last known value
        if (props[prop]["100"] === undefined) {
            props[prop][100] = last;
        }

    }

    return props;
}

/**
 * Animate object properties.
 *
 * *obj* must be writable or at least have defined $__tween
 * *prop* property name to animate
 * *values* keys are numbers from 0 to 100, values could be anything
 * *ioptions*
 * **mandatory**
 *   * **time**: <number> in ms
 *
 * **optional**
 *   * **transition** Transition.XXX, or a valid compatible function Default: linear
 *   * **link** Transition.LINK_XXX Default: CHAIN
 *   * **render** function(obj, property, new_value) {}
 *   * **parser** function(obj, property) { return <value>; }
 *   * **tickEvent** <string> event name Default: "tick"
 *   * **endEvent** <string> event name Default: "animation:end"
 *   * **startEvent** <string> event name Default: "animation:star"
 *   * **chainEvent** <string> event name Default: "animation:chain"
 *
 * @param {Object} obj
 * @param {String|Number} prop
 * @param {Array|Object} values
 * @param {Object} ioptions
 */
function animate(obj, prop, values, ioptions) {
if ('object' !== typeof obj || Array.isArray(obj) || obj === null) {
    throw new Error("obj is not a object")
}

if (!('string' !== typeof prop) && !(prop == undefined || Number.isNaN(prop) || 'number' !== typeof prop)) {
    throw new Error("prop is undefined or null OR prop is undefined or null")
}

if (!(!Array.isArray(values)) && !('object' !== typeof values || Array.isArray(values) || values === null)) {
    throw new Error("values is not a array OR values is not a object")
}

if ('object' !== typeof ioptions || Array.isArray(ioptions) || ioptions === null) {
    throw new Error("ioptions is not a object")
}

    // lazy init
    obj.$__tween = obj.$__tween || {};

    //console.log("options", JSON.stringify(options), JSON.stringify(values));
    // <debug>
    if ("function" !== typeof obj.on) {
        throw new Error("obj must be an event-emitter");
    }
    if ("function" !== typeof obj.removeListener) {
        throw new Error("obj must be an event-emitter");
    }
    if ("number" !== typeof ioptions.time) {
        throw new Error("options.time is mandatory");
    }
    // </debug>

        //soft clone and defaults
    var options = {
            render: ioptions.render || _def_render,
            parser: ioptions.parser || _def_parser,
            applyFactor: ioptions.applyFactor || _def_factor,
            transition: ioptions.transition || Transitions.linear,
            link: ioptions.link || CHAIN,
            tickEvent: ioptions.tickEvent || "tick",
            endEvent: ioptions.endEvent || "animation:end",
            startEvent: ioptions.startEvent || "animation:start", // first emit
            chainEvent: ioptions.chainEvent || "animation:chain",
            time: ioptions.time,
            start: Date.now(),
            current: 0
        },
        chain_fn,
        kvalues = Object.keys(values),
        fvalues = kvalues.map(function (val) { return parseFloat(val) * 0.01; }),
        update_fn;

    //console.log("options", JSON.stringify(options), JSON.stringify(values));

    update_fn = function (delta) {
        //console.log(prop, "tween @", delta, options, values);
        if (!delta) {
            throw new Error("trace");
        }
        options.current += delta;



        var factor = options.current / options.time,
            tr_factor,
            i,
            found = false,
            max = kvalues.length,
            k0,
            k1,
            rfactor;

        //clamp
        if (factor > 1) { // end
            factor = 1;
            tr_factor = 1;
        } else {
            tr_factor = options.transition(factor);
        }

        for (i = 0; i < max && !found; ++i) {
            k0 = fvalues[i];
            if (k0 <= tr_factor) {
                if (i === max - 1) {
                    // last element
                    found = true;
                    k0 = fvalues[i - 1];
                    k1 = fvalues[i];
                } else {
                    k1 = fvalues[i + 1];

                    if (k1 > tr_factor) {
                        found = true;
                    }
                }


                if (found === true) {
                    //console.log(prop, "ko", k0, "k1", k1);
                    //console.log(prop, tr_factor);

                    if (tr_factor === 1) {
                        options.render(obj, prop, values["100"]);

                        // this is the end, my only friend, the end...
                        obj.removeListener(options.tickEvent, obj.$__tween[prop]);
                        delete obj.$__tween[prop];
                        obj.emit(options.endEvent, options);
                    } else {
                        rfactor = (tr_factor - k0) / (k1 - k0);
                        //console.log(prop, i, rfactor);

                        //console.log(prop, rfactor, "k0", values[k0], "k1", values[k1]);

                        options.render(obj, prop,
                            options.applyFactor(values[kvalues[i]], values[kvalues[i + 1]], rfactor)
                            );
                    }
                }
            }
        }
    };

    if (obj.$__tween[prop]) {
        // link will told us what to do!
        switch (options.link) {
        case IGNORE:
            return IGNORE;
        case CHAIN:

            chain_fn = function () {
                if (!obj.$__tween[prop]) {
                    obj.$__tween[prop] = update_fn;
                    obj.on(options.tickEvent, obj.$__tween[prop]);
                    obj.removeListener(options.endEvent, chain_fn);
                }
            };

            obj.on(options.endEvent, chain_fn);
            obj.emit(options.chainEvent, options);

            return CHAIN;
        case STOP:
            obj.removeListener(options.tickEvent, obj.$__tween[prop]);
            delete obj.$__tween[prop];

            return STOP;
        case CANCEL:
            obj.removeListener(options.tickEvent, obj.$__tween[prop]);
            delete obj.$__tween[prop];
            // and attach!

            obj.$__tween[prop] = update_fn;
            obj.on(options.tickEvent, obj.$__tween[prop]);
            break;
        }
    } else {
        obj.$__tween[prop] = update_fn;
        obj.on(options.tickEvent, obj.$__tween[prop]);
    }



    return true;
}

/**
 * @param {Object} obj
 * @param {Object} params
 * @param {Object} options
 */
function tween(obj, params, options) {
if ('object' !== typeof obj || Array.isArray(obj) || obj === null) {
    throw new Error("obj is not a object")
}

if ('object' !== typeof params || Array.isArray(params) || params === null) {
    throw new Error("params is not a object")
}

if ('object' !== typeof options || Array.isArray(options) || options === null) {
    throw new Error("options is not a object")
}

    // <debug>
    if (!params.hasOwnProperty("100%")) {
        throw new Error("100% params must exists");
    }

    if ("function" !== typeof obj.on) {
        throw new Error("obj must be an event-emitter");
    }
    if ("function" !== typeof obj.removeListener) {
        throw new Error("obj must be an event-emitter");
    }
    if ("number" !== typeof options.time) {
        throw new Error("options.time is mandatory");
    }
    // </debug>

    options = options || {};
    // set defaults
    options.render = options.render || _def_render;
    options.parser = options.parser || _def_parser;
    options.transition = options.transition || Transitions.linear;
    options.link = options.link || CHAIN;
    options.tick = options.tick || "tick";

    // set config
    obj.$__tween = obj.$__tween || {};

    var plist = _normalize(obj, params),
        i;

    // animate each property
    for (i in plist) {
        Transitions.animate(obj, i, plist[i], options);
    }

}


Transitions.tween = tween;
Transitions.animate = animate;
Transitions.linear = linear;
Transitions.create = create;

Transitions.createCubic = createCubic;
Transitions.createQuadric = createQuadric;

module.exports = Transitions;
},{"./beizer.js":4,"array-enhancements":32}],29:[function(require,module,exports){
/**
 * Stability: 2 (fixes / performance improvements)
 *
 * Triangle is represented as a three coordinates array
 * [A:Vec2, B:Vec2, C:Vec2]
 */


var Vec2 = require("./vec2.js"),
    vec2_midpoint = Vec2.midPoint,
    vec2_distance = Vec2.distance,
    vec2_pow = Vec2.pow,
    vec2_dot = Vec2.dot,
    DIV3 = 1 / 3,
    ah = [0, 0],
    bh = [0, 0],
    ch = [0, 0],
    dab = [0, 0],
    dbc = [0, 0],
    dca = [0, 0],
    det = 0,
    a = 0,
    b = 0,
    c = 0;
/**
 * A(x1, y1), B(x2, y2), C(x3, y3)
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Number} x3
 * @param {Number} y3
 * @return {Triangle}
 */
function create(x1, y1, x2, y2, x3, y3) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

if (x3 == undefined || Number.isNaN(x3) || 'number' !== typeof x3) {
    throw new Error("x3 is undefined or null")
}

if (y3 == undefined || Number.isNaN(y3) || 'number' !== typeof y3) {
    throw new Error("y3 is undefined or null")
}

    var out = [[x1, y1], [x2, y2], [x3, y3], false];

    //normalize(out, out);
    return out;
}
/**
 * @return {Triangle}
 */
function zero() {
    return [[0, 0], [0, 0], [0, 0], true];
}
/**
 * @param {Triangle} tri
 * @return {Triangle}
 */
function clone(tri) {
if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    return [[tri[0][0], tri[0][1]], [tri[1][0], tri[1][1]], [tri[2][0], tri[2][1]], tri[3]];
}
/**
 * @param {Triangle} out_tri
 * @param {Triangle} tri
 * @return {Triangle}
 */
function copy(out_tri, tri) {
if (!Array.isArray(out_tri) || out_tri[0][0] == undefined || Number.isNaN(out_tri[0][0]) || 'number' !== typeof out_tri[0][0] || out_tri[0][1] == undefined || Number.isNaN(out_tri[0][1]) || 'number' !== typeof out_tri[0][1] || out_tri[1][0] == undefined || Number.isNaN(out_tri[1][0]) || 'number' !== typeof out_tri[1][0] || out_tri[1][1] == undefined || Number.isNaN(out_tri[1][1]) || 'number' !== typeof out_tri[1][1] || out_tri[2][0] == undefined || Number.isNaN(out_tri[2][0]) || 'number' !== typeof out_tri[2][0] || out_tri[2][1] == undefined || Number.isNaN(out_tri[2][1]) || 'number' !== typeof out_tri[2][1]) {
    throw new Error("invalid Traingle out_tri")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    out_tri[0][0] = tri[0][0];
    out_tri[0][1] = tri[0][1];

    out_tri[1][0] = tri[1][0];
    out_tri[1][1] = tri[1][1];

    out_tri[2][0] = tri[2][0];
    out_tri[2][1] = tri[2][1];

    out_tri[3] = tri[3];

    return out_tri;
}

/**
 * @param {Vec2} out_vec2
 * @param {Triangle} tri
 * @return {Vec2}
 */
function abMidPoint(out_vec2, tri) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    return vec2_midpoint(out_vec2, tri[0], tri[1]);
}
/**
 * @param {Vec2} out_vec2
 * @param {Triangle} tri
 * @return {Vec2}
 */
function bcMidPoint(out_vec2, tri) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    return vec2_midpoint(out_vec2, tri[1], tri[2]);
}
/**
 * @param {Vec2} out_vec2
 * @param {Triangle} tri
 * @return {Vec2}
 */
function caMidPoint(out_vec2, tri) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    return vec2_midpoint(out_vec2, tri[2], tri[0]);
}
/**
 * @param {Triangle} out
 * @param {Triangle} tri
 * @return {Triangle}
 */
function midTriangle(out, tri) {
if (!Array.isArray(out) || out[0][0] == undefined || Number.isNaN(out[0][0]) || 'number' !== typeof out[0][0] || out[0][1] == undefined || Number.isNaN(out[0][1]) || 'number' !== typeof out[0][1] || out[1][0] == undefined || Number.isNaN(out[1][0]) || 'number' !== typeof out[1][0] || out[1][1] == undefined || Number.isNaN(out[1][1]) || 'number' !== typeof out[1][1] || out[2][0] == undefined || Number.isNaN(out[2][0]) || 'number' !== typeof out[2][0] || out[2][1] == undefined || Number.isNaN(out[2][1]) || 'number' !== typeof out[2][1]) {
    throw new Error("invalid Traingle out")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    abMidPoint(out[0], tri);
    bcMidPoint(out[1], tri);
    caMidPoint(out[2], tri);

    return out;

}
/**
 * @param {Triangle} tri
 * @return {Number}
 */
function perimeter(tri) {
if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    return vec2_distance(tri[0], tri[1]) +
        vec2_distance(tri[1], tri[2]) +
        vec2_distance(tri[2], tri[0]);
}

/**
 * @param {Vec2} out_vec2
 * @param {Triangle} tri
 * @return {Vec2}
 */
function centroid(out_vec2, tri) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    out_vec2[0] = (tri[0][0] + tri[1][0] + tri[2][0]) * DIV3;
    out_vec2[1] = (tri[0][1] + tri[1][1] + tri[2][1]) * DIV3;

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Triangle} tri
 * @return {Vec2}
 */
function incenter(out_vec2, tri) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    a = Vec2.distance(tri[1], tri[2]);
    b = Vec2.distance(tri[2], tri[0]);
    c = Vec2.distance(tri[0], tri[1]);

    out_vec2[0] = (a * tri[0][0] + b * tri[1][0] + c * tri[2][0]) * DIV3;
    out_vec2[1] = (a * tri[0][1] + b * tri[1][1] + c * tri[2][1]) * DIV3;

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Triangle} tri
 * @return {Vec2}
 */
function circumcenter(out_vec2, tri) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    var bx = tri[1][0] - tri[0][0],
        by = tri[1][1] - tri[0][1],
        bl = bx * bx + by * by,
        cx = tri[2][0] - tri[0][0],
        cy = tri[2][1] - tri[0][1],
        cl = cx * cx + cy * cy,
        d = 2 * (bx * cy - by * cx),
        x = cy * bl - by * cl,
        y = bx * cl - cx * bl;

    out_vec2[0] = x / d + tri[0][0];
    out_vec2[1] = y / d + tri[0][1];

    return out_vec2;
}
/**
 * @param {Triangle} tri
 * @return {Number}
 */
function area(tri) {
if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

    dab = Vec2.min(dbc, tri[1], tri[0]);
    dbc = Vec2.min(dbc, tri[2], tri[0]);

    return (dbc[1] * dab[0] - dbc[0] * dab[1]) * 0.5;
}

/**
 * @param {Triangle} out
 * @param {Triangle} tri
 * @param {Vec2} vec2
 * @return {Triangle}
 */
function translate(out, tri, vec2) {
if (!Array.isArray(out) || out[0][0] == undefined || Number.isNaN(out[0][0]) || 'number' !== typeof out[0][0] || out[0][1] == undefined || Number.isNaN(out[0][1]) || 'number' !== typeof out[0][1] || out[1][0] == undefined || Number.isNaN(out[1][0]) || 'number' !== typeof out[1][0] || out[1][1] == undefined || Number.isNaN(out[1][1]) || 'number' !== typeof out[1][1] || out[2][0] == undefined || Number.isNaN(out[2][0]) || 'number' !== typeof out[2][0] || out[2][1] == undefined || Number.isNaN(out[2][1]) || 'number' !== typeof out[2][1]) {
    throw new Error("invalid Traingle out")
}

if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    out[0][0] = tri[0][0] + vec2[0];
    out[0][1] = tri[0][1] + vec2[1];

    out[1][0] = tri[1][0] + vec2[0];
    out[1][1] = tri[1][1] + vec2[1];

    out[2][0] = tri[2][0] + vec2[0];
    out[2][1] = tri[2][1] + vec2[1];

    return out;
}

var ac = [0, 0],
    ab = [0, 0],
    av = [0, 0],
    dot00,
    dot01,
    dot02,
    dot11,
    dot12,
    invDenom,
    u,
    v;

/**
 * @param {Triangle} tri
 * @param {Vec2} vec2
 * @return {Boolean}
 */
function isVec2Inside(tri, vec2) {
if (!Array.isArray(tri) || tri[0][0] == undefined || Number.isNaN(tri[0][0]) || 'number' !== typeof tri[0][0] || tri[0][1] == undefined || Number.isNaN(tri[0][1]) || 'number' !== typeof tri[0][1] || tri[1][0] == undefined || Number.isNaN(tri[1][0]) || 'number' !== typeof tri[1][0] || tri[1][1] == undefined || Number.isNaN(tri[1][1]) || 'number' !== typeof tri[1][1] || tri[2][0] == undefined || Number.isNaN(tri[2][0]) || 'number' !== typeof tri[2][0] || tri[2][1] == undefined || Number.isNaN(tri[2][1]) || 'number' !== typeof tri[2][1]) {
    throw new Error("invalid Traingle tri")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}


    // Compute vectors
    // ac = C - A
    Vec2.sub(ac, tri[2], tri[0]);
    // ab = B - A
    Vec2.sub(ab, tri[1], tri[0]);
    // av = P - A
    Vec2.sub(av, vec2, tri[0]);

    // Compute dot products
    dot00 = vec2_dot(ac, ac)
    dot01 = vec2_dot(ac, ab)
    dot02 = vec2_dot(ac, av)
    dot11 = vec2_dot(ab, ab)
    dot12 = vec2_dot(ab, av)

    // Compute barycentric coordinates
    invDenom = 1 / (dot00 * dot11 - dot01 * dot01)
    u = (dot11 * dot02 - dot01 * dot12) * invDenom
    v = (dot00 * dot12 - dot01 * dot02) * invDenom

    // Check if point is in triangle
    return (u >= 0) && (v >= 0) && (u + v < 1);
}

/**
 * @class Triangle
 */
var Triangle = {
    create: create,
    zero: zero,
    clone: clone,
    copy: copy,

    abMidPoint: abMidPoint,
    bcMidPoint: bcMidPoint,
    caMidPoint: caMidPoint,
    midTriangle: midTriangle,

    perimeter: perimeter,

    centroid: centroid,
    incenter: incenter,
    circumcenter: circumcenter,
    area: area,
    translate: translate,
    isVec2Inside: isVec2Inside,

    // alias
    center: centroid,
};

module.exports = Triangle;
},{"./vec2.js":30}],30:[function(require,module,exports){
/**
 * Stability: 2 (fixes / performance improvements)
 *
 * Vec2 is represented as a two coordinates array
 * [x:Number, y:Number]
 */

var aux_vec = [0, 0],
    __x = 0,
    __y = 0,
    aux_number1 = 0,
    aux_number2 = 0,
    aux_number3 = 0,

    //cache
    EPS = Math.EPS,
    acos = Math.acos,
    cos  = Math.cos,
    sqrt = Math.sqrt,
    __abs  = Math.abs,
    sin  = Math.sin,
    __min  = Math.min,
    atan2 = Math.atan2,
    __pow = Math.pow,

    HALF_NPI = Math.HALF_NPI,
    HALF_PI = Math.HALF_PI,

    DEG_TO_RAD = Math.DEG_TO_RAD,
    Vec2;

/**
 * Create a Vec2 given two coords
 *
 * @param {Vec2|Number} x
 * @param {Number} y
 * @return {Vec2}
 */
function create(x, y) {
if (!(!Array.isArray(x) || x[0] == undefined || Number.isNaN(x[0]) || 'number' !== typeof x[0] || x[1] == undefined || Number.isNaN(x[1]) || 'number' !== typeof x[1]) && !(x == undefined || Number.isNaN(x) || 'number' !== typeof x)) {
    throw new Error("invalid Vec2 x OR x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

    return [x, y];
}

/**
 * Create a Vec2 given length and angle
 *
 * @param {Number} length
 * @param {Number} degrees
 * @return {Vec2}
 */
function dFromPolar(length, degrees) {
if (length == undefined || Number.isNaN(length) || 'number' !== typeof length) {
    throw new Error("length is undefined or null")
}

if (degrees == undefined || Number.isNaN(degrees) || 'number' !== typeof degrees) {
    throw new Error("degrees is undefined or null")
}

    return fromPolar(length, degrees * DEG_TO_RAD);
}

/**
 * Create a Vec2 given length and angle
 *
 * @param {Number} length
 * @param {Number} radians
 * @return {Vec2}
 */
function fromPolar(length, radians) {
if (length == undefined || Number.isNaN(length) || 'number' !== typeof length) {
    throw new Error("length is undefined or null")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    return [length * sin(radians), length * cos(radians)];
}

/**
 * Create an empty Vec2
 *
 * @return {Vec2}
 */
function zero() {
    return [0, 0];
}

/**
 * Clone given vec2
 *
 * @param {Vec2} v1
 * @return {Vec2}
 */
function clone(v1) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    return [v1[0], v1[1]];
}

// **********************************************************
// comparison operations
// **********************************************************

/**
 * Returns true if both vectors are equal(same coords)
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Boolean}
 */
function equals(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    return v2[0] === v1[0] && v2[1] === v1[1];
}
/**
 * Returns true if both vectors are "almost(Math.EPS)" equal
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Boolean}
 */
function equalsEpsilon(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    aux_number1 = __abs(v2[0] - v1[0]);
    aux_number2 = __abs(v2[1] - v1[1]);

    return aux_number1 < EPS && aux_number2 < EPS;
}
/**
 * Returns true both coordinates of v1 area greater than v2
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Boolean}
 */
function gt(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    return v2[0] > v1[0] && v2[1] > v1[1];
}
/**
 * Returns true both coordinates of v1 area lesser than v2
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Boolean}
 */
function lt(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    return v2[0] < v1[0] && v2[1] < v1[1];
}

/**
 * Returns true if the distance between v1 and v2 is less than dist.
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @param {Number} dist
 * @return {Boolean}
 */
function near(v1, v2, dist) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

if (dist == undefined || Number.isNaN(dist) || 'number' !== typeof dist) {
    throw new Error("dist is undefined or null")
}

    // maybe inline
    aux_number1 = sqrDistance(v1, v2);


    return aux_number1 < dist * dist;
}

/**
 * * 0 equal
 * * 1 top
 * * 2 top-right
 * * 3 right
 * * 4 bottom right
 * * 5 bottom
 * * 6 bottom-left
 * * 7 left
 * * 8 top-left
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Number}
 */
function compare(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    var v1x = v1[0],
        v1y = v1[1],
        v2x = v2[0],
        v2y = v2[1];

    if (v2x === v1x && v2y === v1y) {
        return 0;
    }
    if (v2x === v1x) {
        return v2y > v1y ? 1 : 5;
    }
    if (v2y === v1y) {
        return v2x > v1x ? 3 : 7;
    }

    if (v2x > v1x) {
        if (v2y > v1y) {
            return 2;
        }

        if (v2y < v1y) {
            return 4;
        }
    }

    if (v2x < v1x) {
        if (v2y < v1y) {
            return 6;
        }
        if (v2y > v1y) {
            return 8;
        }
    }

    return -1;
}

// **********************************************************
// validation
// **********************************************************
/**
 * The vector does not contain any not number value: Infinity || NaN
 *
 * @param {Vec2} v1
 * @return {Boolean}
 */
function isValid(v1) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    return !(v1[0] === Infinity || v1[0] === -Infinity || isNaN(v1[0]) || v1[1] === Infinity || v1[1] === -Infinity || isNaN(v1[1]));
}
/**
 * Any coordinate is NaN? -> true
 *
 * @param {Vec2} v1
 * @return {Boolean}
 */
function isNaN(v1) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    return isNaN(v1[0]) || isNaN(v1[1]);
}

// **********************************************************
// first parameter is the output
// **********************************************************

/**
 * Copy v1 into out_vec2
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @return {Vec2}
 */
function copy(out_vec2, v1) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    out_vec2[0] = v1[0];
    out_vec2[1] = v1[1];

    return out_vec2;
}

/**
 * Negate v1 into out_vec2
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @return {Vec2}
 */
function negate(out_vec2, v1) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    out_vec2[0] = -v1[0];
    out_vec2[1] = -v1[1];

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @return {Vec2}
 */
function normalize(out_vec2, v1) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    __x = v1[0];
    __y = v1[1];
    aux_number3 = sqrt(__x * __x + __y * __y);

    if (aux_number3 > EPS) {
        aux_number3 = 1 / aux_number3;
        out_vec2[0] = v1[0] * aux_number3;
        out_vec2[1] = v1[1] * aux_number3;
    }

    return out_vec2;
}
/**
 * Normalize v1 but squared no use sqrt, for performance.
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @return {Vec2}
 */
function normalizeSq(out_vec2, v1) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    __x = v1[0];
    __y = v1[1];
    aux_number3 = __x * __x + __y * __y;

    if (aux_number3 > EPS * EPS) {
        aux_number3 = 1 / aux_number3;
        out_vec2[0] = v1[0] * aux_number3;
        out_vec2[1] = v1[1] * aux_number3;
    }

    return out_vec2;
}
/**
 * Rotate the vector clockwise
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @return {Vec2}
 */
function perpendicular(out_vec2, v1) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    aux_number1 = v1[0];
    out_vec2[0] = v1[1];
    out_vec2[1] = -aux_number1;

    return out_vec2;
}
/**
 * Rotate the vector counterclockwise
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @return {Vec2}
 */
function rperpendicular(out_vec2, v1) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    aux_number1 = v1[0];
    out_vec2[0] = -v1[1];
    out_vec2[1] = aux_number1;

    return out_vec2;
}

/**
 * Linearly interpolate between a and b.
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @param {Number} t
 * @return {Vec2}
 */
function lerp(out_vec2, v1, v2, t) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

if (t == undefined || Number.isNaN(t) || 'number' !== typeof t) {
    throw new Error("t is undefined or null")
}

    out_vec2[0] = v1[0] + (v2[0] - v1[0]) * t;
    out_vec2[1] = v1[1] + (v2[1] - v1[1]) * t;

    return out_vec2;
}

/**
 * Linearly interpolate between v1 towards v2 by distance d.
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @param {Number} d
 * @return {Vec2}
 */
function lerpconst(out_vec2, v1, v2, d) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

if (d == undefined || Number.isNaN(d) || 'number' !== typeof d) {
    throw new Error("d is undefined or null")
}

    out_vec2[0] = v2[0] - v1[0];
    out_vec2[1] = v2[1] - v1[1];

    clamp(out_vec2, out_vec2, d);

    out_vec2[0] += v1[0];
    out_vec2[1] += v1[1];

    return out_vec2;
}

/**
 * Spherical linearly interpolate between v1 and v2.
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @param {Number} t
 * @return {Vec2}
 */
function slerp(out_vec2, v1, v2, t) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

if (t == undefined || Number.isNaN(t) || 'number' !== typeof t) {
    throw new Error("t is undefined or null")
}

    var omega = acos(dot(v1, v2)),
        denom;

    if (omega) {
        denom = 1.0 / sin(omega);

        scale(out_vec2, v1, sin((1.0 - t) * omega) * denom);
        scale(aux_vec, sin(t * omega) * denom);

        return add(out_vec2, out_vec2, aux_vec);
    }

    return copy(out_vec2, v1);
}

/**
 * Spherical linearly interpolate between v1 towards v2 by no more than angle a in radians.
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @param {Number} radians
 * @return {Vec2}
 */
function slerpconst(out_vec2, v1, v2, radians) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    var _radians = acos(dot(v1, v2));
    return slerp(out_vec2, v1, v2, __min(radians, _radians) / _radians);
}

/**
 * Returns the unit length vector for the given angle (in radians).
 *
 * @param {Vec2} out_vec2
 * @param {Number} radians
 * @return {Vec2}
 */
function forAngle(out_vec2, radians) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    out_vec2[0] = cos(radians);
    out_vec2[1] = sin(radians);

    return out_vec2;
}

/**
 * Returns the vector projection of v1 onto v2.
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Vec2}
 */
function project(out_vec2, v1, v2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    multiply(out_vec2, v1, v2);
    scale(out_vec2, dot(v1, v2) / dot(v2, v2));

    return out_vec2;
}

/**
 * Rotates the point by the given angle
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} radians
 * @return {Vec2}
 */
function rotate(out_vec2, v1, radians) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

    var s = sin(radians),
        c = cos(radians);

    __x = v1[0];
    __y = v1[1];

    out_vec2[0] = __x * c - __y * s;
    out_vec2[1] = __y * c + __x * s;

    return out_vec2;
}
/**
 * Rotates the point by the given angle around an optional center point.
 *
 * @note center cannot be out_vec2
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} radians
 * @param {Vec2} center
 * @return {Vec2}
 */
function rotateFrom(out_vec2, v1, radians, center) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (radians == undefined || Number.isNaN(radians) || 'number' !== typeof radians) {
    throw new Error("radians is undefined or null")
}

if (!Array.isArray(center) || center[0] == undefined || Number.isNaN(center[0]) || 'number' !== typeof center[0] || center[1] == undefined || Number.isNaN(center[1]) || 'number' !== typeof center[1]) {
    throw new Error("invalid Vec2 center")
}

    subtract(out_vec2, v1, center);

    __x = out_vec2[0];
    __y = out_vec2[1];

    var s = sin(radians),
        c = cos(radians);


    out_vec2[0] = __x * c - __y * s;
    out_vec2[1] = __y * c + __x * s;

    add(out_vec2, out_vec2, center);

    return out_vec2;
}
/**
 * Rotate a vector given "angle" by a normalized vector v2_n
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2_n
 * @return {Vec2}
 */
function rotateVec(out_vec2, v1, v2_n) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2_n) || v2_n[0] == undefined || Number.isNaN(v2_n[0]) || 'number' !== typeof v2_n[0] || v2_n[1] == undefined || Number.isNaN(v2_n[1]) || 'number' !== typeof v2_n[1]) {
    throw new Error("invalid Vec2 v2_n")
}

    out_vec2[0] = v1[0] * v2_n[0] - v1[1] * v2_n[1];
    out_vec2[1] = v1[0] * v2_n[1] + v1[1] * v2_n[0];

    return out_vec2;
}
/**
 * Un-rotate a vector given "angle" by a normalized vector v2_n
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2_n
 * @return {Vec2}
 */
function unrotateVec(out_vec2, v1, v2_n) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2_n) || v2_n[0] == undefined || Number.isNaN(v2_n[0]) || 'number' !== typeof v2_n[0] || v2_n[1] == undefined || Number.isNaN(v2_n[1]) || 'number' !== typeof v2_n[1]) {
    throw new Error("invalid Vec2 v2_n")
}

    out_vec2[0] = v1[0] * v2_n[0] + v1[1] * v2_n[1];
    out_vec2[1] = v1[1] * v2_n[0] - v1[0] * v2_n[1];

    return out_vec2;
}
/**
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Vec2}
 */
function midPoint(out_vec2, v1, v2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    out_vec2[0] = (v1[0] + v2[0]) * 0.5;
    out_vec2[1] = (v1[1] + v2[1]) * 0.5;

    return out_vec2;
}

var reflect_factor;
/**
 * Reflect v1 by the imaginary line v2_n
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2_n
 * @return {Vec2}
 */
function reflect(out_vec2, v1, v2_n) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2_n) || v2_n[0] == undefined || Number.isNaN(v2_n[0]) || 'number' !== typeof v2_n[0] || v2_n[1] == undefined || Number.isNaN(v2_n[1]) || 'number' !== typeof v2_n[1]) {
    throw new Error("invalid Vec2 v2_n")
}

    reflect_factor = dot(v1, v2_n);

    scale(out_vec2, v2_n, 2 * reflect_factor);
    subtract(out_vec2, v1, out_vec2);

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Vec2}
 */
function subtract(out_vec2, v1, v2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    out_vec2[0] = v1[0] - v2[0];
    out_vec2[1] = v1[1] - v2[1];

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} x
 * @param {Number} y
 * @return {Vec2}
 */
function subtract2(out_vec2, v1, x, y) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

    out_vec2[0] = v1[0] - x;
    out_vec2[1] = v1[1] - y;

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Vec2}
 */
function add(out_vec2, v1, v2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    out_vec2[0] = v1[0] + v2[0];
    out_vec2[1] = v1[1] + v2[1];

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} x
 * @param {Number} y
 * @return {Vec2}
 */
function add2(out_vec2, v1, x, y) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

    out_vec2[0] = v1[0] + x;
    out_vec2[1] = v1[1] + y;

    return out_vec2;
}
/**
 * @see scale
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Vec2}
 */
function multiply(out_vec2, v1, v2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    out_vec2[0] = v1[0] * v2[0];
    out_vec2[1] = v1[1] * v2[1];

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} x
 * @param {Number} y
 * @return {Vec2}
 */
function multiply2(out_vec2, v1, x, y) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

    out_vec2[0] = v1[0] * x;
    out_vec2[1] = v1[1] * y;

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Vec2}
 */
function divide(out_vec2, v1, v2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    out_vec2[0] = v1[0] / v2[0];
    out_vec2[1] = v1[1] / v2[1];

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} x
 * @param {Number} y
 * @return {Vec2}
 */
function divide2(out_vec2, v1, x, y) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (x == undefined || Number.isNaN(x) || 'number' !== typeof x) {
    throw new Error("x is undefined or null")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

    out_vec2[0] = v1[0] / x;
    out_vec2[1] = v1[1] / y;

    return out_vec2;
}
/**
 * @see multiply
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} factor
 * @return {Vec2}
 */
function scale(out_vec2, v1, factor) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (factor == undefined || Number.isNaN(factor) || 'number' !== typeof factor) {
    throw new Error("factor is undefined or null")
}

    out_vec2[0] = v1[0] * factor;
    out_vec2[1] = v1[1] * factor;

    return out_vec2;
}
/**
 * (x1^y, y1^y)
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} y
 * @return {Vec2}
 */
function pow(out_vec2, v1, y) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (y == undefined || Number.isNaN(y) || 'number' !== typeof y) {
    throw new Error("y is undefined or null")
}

    if (y === 2) {
        out_vec2[0] = v1[0] * v1[0];
        out_vec2[1] = v1[1] * v1[1];
    } else {
        out_vec2[0] = __pow(v1[0], y);
        out_vec2[1] = __pow(v1[1], y);
    }

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Vec2}
 */
function max(out_vec2, v1, v2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    out_vec2[0] = v1[0] > v2[0] ? v1[0] : v2[0];
    out_vec2[1] = v1[1] > v2[1] ? v1[1] : v2[1];

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Vec2}
 */
function min(out_vec2, v1, v2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    out_vec2[0] = v1[0] < v2[0] ? v1[0] : v2[0];
    out_vec2[1] = v1[1] < v2[1] ? v1[1] : v2[1];

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @return {Vec2}
 */
function abs(out_vec2, v1) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    out_vec2[0] = __abs(v1[0]);
    out_vec2[1] = __abs(v1[1]);

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @param {Number} factor
 * @return {Vec2}
 */
function scaleAndAdd(out_vec2, v1, v2, factor) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

if (factor == undefined || Number.isNaN(factor) || 'number' !== typeof factor) {
    throw new Error("factor is undefined or null")
}

    out_vec2[0] = v1[0] + (v2[0] * factor);
    out_vec2[1] = v1[1] + (v2[1] * factor);

    return out_vec2;
}
/**
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} length
 * @return {Vec2}
 */
function clamp(out_vec2, v1, length) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (length == undefined || Number.isNaN(length) || 'number' !== typeof length) {
    throw new Error("length is undefined or null")
}

    out_vec2[0] = v1[0];
    out_vec2[1] = v1[1];

    if (dot(v1, v1) > length * length) {
        normalize(out_vec2);
        multiply(out_vec2, length);
    }

    return out_vec2;
}
/**
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Number} length
 */
function truncate(out_vec2, v1, length) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (length == undefined || Number.isNaN(length) || 'number' !== typeof length) {
    throw new Error("length is undefined or null")
}

    var length_sq = v1[0] * v1[0] + v1[1] * v1[1];
    if (length_sq > length * length) {
        return scale(out_vec2, v1, length / sqrt(length_sq));
    }

    out_vec2[0] = v1[0];
    out_vec2[1] = v1[1];

    return out_vec2;
}

/**
 * Cross product between a vector and the Z component of a vector
 * AKA Rotate CW and scale
 *
 * @todo test use rprependicular ?
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} vec2
 * @param {Number} factor
 * @return {Number}
 */
function crossVZ(out_vec2, vec2, factor) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

if (factor == undefined || Number.isNaN(factor) || 'number' !== typeof factor) {
    throw new Error("factor is undefined or null")
}

    rotate(out_vec2, vec2, HALF_NPI); // Rotate according to the right hand rule
    return scale(out_vec2, out_vec2, factor); // Scale with z
}
/**
 * Cross product between a vector and the Z component of a vector
 * AKA Rotate CCW and scale
 *
 * @todo test use prependicular ?
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} vec2
 * @param {Number} factor
 * @return {Vec2}
 */
function crossZV(out_vec2, factor, vec2) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (factor == undefined || Number.isNaN(factor) || 'number' !== typeof factor) {
    throw new Error("factor is undefined or null")
}

if (!Array.isArray(vec2) || vec2[0] == undefined || Number.isNaN(vec2[0]) || 'number' !== typeof vec2[0] || vec2[1] == undefined || Number.isNaN(vec2[1]) || 'number' !== typeof vec2[1]) {
    throw new Error("invalid Vec2 vec2")
}

    rotate(out_vec2, vec2, HALF_PI);
    return scale(out_vec2, out_vec2, factor);
}

var tp_left = [0, 0],
    tp_right = [0, 0];
/**
 * (A x B) x C = B(C  A) - A(C  B)
 * (A x B) x C = B(A.dot(C)) - A(B.dot(C))
 *
 * @param {Vec2} out_vec2
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @param {Vec2} v3
*/
function tripleProduct(out_vec2, v1, v2, v3) {
if (!Array.isArray(out_vec2) || out_vec2[0] == undefined || Number.isNaN(out_vec2[0]) || 'number' !== typeof out_vec2[0] || out_vec2[1] == undefined || Number.isNaN(out_vec2[1]) || 'number' !== typeof out_vec2[1]) {
    throw new Error("invalid Vec2 out_vec2")
}

if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

if (!Array.isArray(v3) || v3[0] == undefined || Number.isNaN(v3[0]) || 'number' !== typeof v3[0] || v3[1] == undefined || Number.isNaN(v3[1]) || 'number' !== typeof v3[1]) {
    throw new Error("invalid Vec2 v3")
}

    scale(tp_left, v2, dot(v1, v3));

    scale(tp_right, v1, dot(v2, v3));

    return subtract(out_vec2, tp_left, tp_right);
}

// **********************************************************
// functions that return numbers
// **********************************************************

/**
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Number}
 */
function magnitude(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    __x = v1[0] - v2[0];
    __y = v1[1] - v2[1];

    return __x / __y;
}

/**
 * v1  v2 = |a| * |b| * sin 
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Number}
 */
function dot(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    return v1[0] * v2[0] + v1[1] * v2[1];
}

/**
 * v1  v2 = |a| * |b| * sin 
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Number}
 */
function cross(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    return v1[0] * v2[1] - v1[1] * v2[0];
}
/**
 * @param {Vec2} v1
 * @return {Number}
 */
function toAngle(v1) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    return atan2(v1[1], v1[0]);
}

/**
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Number}
 */
function angleTo(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    return atan2(v2[1] - v1[1], v2[0] - v1[0]);
}

var distance_x,
    distance_y;
/**
 * Returns the distance between v1 and v2.
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Number}
 */
function distance(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    //subtract
    distance_x = v2[0] - v1[0];
    distance_y = v2[1] - v1[1];
    //sqrLength
    return sqrt(distance_x * distance_x + distance_y * distance_y);
}
/**
 * Distance without using sqrt (squared distance)
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Number}
 */
function sqrDistance(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    //subtract
    distance_x = v1[0] - v2[0];
    distance_y = v1[1] - v2[1];
    //sqrLength
    return distance_x * distance_x + distance_y * distance_y;
}

/**
 * Return vector the length.
 *
 * @param {Vec2} v1
 * @return {Number}
 */
function length(v1) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    return sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
}
/**
 * Squared length (no sqrt)
 *
 * @param {Vec2} v1
 * @return {Number}
 */
function sqrLength(v1) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    return v1[0] * v1[0] + v1[1] * v1[1];
}

/**
 * Return true if v2 is between v1 and v3(inclusive)
 *
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @param {Vec2} v3
 * @return {Boolean}
 */
function within(v1, v2, v3) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

if (!Array.isArray(v3) || v3[0] == undefined || Number.isNaN(v3[0]) || 'number' !== typeof v3[0] || v3[1] == undefined || Number.isNaN(v3[1]) || 'number' !== typeof v3[1]) {
    throw new Error("invalid Vec2 v3")
}

    return ((v1[0] <= v2[0] && v2[0] <= v3[0]) || (v3[0] <= v2[0] && v2[0] <= v1[0])) &&
          ((v1[1] <= v2[1] && v2[1] <= v3[1]) || (v3[1] <= v2[1] && v2[1] <= v1[1]));
}

/**
 * Return true if q is between p and r(inclusive)
 *
 * @param {Number} px
 * @param {Number} py
 * @param {Number} qx
 * @param {Number} qy
 * @param {Number} rx
 * @param {Number} ry
 * @return {Boolean}
 */
function $within(px, py, qx, qy, rx, ry) {
if (px == undefined || Number.isNaN(px) || 'number' !== typeof px) {
    throw new Error("px is undefined or null")
}

if (py == undefined || Number.isNaN(py) || 'number' !== typeof py) {
    throw new Error("py is undefined or null")
}

if (qx == undefined || Number.isNaN(qx) || 'number' !== typeof qx) {
    throw new Error("qx is undefined or null")
}

if (qy == undefined || Number.isNaN(qy) || 'number' !== typeof qy) {
    throw new Error("qy is undefined or null")
}

if (rx == undefined || Number.isNaN(rx) || 'number' !== typeof rx) {
    throw new Error("rx is undefined or null")
}

if (ry == undefined || Number.isNaN(ry) || 'number' !== typeof ry) {
    throw new Error("ry is undefined or null")
}

    return ((px <= qx && qx <= rx) || (rx <= qx && qx <= px)) &&
          ((py <= qy && qy <= ry) || (ry <= qy && qy <= py));
}

/**
 * p is near x  dist ("box test")
 *
 * @param {Number} px
 * @param {Number} py
 * @param {Number} qx
 * @param {Number} qy
 * @param {Number} dist EPS
 * @return {Boolean}
 */
function $near(px, py, qx, qy, dist) {
if (px == undefined || Number.isNaN(px) || 'number' !== typeof px) {
    throw new Error("px is undefined or null")
}

if (py == undefined || Number.isNaN(py) || 'number' !== typeof py) {
    throw new Error("py is undefined or null")
}

if (qx == undefined || Number.isNaN(qx) || 'number' !== typeof qx) {
    throw new Error("qx is undefined or null")
}

if (qy == undefined || Number.isNaN(qy) || 'number' !== typeof qy) {
    throw new Error("qy is undefined or null")
}

if (dist == undefined || Number.isNaN(dist) || 'number' !== typeof dist) {
    throw new Error("dist is undefined or null")
}

    return (px > qx ? (px - qx) < dist : (qx - px) < dist) &&
           (py > qy ? (py - qy) < dist : (qy - py) < dist);
}
/**
 *
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @return {Number}
 */
function $cross(x1, y1, x2, y2) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

    return x1 * y2 - y1 * x2;
}

/**
 *
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @return {Number}
 */
function $dot(x1, y1, x2, y2) {
if (x1 == undefined || Number.isNaN(x1) || 'number' !== typeof x1) {
    throw new Error("x1 is undefined or null")
}

if (y1 == undefined || Number.isNaN(y1) || 'number' !== typeof y1) {
    throw new Error("y1 is undefined or null")
}

if (x2 == undefined || Number.isNaN(x2) || 'number' !== typeof x2) {
    throw new Error("x2 is undefined or null")
}

if (y2 == undefined || Number.isNaN(y2) || 'number' !== typeof y2) {
    throw new Error("y2 is undefined or null")
}

    return x1 * x2 + y1 * y2;
}
/**
 * Swap vectors, both will be modified.
 * for lazy people
 * @param {Vec2} v1
 * @param {Vec2} v2
 * @return {Undefined}
 */
function swap(v1, v2) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

if (!Array.isArray(v2) || v2[0] == undefined || Number.isNaN(v2[0]) || 'number' !== typeof v2[0] || v2[1] == undefined || Number.isNaN(v2[1]) || 'number' !== typeof v2[1]) {
    throw new Error("invalid Vec2 v2")
}

    __x = v2[0];
    v2[0] = v1[0];
    v1[0] = __x;

    __x = v2[1];
    v2[1] = v1[1];
    v1[1] = __x;
}
/*
 * (x, y) with only two decimals, for readability
 * @param {Vec2} v1
 * @return {String}
 */
function toString(v1) {
if (!Array.isArray(v1) || v1[0] == undefined || Number.isNaN(v1[0]) || 'number' !== typeof v1[0] || v1[1] == undefined || Number.isNaN(v1[1]) || 'number' !== typeof v1[1]) {
    throw new Error("invalid Vec2 v1")
}

    return "(" + v1[0].toFixed(2) + "," + v1[1].toFixed(2) + ")";
}

Vec2 = {
    ZERO: [0, 0],
    create: create,
    dFromPolar: dFromPolar,
    fromPolar: fromPolar,
    zero: zero,
    clone: clone,
    equals: equals,
    equalsEpsilon: equalsEpsilon,
    gt: gt,
    lt: lt,
    near: near,
    isValid: isValid,
    isNaN: isNaN,
    copy: copy,
    negate: negate,
    perpendicular: perpendicular,
    perp: perpendicular,
    rotateCW: perpendicular,
    normalize: normalize,
    normalizeSq: normalizeSq,
    rperpendicular: rperpendicular,
    rperp: rperpendicular,
    rotateCCW: rperpendicular,
    lerp: lerp,
    interpolate: lerp,
    lerpconst: lerpconst,
    slerp: slerp,
    slerpconst: slerpconst,
    forAngle: forAngle,
    project: project,
    rotate: rotate,
    rotateFrom: rotateFrom,
    rotateVec: rotateVec,
    unrotateVec: unrotateVec,
    midPoint: midPoint,
    reflect: reflect,
    subtract: subtract,
    subtract2: subtract2,
    add: add,
    add2: add2,
    multiply: multiply,
    multiply2: multiply2,
    divide: divide,
    divide2: divide2,
    scale: scale,
    pow: pow,
    max: max,
    min: min,
    abs: abs,
    scaleAndAdd: scaleAndAdd,
    clamp: clamp,
    truncate: truncate,
    magnitude: magnitude,
    compare: compare,
    dot: dot,
    cross: cross,
    crossVZ: crossVZ,
    crossZV: crossZV,
    toAngle: toAngle,
    angle: toAngle,
    angleTo: angleTo,
    distance: distance,
    length: length,
    sqrDistance: sqrDistance,
    sqrLength: sqrLength,
    within: within,
    swap: swap,
    tripleProduct: tripleProduct,

    // alias
    eq: equals,
    sub: subtract,
    sub2: subtract2,
    mul: multiply,
    mul2: multiply2,
    div: divide,
    div2: divide2,
    distanceSq: sqrDistance,
    lengthSq: sqrLength,
    $within: $within,
    $near: $near,
    $cross: $cross,
    $dot: $dot,

    toString: toString
};

module.exports = Vec2;

},{}],31:[function(require,module,exports){
// from: http://jsdo.it/akm2/fhMC/js
// don't know the author :)
// I just lint the code... and adapt it to this lib philosophy

// Helper

function _mash(data) {
    data = data.toString();
    var n = 0xefc8249d,
        i,
        len,
        h;

    for (i = 0, len = data.length; i < len; i++) {
        n += data.charCodeAt(i);
        h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000;
    }
    return (n >>> 0) * 2.3283064365386963e-10;
}

/**
 * Random numbers generator
 * Returns an object with three methods
 * * uint32()
 * * random()
 * * fract53()
 *
 * @see http://baagoe.com/en/RandomMusings/javascript/
 * @see http://en.wikipedia.org/wiki/Xorshift
 * @source http://jsdo.it/akm2/fhMC/js
 *
 * @param {Array} seeds
 * @return {Object} {uint32: Function, random: Function, fract53: Function}
 */
function create(seeds) {
if (!Array.isArray(seeds)) {
    throw new Error("seeds is not a array")
}

    var self = this,
        seeds = (arguments.length) ? Array.prototype.slice.call(arguments) : [new Date().getTime()],

        x = 123456789,
        y = 362436069,
        z = 521288629,
        w = 88675123,
        v = 886756453,
        i,
        len,
        seed,
        t;

    for (i = 0, len = seeds.length; i < len; i++) {
        seed = seeds[i];
        x ^= _mash(seed) * 0x100000000;
        y ^= _mash(seed) * 0x100000000;
        z ^= _mash(seed) * 0x100000000;
        v ^= _mash(seed) * 0x100000000;
        w ^= _mash(seed) * 0x100000000;
    }

    return {
        uint32: function () {
            t = (x ^ (x >>> 7)) >>> 0;
            x = y;
            y = z;
            z = w;
            w = v;
            v = (v ^ (v << 6)) ^ (t ^ (t << 13)) >>> 0;
            return ((y + y + 1) * v) >>> 0;
        },

        random: function () {
            return self.uint32() * 2.3283064365386963e-10;
        },

        fract53: function () {
            return self.random() + (self.uint32() & 0x1fffff) * 1.1102230246251565e-16;
        }
    };
};

Xorshift = {
    create: create
};

module.exports = Xorshift;
},{}],32:[function(require,module,exports){
(function () {
    "use strict";

    module.exports = require("./lib/arrays.js");

}());
},{"./lib/arrays.js":33}],33:[function(require,module,exports){
(function () {
    "use strict";

/**
* TODO
* - some mozilla functions use .call but thisp could be "undefined" so -> can be replaced by direct call ?!
*
*/

    var slice = Array.prototype.slice,
        hasOwnProperty = Object.hasOwnProperty,
        __clone,
        __rfilter;

    /**
     * Create an array given any type of argument
     *
     * @param {Mixed} item
     * @returns {Array}
     */
    module.exports.ize = function (item) {
        if (item === null || item === undefined) {
            return [];
        }

        if (item instanceof Array) {
            return item;
        }

        if (hasOwnProperty.call(item, "callee")) {
            return slice.call(item);
        }

        // TODO deal with Iterable objects like Collections!

        return [ item ];
    };

    module.exports.from = Array.ize;

    /**
     * Append any given number of arrays into a new one
     * @todo support any type of arguments
     *
     * @returns Array
    */
    module.exports.add = function () {
        var i,
            j,
            ret = [],
            ar;

        for (i = 0; i < arguments.length; ++i) {
            ar = arguments[i];
            for (j = 0; j < ar.length; ++j) {
                ret.push(ar[j]);
            }
        }

        return ret;
    };
    /**
     * Clone (could be recursive) a dense array
     * Note: only loop arrays not objects
     *
     * @param Array ar
     * @param Boolean deep
     * @returns Array
    */
    module.exports.clone = __clone = function (ar, deep) {
        var i = ar.length,
            clone = new Array(i);
        while (i--) {
            if (deep && ar[i] instanceof Array) {
                clone[i] = __clone(ar[i], true);
            } else {
                clone[i] = ar[i];
            }
        }
        return clone;
    };
    /**
     * Add an element at the specified index
     *
     * @param {Array} ar
     * @param {Mixed} o The object to add
     * @param {int} index The index position the element has to be inserted
     * @return {Boolean} true if o is successfully inserted
     */
    module.exports.insertAt = function (ar, o, index) {
        if (index > -1 && index <= ar.length) {
            ar.splice(index, 0, o);
            return true;
        }
        return false;
    };
    /**
     * Get a random value, the array must be dense
     *
     * @param {Array} arr
     * @returns {Mixed}
     */
    module.exports.random = function (arr) {
        var l = Math.floor(Math.random() * arr.length);
        return arr[l];
    };
    /**
     * Create a new array removing duplicated values
     *
     * @param {Array} arr
     * @returns {Array}
     */
    module.exports.unique = function (arr) {
        var ret = [],
            i;

        for (i = 0; i < arr.length; ++i) {
            if (ret.indexOf(arr[i]) === -1) {
                ret.push(arr[i]);
            }
        }

        return ret;
    };

    /**
     * sort an array (must be dense)
     *
     * @param {Array} arr
     * @returns {Array}
     */
    module.exports.sortObject = function (arr, key) {
        arr.sort(function (a, b) {
            if ("string" === (typeof a[key])) {
                return a.value.toLowerCase().localeCompare(b.value.toLowerCase());
            }
            return a[key] - b[key];
        });

        return arr;
    };
    /**
     * This function shuffles (randomizes the order of the elements in) an array.
     * credits -  http://stackoverflow.com/questions/2450954/how-to-randomize-a-javascript-array
     * @note Given array is modified!
     * @param {Array} arr
     * @returns {Array}
     */
    module.exports.shuffle = function (arr) {
        var currentIndex = arr.length,
            temporaryValue,
            randomIndex;

        // While there remain elements to shuffle..
        while (0 !== currentIndex) {

            // Pick a remaining element..
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            // And swap it with the current element.
            temporaryValue = arr[currentIndex];
            arr[currentIndex] = arr[randomIndex];
            arr[randomIndex] = temporaryValue;
        }

        return arr;
    };

    /**
     * Iterates over each value in the array passing them to the callback function.
     * Returns an array with all the callback results
     * @param {Array} arr
     * @param {Function} fun
     * @returns {Array}
     */
    module.exports.rfilter = __rfilter = function (arr, fun /*, thisp */) {
        if (arr === null) {
            throw new TypeError();
        }

        var t = Object(arr),
            len = t.length >>> 0,
            res,
            thisp,
            i,
            val,
            r;

        if ("function" !== typeof fun) {
            throw new TypeError();
        }

        res = [];
        thisp = arguments[1];
        for (i = 0; i < len; i++) {
            if (i in t) {
                val = t[i]; // in case fun mutates this
                r = fun.call(thisp, val, i, t);
                if (r !== undefined) {
                    res.push(r);
                }
            }
        }

        return res;
    };

    module.exports.chunk = function (arr, size, preserve_keys) {
        preserve_keys = preserve_keys || false;

        var i = 0,
            j = 0,
            key,
            val,
            chunks = [[]];

        //while( @list( $key, $value ) = @each( arr ) ) {
        for (key = 0; key < arr.length; ++key) {
            val = arr[key];


            if (chunks[i].length < size) {
                if (preserve_keys) {
                    chunks[i][key] = val;
                    j++;
                } else {
                    chunks[i].push(val);
                }
            } else {
                i++;
                chunks.push([]);

                if (preserve_keys) {
                    chunks[i][key] = val;
                    j++;
                } else {
                    j = 0;
                    chunks[i][j] = val;
                }
            }
        }

        return chunks;
    };
    /**
     * returns the values from a single column of the array-of-objects/arrays, identified by the column_key.
     * Optionally, you may provide an index_key to index the values in the returned array by the values from the index_key column in the input array.
     */
    module.exports.column = function (arr, field) {
        return Array.rfilter(arr, function (x) { return x ? x[field] : undefined; });
    };
    /**
     * Append any number of arrays into the first one
     *
     * @param {Array} dst
     * @returns {Array}
     */
    module.exports.combine = function (dst) {
        var i,
            j,
            ar;

        for (j = 1; j < arguments.length; ++j) {
            ar = arguments[j];

            for (i = 0; i < ar.length; ++i) {
                dst.push(ar[i]);
            }
        }
    };
    /**
     * Counts all the values of an array
     */
    module.exports.countValues = function (arr, ci) {
        ci = ci || false;
        var i,
            counter = {},
            val;

        for (i = 0; i < arr.length; ++i) {
            val = arr[i];
            if (ci && "string" === typeof val) {
                val = val.toLowerCase();
            }

            if (counter[val]) {
                ++counter[val];
            } else {
                counter[val] = 1;
            }
        }

        return counter;
    };
    /**
     * Returns a copy of the array padded to size specified by size with value value. If size is positive then the array is padded on the right, if it"s negative then on the left. If the absolute value of size is less than or equal to the length of the array then no padding takes place
     */
    module.exports.pad = function (arr, size, value) {
        if (Math.abs(size) <= arr.length) {
            return arr;
        }
        var out = [],
            i,
            len;

        if (size > 0) {
            for (i = 0;  i < size; ++i) {
                out[i] = i < arr.length ? arr[i] : value;
            }
        } else {
            size = Math.abs(size);
            len = size - arr.length;
            for (i = 0;  i < size; ++i) {
                out[i] = i < len ? value : arr[i - len];
            }
        }

        return out;
    };
    /**
     * Calculate the product of values in an array
     */
    module.exports.product = function (arr) {
        var sum = 1,
            len = arr.length,
            i;

        for (i = 0; i < len; i++) {
            sum *= parseFloat(arr[i]); // be sure it"s a number..
        }

        return sum;
    };
    /**
     * Picks one or more random entries out of an array, and returns the key (or keys) of the random entries.
     */
    module.exports.rand = function (arr, len) {
        var out = [],
            i;
        len = len || 1;

        for (i = 0; i < len; ++i) {
            out.push(Math.floor(Math.random() * arr.length));
        }

        return out;
    };

    module.exports.dense = function (arr) {
        var out = [];

        arr.forEach(function (val) {
            out.push(val);
        });

        return out;
    };

    module.exports.sum = function (arr) {
        var sum = 0,
            len = arr.length,
            i;

        for (i = 0; i < len; i++) {
            sum += parseFloat(arr[i]); // be sure it"s a number..
        }

        return sum;
    };

    /**
     * Fill an array with values
     */
    module.exports.fill = function (start, count, value) {
        var arr = [],
            len = start + count,
            i;

        for (i = start; i < len; ++i) {
            arr[i] = value;
        }

        return arr;
    };
    /**
     * Return the values from a single column in the input array
     */
    module.exports.column = function (arr, field) {
        return __rfilter(arr, function (x) { return x[field]; });
    };

    /**
     * returns an object with the same values keys given a property of the object
     * @throws if the field is undefined!
     */
    module.exports.kmap = function (arr, field) {
        var ret = {};

        arr.forEach(function (v) {
            if (!v[field]) {
                console.log(v);
                throw new Error("field not found in v");
            }

            ret[v[field]] = v;
        });

        return ret;
    };


    module.exports.oFilter = function (arr, obj) {
        if (!arr) return [];

        var res = [],
            i,
            f,
            j,
            max = arr.length;

        for (i = 0; i < max; ++i) {
            if (arr[i]) {
                f = true;
                for (j in obj) {
                    if (arr[i][j] !== obj[j]) {
                        f = false;
                    }
                }
                if (f) {
                    res.push(arr[i]);
                }
            }
        }

        return res;
    };

    /**
     * Returns the key of the object contained in the array that has the same value in given key.
     * @throws if the field is undefined!
     */
    module.exports.search = function (arr, key, value) {
        if (!arr || !arr.length) {
            return -1;
        }

        var i,
            max = arr.length;

        for (i = 0; i < max; ++i) {
            if (arr[i] && arr[i][key] == value) {
                return i;
            }
        }

        return -1;
    };


    module.exports.mapAsync = function (arr, callback, donecallback, thisArg) {
        if (!arr || !arr.length) {
            return donecallback();
        }

        var i,
            max = arr.length,
            done_count = 0,
            ret = [],
            done = function(value, key) {
                if (ret.length === 0 && key) {
                    ret = {};
                }

                // no first
                key = key || done_count;
                ret[key] = value;


                if (++done_count === max) {
                    donecallback(ret);
                }
            };

        for (i = 0; i < max; ++i) {
            if (thisArg) {
                callback.call(thisArg, arr[i], i, done);
            } else {
                callback(arr[i], i, done);
            }

        }
    };

    module.exports.mapSerial = function (arr, callback, donecallback, thisArg) {
        if (!arr || !arr.length) {
            return donecallback();
        }

        var i = 0,
            max = arr.length,
            ret = [],
            next = function(value, key) {
                // change ret to object if first call has key
                if (i === 1 && key) {
                    ret = {};
                }


                // no first
                if (i !== 0) {
                    key = key || i;
                    ret[key] = value;
                }

                var ci = i,
                    ct = arr[i];

                if (++i > max) {
                    return donecallback(ret);
                }

                if (thisArg) {
                    callback.call(thisArg, ct, ci, next, end);
                } else {
                    callback(ct, ci, next, end);
                }

            },
            end = function(value, key) {
                key = key || i;
                ret[key] = value;

                donecallback(ret);
            };

        next();
    };
}());
},{}],34:[function(require,module,exports){
(function () {
    "use strict";

    module.exports = require("./lib/objects.js");

}());
},{"./lib/objects.js":35}],35:[function(require,module,exports){
(function () {
    "use strict";

    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable("toString"),
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length,
        ArrayPush = Array.prototype.push,
        ObjectConstructor = Object.prototype.constructor,
        __typeof,
        __merge,
        __depth,
        __rfilter,
        __debug = true;

    module.exports["typeof"] = __typeof = function (val) {
        if (val === null || val === undefined) {
            return "null";
        }
        // dont deal with undefine...
        if (val === true || val === false) {
            return "boolean";
        }

        var type = typeof val;

        if (type === "object") {
            // for performance, we check if it"s a plain object first
            if (type.constructor === ObjectConstructor) {
                return type;
            }

            if (val.push === ArrayPush && val.length != null) { // != null is ok!
                return "array";
            }
            // for performance, I will keep this insecure
            // if (hasOwnProperty.call(val, "callee")) {
            if (val.hasOwnProperty && val.hasOwnProperty("callee")) {
                return "arguments";
            }
            if (val instanceof Date) {
                return "date";
            }
            if (val instanceof RegExp) {
                return "regexp";
            }

            // this is an instance of something?
        } else if (type === "number" && isNaN(val)) {
            return "null";
        }

        return type;
    };

    //
    // Object
    //

    // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
    if (!Object.keys) {
        Object.keys = function (obj) {
            if (typeof obj !== "object" && (typeof obj !== "function" || obj === null)) {
                throw new TypeError("Object.keys called on non-object");
            }

            var result = [], prop, i;

            for (prop in obj) {
                if (hasOwnProperty.call(obj, prop)) {
                    result.push(prop);
                }
            }

            if (hasDontEnumBug) {
                for (i = 0; i < dontEnumsLength; i++) {
                    if (hasOwnProperty.call(obj, dontEnums[i])) {
                        result.push(dontEnums[i]);
                    }
                }
            }
            return result;
        };
    }

    // define Object.defineProperty if not found, no functionality just a replacement so your code not throw!
    if (!Object.defineProperty) {
        Object.defineProperty = function (obj, name, prop) {
            if (prop.get || prop.set) {
                throw new Error("this is not supported in your js.engine");
            }
            obj[name] = prop.value;
        };
    }


    // define Object.seal if not found, no functionality just a replacement so your code not throw!
    if (!Object.seal) {
        Object.seal = function (obj) {
            return obj;
        };
    }

    module.exports.values = function (obj) {
        if (__debug) {
            if (typeof obj !== "object" && (typeof obj !== "function" || obj === null)) {
                throw new TypeError("Object.values called on non-object");
            }
        }

        var result = [],
            prop;

        for (prop in obj) {
            if (!__debug || hasOwnProperty.call(obj, prop)) {
                result.push(obj[prop]);
            }
        }

        return result;
    };


    /**
     * get the keys of an object (or anything iterable for...in) note: remove prototype key
     *
     * @param {Object} object
     * @param {Function} fn
     * @returns {Object} object
     */
    function __each(object, fn) {
        var key = null;

        for (key in object) {
            fn(object[key], key);
        }

        return object;
    }

    module.exports.each = __each;

    module.exports.forEach = __each;

    module.exports.clone = function (obj) {
        return __merge({}, obj, true, false);
    };

    /**
     * merge two object
     *
     *
     * @params {Object} to, this parameter is modified
     * @params {Object} from
     * @params {Boolean} clone
     * @params {Boolean} must_exists do not allow undefined in the objects
     */
    module.exports.merge = __merge = function (to, from, clone, must_exists) {
        //console.log("Object.merge", from);
        clone = clone || false;
        must_exists = must_exists || false;

        var ftype = __typeof(from),
            key,
            ret;

        switch (ftype) {
        case "string":
            return clone ? "" + from : from;
        case "number":
            return clone ? 0 + from : from;
        case "array": // maybe need more deep clone ?

            if (clone) {
                ret = [];
                for (key = 0; key < from.length; ++key) {
                    ret[key] = __merge(to[key] || {}, from[key], clone, must_exists);
                }

                return ret;
            }

            return from;
        case "boolean":
            return clone ? (from ? true : false) : from;
        case "null":
            return null;
        case "function":
            return from;
        case "object":
            // to it not an object, overwrite!
            ret = __typeof(to) !== "object" ? {} : to || {};
            // if has prototype just copy
            key = null;

            for (key in from) {
                if (key !== "prototype") {
                    if (ret[key] === undefined) {
                        if (must_exists) {
                            continue;
                        }
                        ret[key] = {};
                    }
                    ret[key] = __merge(ret[key] || {}, from[key], clone, must_exists);
                }
            }

            return ret;
        case "regexp":
            return new RegExp(from.source);
        case "date":
            return clone ? new Date(from) : from;
        }
        // unknown type... just return
        return from;
    };

    module.exports.combine = function (keys, values) {
        values = values || [];
        var i,
            ret = {};

        for (i = 0; i < keys.length; ++i) {
            ret[keys[i]] = values[i] === undefined ? null : values[i];
        }
        return ret;
    };

    module.exports.ksort = function (from) {
        var keys = Object.keys(from),
            i,
            ret = {};

        for (i = 0; i < keys.length; ++i) {
            ret[keys[i]] = from[keys[i]];
        }

        return ret;
    };

    module.exports.extend = function () {
        var target = arguments[0] || {},
            o,
            p,
            i,
            len;

        for (i = 1, len = arguments.length; i < len; i++) {
            o = arguments[i];

            if ("object" === typeof o && o !== null) {
                for (p in o) {
                    target[p] = o[p];
                }
            }
        }

        return target;
    };

    module.exports.extract = function (from, keys, default_value) {
        var i,
            ret = {};

        default_value = default_value === undefined ? null : default_value;

        for (i = 0; i < keys.length; ++i) {
            ret[keys[i]] = from[keys[i]] === undefined ? default_value : from[keys[i]];
        }

        return ret;
    };

    module.exports.empty = function (obj) {
        var name;
        for (name in obj) {
            return false;
        }
        return true;
    };

    module.exports.depth = __depth = function (obj) {
        var i,
            max,
            props = false,
            d = 0;

        if (obj === null || obj === undefined) {
            return 0;
        }

        if (Array.isArray(obj)) {
            // array

            for (i = 0, max = obj.length; i < max; ++i) {
                d = Math.max(d, __depth(obj[i]));
            }
            props = max > 0;
        } else if ("object" === typeof obj) {
            // object

            for (i in obj) {
                props = true;
                d = Math.max(d, __depth(obj[i]));
            }
        }

        return (props ? 1 : 0) + d;
    };

    module.exports.rFilter = __rfilter = function (obj, callback, loop_arrays) {
        var i,
            max;
        loop_arrays = loop_arrays === true;

        if (Array.isArray(obj)) {
            // array
            if (!loop_arrays) {
                obj = callback(obj);
            } else {
                for (i = 0, max = obj.length; i < max; ++i) {
                    obj[i] = __rfilter(obj[i], callback, loop_arrays);
                }
            }

            return obj;
        }

        if ("object" === typeof obj) {
            // object
            if (!(obj instanceof Date || obj instanceof RegExp)) {

                for (i in obj) {
                    obj[i] = __rfilter(obj[i], callback, loop_arrays);
                }
                return obj;
            }
        }

        return callback(obj);
    };

    module.exports.prefixKeys = function (obj, prefix, ignore_keys) {
        ignore_keys = ignore_keys || [];
        var i,
            ret = {};

        if (ignore_keys.length) {
            for (i in obj) {
                if (ignore_keys.indexOf(i) === -1) {
                    ret[prefix + i] = obj[i];
                } else {
                    ret[i] = obj[i];
                }
            }
        } else {
            for (i in obj) {
                ret[prefix + i] = obj[i];
            }
        }

        return ret;
    };

    module.exports.remPrefixKeys = function (obj, prefix, ignore_keys) {
        ignore_keys = ignore_keys || [];
        var i,
            prefix_len = prefix.length,
            ret = {};

        if (ignore_keys.length) {
            for (i in obj) {
                if (ignore_keys.indexOf(i) === -1) {
                    if (i.indexOf(prefix) === 0) {
                        ret[i.substring(prefix_len)] = obj[i];
                    } else {
                        ret[i] = obj[i];
                    }
                } else {
                    ret[i] = obj[i];
                }
            }
        } else {
            for (i in obj) {
                if (i.indexOf(prefix) === 0) {
                    ret[i.substring(prefix_len)] = obj[i];
                } else {
                    ret[i] = obj[i];
                }
            }
        }

        return ret;
    };


    module.exports.diff = function (obj) {
        var ret = {},
            argl = arguments.length,
            k1,
            i,
            found;

        for (k1 in obj) {
            found = false;
            for (i = 1; i < argl && !found; ++i) {
                if (obj[k1] === arguments[i][k1]) {
                    found  = true;
                }
            }

            if (!found) {
                ret[k1] = obj[k1];
            }

        }

        return ret;

    };

}());
},{}]},{},[])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ub2JveG91dC9qcy0yZG1hdGgvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvaW5kZXguanMiLCIvbm9ib3hvdXQvanMtMmRtYXRoL2xpYi9hYWJiMi5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL2JlaXplci5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL2NpcmNsZS5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL2NvbGxpZGUuanMiLCIvbm9ib3hvdXQvanMtMmRtYXRoL2xpYi9jb2xsaXNpb24vZXBhLmpzIiwiL25vYm94b3V0L2pzLTJkbWF0aC9saWIvY29sbGlzaW9uL2dqay5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL2NvbGxpc2lvbi9tYW5pZm9sZC5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL2NvbGxpc2lvbi9yZXNvbHZlLmpzIiwiL25vYm94b3V0L2pzLTJkbWF0aC9saWIvY29sbGlzaW9uL3Jlc3BvbnNlLmpzIiwiL25vYm94b3V0L2pzLTJkbWF0aC9saWIvY29sbGlzaW9uL3NhdC5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL2Rpc3RhbmNlLmpzIiwiL25vYm94b3V0L2pzLTJkbWF0aC9saWIvZHJhdy5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL2ludGVyc2VjdGlvbi5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL2xpbmUyLmpzIiwiL25vYm94b3V0L2pzLTJkbWF0aC9saWIvbWF0aC5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL21hdHJpeDIyLmpzIiwiL25vYm94b3V0L2pzLTJkbWF0aC9saWIvbWF0cml4MjMuanMiLCIvbm9ib3hvdXQvanMtMmRtYXRoL2xpYi9ubXRyZWUuanMiLCIvbm9ib3hvdXQvanMtMmRtYXRoL2xpYi9ub2lzZS5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL251bWVyaWNhbC1pbnRlZ3JhdGlvbi9ldWxlci5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL251bWVyaWNhbC1pbnRlZ3JhdGlvbi9yazQuanMiLCIvbm9ib3hvdXQvanMtMmRtYXRoL2xpYi9udW1lcmljYWwtaW50ZWdyYXRpb24vdmVybGV0LmpzIiwiL25vYm94b3V0L2pzLTJkbWF0aC9saWIvcG9seWdvbi5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL3JlY3RhbmdsZS5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL3NlZ21lbnQyLmpzIiwiL25vYm94b3V0L2pzLTJkbWF0aC9saWIvdHJhbnNpdGlvbnMuanMiLCIvbm9ib3hvdXQvanMtMmRtYXRoL2xpYi90cmlhbmdsZS5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbGliL3ZlYzIuanMiLCIvbm9ib3hvdXQvanMtMmRtYXRoL2xpYi94b3JzaGlmdC5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbm9kZV9tb2R1bGVzL2FycmF5LWVuaGFuY2VtZW50cy9pbmRleC5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbm9kZV9tb2R1bGVzL2FycmF5LWVuaGFuY2VtZW50cy9saWIvYXJyYXlzLmpzIiwiL25vYm94b3V0L2pzLTJkbWF0aC9ub2RlX21vZHVsZXMvb2JqZWN0LWVuaGFuY2VtZW50cy9pbmRleC5qcyIsIi9ub2JveG91dC9qcy0yZG1hdGgvbm9kZV9tb2R1bGVzL29iamVjdC1lbmhhbmNlbWVudHMvbGliL29iamVjdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9lQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwicmVxdWlyZShcIi4vbGliL21hdGguanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFZlYzI6IHJlcXVpcmUoXCIuL2xpYi92ZWMyLmpzXCIpLFxuICAgIExpbmUyOiByZXF1aXJlKFwiLi9saWIvbGluZTIuanNcIiksXG4gICAgU2VnbWVudDI6IHJlcXVpcmUoXCIuL2xpYi9zZWdtZW50Mi5qc1wiKSxcbiAgICAvL2dlb21cbiAgICBSZWN0YW5nbGU6IHJlcXVpcmUoXCIuL2xpYi9yZWN0YW5nbGUuanNcIiksXG4gICAgQUFCQjI6IHJlcXVpcmUoXCIuL2xpYi9hYWJiMi5qc1wiKSxcbiAgICBDaXJjbGU6IHJlcXVpcmUoXCIuL2xpYi9jaXJjbGUuanNcIiksXG4gICAgVHJpYW5nbGU6IHJlcXVpcmUoXCIuL2xpYi90cmlhbmdsZS5qc1wiKSxcbiAgICBQb2x5Z29uOiByZXF1aXJlKFwiLi9saWIvcG9seWdvbi5qc1wiKSxcblxuICAgIEJlaXplcjogcmVxdWlyZShcIi4vbGliL2JlaXplci5qc1wiKSxcbiAgICBNYXRyaXgyMzogcmVxdWlyZShcIi4vbGliL21hdHJpeDIzLmpzXCIpLFxuICAgIE1hdHJpeDIyOiByZXF1aXJlKFwiLi9saWIvbWF0cml4MjIuanNcIiksXG4gICAgQ29sbGlkZTogcmVxdWlyZShcIi4vbGliL2NvbGxpZGUuanNcIiksXG4gICAgSW50ZXJzZWN0aW9uOiByZXF1aXJlKFwiLi9saWIvaW50ZXJzZWN0aW9uLmpzXCIpLFxuICAgIFRyYW5zaXRpb25zOiByZXF1aXJlKFwiLi9saWIvdHJhbnNpdGlvbnMuanNcIiksXG4gICAgWG9yc2hpZnQ6IHJlcXVpcmUoXCIuL2xpYi94b3JzaGlmdC5qc1wiKSxcbiAgICBOb2lzZTogcmVxdWlyZShcIi4vbGliL25vaXNlLmpzXCIpLFxuICAgIERyYXc6IHJlcXVpcmUoXCIuL2xpYi9kcmF3LmpzXCIpLFxuXG4gICAgTk10cmVlOiByZXF1aXJlKFwiLi9saWIvbm10cmVlLmpzXCIpLFxuXG4gICAgQ29sbGlzaW9uIDoge1xuICAgICAgICBSZXNwb25zZTogcmVxdWlyZShcIi4vbGliL2NvbGxpc2lvbi9yZXNwb25zZS5qc1wiKSxcbiAgICAgICAgR0pLOiByZXF1aXJlKFwiLi9saWIvY29sbGlzaW9uL2dqay5qc1wiKSxcbiAgICAgICAgRVBBOiByZXF1aXJlKFwiLi9saWIvY29sbGlzaW9uL2VwYS5qc1wiKSxcbiAgICAgICAgTWFuaWZvbGQ6IHJlcXVpcmUoXCIuL2xpYi9jb2xsaXNpb24vbWFuaWZvbGQuanNcIiksXG4gICAgICAgIFNBVDogcmVxdWlyZShcIi4vbGliL2NvbGxpc2lvbi9zYXQuanNcIiksXG4gICAgICAgIFJlc29sdmU6IHJlcXVpcmUoXCIuL2xpYi9jb2xsaXNpb24vcmVzb2x2ZS5qc1wiKVxuICAgIH0sXG5cbiAgICBOdW1lcmljYWxJbnRlZ3JhdGlvbjoge1xuICAgICAgICBSSzQ6IHJlcXVpcmUoXCIuL2xpYi9udW1lcmljYWwtaW50ZWdyYXRpb24vcms0LmpzXCIpLFxuICAgICAgICBWZXJsZXQ6IHJlcXVpcmUoXCIuL2xpYi9udW1lcmljYWwtaW50ZWdyYXRpb24vdmVybGV0LmpzXCIpLFxuICAgICAgICBFdWxlcjogcmVxdWlyZShcIi4vbGliL251bWVyaWNhbC1pbnRlZ3JhdGlvbi9ldWxlci5qc1wiKVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmdsb2JhbGl6ZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgaW4gbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgaWYgKFwiZ2xvYmFsaXplXCIgIT09IGkpIHtcbiAgICAgICAgICAgIG9iamVjdFtpXSA9IG1vZHVsZS5leHBvcnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiLyoqXG4gKiBTdGFiaWxpdHk6IDEgKE9ubHkgYWRkaXRpb25zICYgZml4ZXMpXG4gKlxuICogQm91bmRpbmdCb3gyIGlzIHJlcHJlc2VudGVkIGFzIGEgNSBjb29yZGluYXRlcyBhcnJheVxuICogW2xlZnQ6IE51bWJlciwgYm90dG9tOiBOdW1iZXIsIHJpZ2h0OiBOdW1iZXIsIHRvcDogTnVtYmVyLCBub3JtYWxpemVkOiBCb29sZWFuXVxuICovXG5cbnZhciBtaW4gPSBNYXRoLm1pbixcbiAgICBtYXggPSBNYXRoLm1heCxcbiAgICBUT1BMRUZUID0gMSxcbiAgICBUT1BNSURETEUgPSAyLFxuICAgIFRPUFJJR0hUID0gMyxcblxuICAgIENFTlRFUkxFRlQgPSA0LFxuICAgIENFTlRFUiA9IDUsXG4gICAgQ0VOVEVSUklHSFQgPSA2LFxuXG4gICAgQk9UVE9NTEVGVCA9IDcsXG4gICAgQk9UVE9NID0gOCxcbiAgICBCT1RUT01SSUdIVCA9IDksXG5cbiAgICByID0gMCxcbiAgICB4ID0gMCxcbiAgICB5ID0gMCxcblxuICAgIG1pbl94ID0gMCxcbiAgICBtYXhfeCA9IDAsXG4gICAgbWluX3kgPSAwLFxuICAgIG1heF95ID0gMDtcblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gbFxuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7QUFCQjJ9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShsLCBiLCByLCB0KSB7XG5pZiAobCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGwpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImwgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocikgfHwgJ251bWJlcicgIT09IHR5cGVvZiByKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiciBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAodCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHQpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInQgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHZhciBvdXQgPSBbbCwgYiwgciwgdCwgZmFsc2VdO1xuICAgIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQHBhcmFtIHtBQUJCMn0gYWFiYjJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7QXJyYXk8QUFCQjI+fVxuICovXG5mdW5jdGlvbiBmcm9tQUFCQjJEaXZpc2lvbihhYWJiMiwgeCwgeSkge1xuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyKSB8fCBhYWJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzBdIHx8IGFhYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMV0gfHwgYWFiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlsyXSB8fCBhYWJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBhYWJiMlwiKVxufVxuXG5pZiAoeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIGwgPSBhYWJiMlswXSxcbiAgICAgICAgYiA9IGFhYmIyWzFdLFxuICAgICAgICByID0gYWFiYjJbMl0sXG4gICAgICAgIHQgPSBhYWJiMlszXSxcbiAgICAgICAgdyA9IChyIC0gbCkgLyB4LFxuICAgICAgICBoID0gKHQgLSBiKSAvIHk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgeDsgKytpKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB5OyArK2opIHtcbiAgICAgICAgICAgIG91dC5wdXNoKFtsICsgaSAqIHcsIGIgKyBqICogaCwgbCArIChpICsgMSkgKiB3LCBiICsgKGogKyAxKSAqIGhdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEByZXR1cm4ge0FBQkIyfVxuICovXG5mdW5jdGlvbiBmcm9tU2VnbWVudDIoc2VnMikge1xuICAgIHZhciBvdXQgPSBbc2VnMlswXSwgc2VnMlsxXSwgc2VnMlsyXSwgc2VnMlszXSwgZmFsc2VdO1xuICAgIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQHBhcmFtIHtDaXJjbGV9IGNpcmNsZVxuICogQHJldHVybiB7QUFCQjJ9XG4gKi9cbmZ1bmN0aW9uIGZyb21DaXJjbGUoY2lyY2xlKSB7XG4gICAgciA9IGNpcmNsZVsxXTtcbiAgICB4ID0gY2lyY2xlWzBdWzBdO1xuICAgIHkgPSBjaXJjbGVbMF1bMV07XG4gICAgcmV0dXJuIGNyZWF0ZShcbiAgICAgICAgeCAtIHIsXG4gICAgICAgIHkgLSByLFxuICAgICAgICB4ICsgcixcbiAgICAgICAgeSArIHJcbiAgICApO1xufVxuLyoqXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdFxuICogQHJldHVybiB7QUFCQjJ9XG4gKi9cbmZ1bmN0aW9uIGZyb21SZWN0YW5nbGUocmVjdCkge1xuaWYgKCFBcnJheS5pc0FycmF5KHJlY3QpIHx8IHJlY3RbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMF0gfHwgcmVjdFswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVsxXSB8fCByZWN0WzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzBdIHx8IHJlY3RbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSByZWN0XCIpXG59XG5cbiAgICB2YXIgb3V0ID0gW3JlY3RbMF1bMF0sIHJlY3RbMF1bMV0sIHJlY3RbMV1bMF0sIHJlY3RbMV1bMV0sIGZhbHNlXTtcbiAgICBub3JtYWxpemUob3V0LCBvdXQpO1xuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEB0b2RvIGltcGxlbWVudCBhIG1vcmUgcm9idXN0IC8gZmFzdCBhbGdvcml0aG0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTg3NzUxL2FuLWFsZ29yaXRobS10by1maW5kLWJvdW5kaW5nLWJveC1vZi1jbG9zZWQtYmV6aWVyLWN1cnZlcyAoVGltbyBhbnN3ZXIpXG4gKlxuICogQHJlZmVyZW5jZSBodHRwOi8vanNmaWRkbGUubmV0LzRWQ1ZYLzMvXG4gKlxuICogQHBhcmFtIHtCZWl6ZXJ9IGJlaXplclxuICogQHBhcmFtIHtOdW1iZXJ9IG5wb2ludHNcbiAqIEByZXR1cm4ge0FBQkIyfVxuICovXG5mdW5jdGlvbiBmcm9tQmVpemVyKGJlaXplciwgbnBvaW50cykge1xuaWYgKG5wb2ludHMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihucG9pbnRzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG5wb2ludHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJucG9pbnRzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBucG9pbnRzID0gbnBvaW50cyB8fCA0MDtcbiAgICB2YXIgdmVjMl9saXN0ID0gQmVpemVyLmdldChiZWl6ZXIsIG5wb2ludHMpLFxuICAgICAgICBpLFxuICAgICAgICBsID0gSW5maW5pdHksXG4gICAgICAgIGIgPSBJbmZpbml0eSxcbiAgICAgICAgciA9IC1JbmZpbml0eSxcbiAgICAgICAgdCA9IC1JbmZpbml0eSxcbiAgICAgICAgdixcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIC8vIGxvb3AgbWluLCBtYXhcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnBvaW50czsgKytpKSB7XG4gICAgICAgIHYgPSB2ZWMyX2xpc3RbaV07XG5cbiAgICAgICAgeCA9IHZbMF07XG4gICAgICAgIHkgPSB2WzFdO1xuXG4gICAgICAgIGlmICh4ID4gcikge1xuICAgICAgICAgICAgciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA8IGwpIHtcbiAgICAgICAgICAgIGwgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPCBiKSB7XG4gICAgICAgICAgICBiID0geTtcbiAgICAgICAgfSBlbHNlIGlmICh5ID4gdCkge1xuICAgICAgICAgICAgdCA9IHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2wsIGIsIHIsIHQsIHRydWVdO1xuXG59XG5cbi8qKlxuICogQHJldHVybiB7QUFCQjJ9XG4gKi9cbmZ1bmN0aW9uIHplcm8oKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwLCAwLCB0cnVlXTtcbn1cbi8qKlxuICogQHBhcmFtIHtBQUJCMn0gYWFiYjJcbiAqIEByZXR1cm4ge0FBQkIyfVxuICovXG5mdW5jdGlvbiBjbG9uZShhYWJiMikge1xuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyKSB8fCBhYWJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzBdIHx8IGFhYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMV0gfHwgYWFiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlsyXSB8fCBhYWJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBhYWJiMlwiKVxufVxuXG4gICAgcmV0dXJuIFthYWJiMlswXSwgYWFiYjJbMV0sIGFhYmIyWzJdLCBhYWJiMlszXSwgYWFiYjJbNF1dO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FBQkIyfSBvdXRcbiAqIEBwYXJhbSB7QUFCQjJ9IGFhYmIyXG4gKiBAcmV0dXJuIHtBQUJCMn1cbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGFhYmIyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyKSB8fCBhYWJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzBdIHx8IGFhYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMV0gfHwgYWFiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlsyXSB8fCBhYWJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBhYWJiMlwiKVxufVxuXG4gICAgb3V0WzBdID0gYWFiYjJbMF07XG4gICAgb3V0WzFdID0gYWFiYjJbMV07XG4gICAgb3V0WzJdID0gYWFiYjJbMl07XG4gICAgb3V0WzNdID0gYWFiYjJbM107XG4gICAgb3V0WzRdID0gYWFiYjJbNF07XG5cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAcGFyYW0ge0FBQkIyfSBvdXRcbiAqIEBwYXJhbSB7QUFCQjJ9IGFhYmIyXG4gKiBAcGFyYW0ge051bWJlcn0gbWFyZ2luXG4gKiBAcmV0dXJuIHtBQUJCMn1cbiAqL1xuZnVuY3Rpb24gZXhwYW5kKG91dCwgYWFiYjIsIG1hcmdpbikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShhYWJiMikgfHwgYWFiYjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlswXSB8fCBhYWJiMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzFdIHx8IGFhYmIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMl0gfHwgYWFiYjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJcIilcbn1cblxuaWYgKG1hcmdpbiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hcmdpbikgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXJnaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXJnaW4gaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIG91dFswXSA9IGFhYmIyWzBdIC0gbWFyZ2luO1xuICAgIG91dFsxXSA9IGFhYmIyWzFdIC0gbWFyZ2luO1xuICAgIG91dFsyXSA9IGFhYmIyWzJdICsgbWFyZ2luO1xuICAgIG91dFszXSA9IGFhYmIyWzNdICsgbWFyZ2luO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQHBhcmFtIHtBQUJCMn0gb3V0XG4gKiBAcGFyYW0ge0FBQkIyfSBhYWJiMl8xXG4gKiBAcGFyYW0ge0FBQkIyfSBhYWJiMl8yXG4gKiBAcmV0dXJuIHtBQUJCMn1cbiAqL1xuZnVuY3Rpb24gbWVyZ2Uob3V0LCBhYWJiMl8xLCBhYWJiMl8yKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyXzEpIHx8IGFhYmIyXzFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMl8xWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyXzFbMF0gfHwgYWFiYjJfMVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMVsxXSB8fCBhYWJiMl8xWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJfMVsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMl8xWzJdIHx8IGFhYmIyXzFbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMl8xWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyXzFbM10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFBQkIyIGFhYmIyXzFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyXzIpIHx8IGFhYmIyXzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMl8yWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyXzJbMF0gfHwgYWFiYjJfMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMlsxXSB8fCBhYWJiMl8yWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJfMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMl8yWzJdIHx8IGFhYmIyXzJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMl8yWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyXzJbM10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFBQkIyIGFhYmIyXzJcIilcbn1cblxuICAgIG91dFswXSA9IG1pbihhYWJiMl8xWzBdLCBhYWJiMl8yWzBdKTtcbiAgICBvdXRbMV0gPSBtaW4oYWFiYjJfMVsxXSwgYWFiYjJfMlsxXSk7XG4gICAgb3V0WzJdID0gbWF4KGFhYmIyXzFbMl0sIGFhYmIyXzJbMl0pO1xuICAgIG91dFszXSA9IG1heChhYWJiMl8xWzNdLCBhYWJiMl8yWzNdKTtcblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7QUFCQjJ9IG91dFxuICogQHBhcmFtIHtBQUJCMn0gYWFiYjJfMVxuICogQHBhcmFtIHtBQUJCMn0gYWFiYjJfMlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyX29mZnNldFxuICogQHJldHVybiB7QUFCQjJ9XG4gKi9cbmZ1bmN0aW9uIG9mZnNldE1lcmdlKG91dCwgYWFiYjJfMSwgYWFiYjJfMiwgdmVjMl9vZmZzZXQpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF0gfHwgb3V0WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsxXSB8fCBvdXRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzJdIHx8IG91dFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbM10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFBQkIyIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkoYWFiYjJfMSkgfHwgYWFiYjJfMVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMVswXSB8fCBhYWJiMl8xWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJfMVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMl8xWzFdIHx8IGFhYmIyXzFbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMl8xWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyXzFbMl0gfHwgYWFiYjJfMVszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzFbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMVszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJfMVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkoYWFiYjJfMikgfHwgYWFiYjJfMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMlswXSB8fCBhYWJiMl8yWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJfMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMl8yWzFdIHx8IGFhYmIyXzJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMl8yWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyXzJbMl0gfHwgYWFiYjJfMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzJbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJfMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMl9vZmZzZXQpIHx8IHZlYzJfb2Zmc2V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMl9vZmZzZXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMl9vZmZzZXRbMF0gfHwgdmVjMl9vZmZzZXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyX29mZnNldFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyX29mZnNldFsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyX29mZnNldFwiKVxufVxuXG4gICAgb3V0WzBdID0gbWluKGFhYmIyXzFbMF0sIGFhYmIyXzJbMF0gKyB2ZWMyX29mZnNldFswXSk7XG4gICAgb3V0WzFdID0gbWluKGFhYmIyXzFbMV0sIGFhYmIyXzJbMV0gKyB2ZWMyX29mZnNldFsxXSk7XG4gICAgb3V0WzJdID0gbWF4KGFhYmIyXzFbMl0sIGFhYmIyXzJbMl0gKyB2ZWMyX29mZnNldFswXSk7XG4gICAgb3V0WzNdID0gbWF4KGFhYmIyXzFbM10sIGFhYmIyXzJbM10gKyB2ZWMyX29mZnNldFsxXSk7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBvZmZzZXQgJiBzY2FsZSBtZXJnZVxuICogQHBhcmFtIHtBQUJCMn0gb3V0XG4gKiBAcGFyYW0ge0FBQkIyfSBhYWJiMl8xXG4gKiBAcGFyYW0ge0FBQkIyfSBhYWJiMl8yXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJfb2Zmc2V0XG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJfc2NhbGVcbiAqIEByZXR1cm4ge0FBQkIyfVxuICovXG5mdW5jdGlvbiBvc01lcmdlKG91dCwgYWFiYjJfMSwgYWFiYjJfMiwgdmVjMl9vZmZzZXQsIHZlYzJfc2NhbGUpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF0gfHwgb3V0WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsxXSB8fCBvdXRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzJdIHx8IG91dFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbM10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFBQkIyIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkoYWFiYjJfMSkgfHwgYWFiYjJfMVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMVswXSB8fCBhYWJiMl8xWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJfMVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMl8xWzFdIHx8IGFhYmIyXzFbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMl8xWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyXzFbMl0gfHwgYWFiYjJfMVszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzFbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMVszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJfMVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkoYWFiYjJfMikgfHwgYWFiYjJfMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMlswXSB8fCBhYWJiMl8yWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJfMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMl8yWzFdIHx8IGFhYmIyXzJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMl8yWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyXzJbMl0gfHwgYWFiYjJfMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzJbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJfMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMl9vZmZzZXQpIHx8IHZlYzJfb2Zmc2V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMl9vZmZzZXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMl9vZmZzZXRbMF0gfHwgdmVjMl9vZmZzZXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyX29mZnNldFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyX29mZnNldFsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyX29mZnNldFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMl9zY2FsZSkgfHwgdmVjMl9zY2FsZVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJfc2NhbGVbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMl9zY2FsZVswXSB8fCB2ZWMyX3NjYWxlWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMl9zY2FsZVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyX3NjYWxlWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJfc2NhbGVcIilcbn1cblxuICAgIG91dFswXSA9IG1pbihhYWJiMl8xWzBdLCAoYWFiYjJfMlswXSAqIHZlYzJfc2NhbGVbMF0pICsgdmVjMl9vZmZzZXRbMF0pO1xuICAgIG91dFsxXSA9IG1pbihhYWJiMl8xWzFdLCAoYWFiYjJfMlsxXSAqIHZlYzJfc2NhbGVbMV0pICsgdmVjMl9vZmZzZXRbMV0pO1xuICAgIG91dFsyXSA9IG1heChhYWJiMl8xWzJdLCAoYWFiYjJfMlsyXSAqIHZlYzJfc2NhbGVbMF0pICsgdmVjMl9vZmZzZXRbMF0pO1xuICAgIG91dFszXSA9IG1heChhYWJiMl8xWzNdLCAoYWFiYjJfMlszXSAqIHZlYzJfc2NhbGVbMV0pICsgdmVjMl9vZmZzZXRbMV0pO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogb2Zmc2V0ICYgc2NhbGUgbWVyZ2VcbiAqIEBwYXJhbSB7QUFCQjJ9IGFhYmIyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGFyZWEoYWFiYjIpIHtcbmlmICghQXJyYXkuaXNBcnJheShhYWJiMikgfHwgYWFiYjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlswXSB8fCBhYWJiMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzFdIHx8IGFhYmIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMl0gfHwgYWFiYjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJcIilcbn1cblxuICAgIHJldHVybiAoYWFiYjJbMl0gLSBhYWJiMlswXSkgKiAoYWFiYjJbM10gLSBhYWJiMlsxXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7QUFCQjJ9IG91dFxuICogQHBhcmFtIHtBQUJCMn0gYWFiYjJcbiAqIEByZXR1cm4ge0FBQkIyfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhYWJiMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShhYWJiMikgfHwgYWFiYjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlswXSB8fCBhYWJiMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzFdIHx8IGFhYmIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMl0gfHwgYWFiYjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJcIilcbn1cblxuICAgIG1pbl94ID0gYWFiYjJbMF0gPiBhYWJiMlsyXSA/IGFhYmIyWzJdIDogYWFiYjJbMF07XG4gICAgbWF4X3ggPSBhYWJiMlswXSA+IGFhYmIyWzJdID8gYWFiYjJbMF0gOiBhYWJiMlsyXTtcbiAgICBtaW5feSA9IGFhYmIyWzFdID4gYWFiYjJbM10gPyBhYWJiMlszXSA6IGFhYmIyWzFdO1xuICAgIG1heF95ID0gYWFiYjJbMV0gPiBhYWJiMlszXSA/IGFhYmIyWzFdIDogYWFiYjJbM107XG5cbiAgICBvdXRbMF0gPSBtaW5feDtcbiAgICBvdXRbMV0gPSBtaW5feTtcblxuICAgIG91dFsyXSA9IG1heF94O1xuICAgIG91dFszXSA9IG1heF95O1xuXG4gICAgb3V0WzRdID0gdHJ1ZTtcblxufVxuLyoqXG4gKiBAcGFyYW0ge0FBQkIyfSBvdXRcbiAqIEBwYXJhbSB7QUFCQjJ9IGFhYmIyXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEByZXR1cm4ge0FBQkIyfVxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhYWJiMiwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShhYWJiMikgfHwgYWFiYjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlswXSB8fCBhYWJiMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzFdIHx8IGFhYmIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMl0gfHwgYWFiYjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICB4ID0gdmVjMlswXTtcbiAgICB5ID0gdmVjMlsxXTtcblxuICAgIG91dFswXSA9IGFhYmIyWzBdICsgeDtcbiAgICBvdXRbMV0gPSBhYWJiMlsxXSArIHk7XG4gICAgb3V0WzJdID0gYWFiYjJbMl0gKyB4O1xuICAgIG91dFszXSA9IGFhYmIyWzNdICsgeTtcblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7QUFCQjJ9IGFhYmIyXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIGNsYW1wVmVjKG91dF92ZWMyLCBhYWJiMiwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyKSB8fCBhYWJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzBdIHx8IGFhYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMV0gfHwgYWFiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlsyXSB8fCBhYWJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBhYWJiMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gbWluKG1heChhYWJiMlswXSwgdmVjMlswXSksIGFhYmIyWzJdKTtcbiAgICBvdXRfdmVjMlsxXSA9IG1pbihtYXgoYWFiYjJbMV0sIHZlYzJbMV0pLCBhYWJiMlszXSk7XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7QUFCQjJ9IGFhYmIyXG4gKi9cbmZ1bmN0aW9uIGNlbnRlcihvdXRfdmVjMiwgYWFiYjIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShhYWJiMikgfHwgYWFiYjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlswXSB8fCBhYWJiMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzFdIHx8IGFhYmIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMl0gfHwgYWFiYjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gKGFhYmIyWzBdICsgYWFiYjJbMV0pICogMC41O1xuICAgIG91dF92ZWMyWzFdID0gKGFhYmIyWzNdICsgYWFiYjJbMl0pICogMC41O1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuXG4vKipcbiAqIGFsaWdubWVudCB2YWx1ZXM6IEFBQkIyLlRPUExFRlQsIEFBQkIyLlRPUE1JRERMRSwgQUFCQjIuVE9QUklHSFQsIEFBQkIyLkNFTlRFUkxFRlQsIEFBQkIyLkNFTlRFUiwgQUFCQjIuQ0VOVEVSUklHSFQsIEFBQkIyLkJPVFRPTUxFRlQsIEFBQkIyLkJPVFRPTSwgQUFCQjIuQk9UVE9NUklHSFxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7QUFCQjJ9IGFhYmIyXG4gKiBAcGFyYW0ge051bWJlcn0gYWxpZ25tZW50XG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBhbGlnbihvdXRfdmVjMiwgYWFiYjIsIGFsaWdubWVudCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyKSB8fCBhYWJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzBdIHx8IGFhYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMV0gfHwgYWFiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlsyXSB8fCBhYWJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBhYWJiMlwiKVxufVxuXG5pZiAoYWxpZ25tZW50ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWxpZ25tZW50KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFsaWdubWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFsaWdubWVudCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcbiAgICBjYXNlIFRPUExFRlQ6XG4gICAgICAgIC8vIGRvIG5vdGhpbmchXG4gICAgICAgIG91dF92ZWMyWzBdID0gYWFiYjJbMF07XG4gICAgICAgIG91dF92ZWMyWzFdID0gYWFiYjJbMV07XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgVE9QTUlERExFOlxuICAgICAgICBvdXRfdmVjMlswXSA9IChhYWJiMlsyXSAtIGFhYmIyWzBdKSAqIDAuNSArIGFhYmIyWzBdO1xuICAgICAgICBvdXRfdmVjMlsxXSA9IGFhYmIyWzFdO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFRPUFJJR0hUOlxuICAgICAgICBvdXRfdmVjMlswXSA9IGFhYmIyWzJdO1xuICAgICAgICBvdXRfdmVjMlsxXSA9IGFhYmIyWzFdO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgQ0VOVEVSTEVGVDpcbiAgICAgICAgb3V0X3ZlYzJbMF0gPSBhYWJiMlswXTtcbiAgICAgICAgb3V0X3ZlYzJbMV0gPSAoYWFiYjJbM10gLSBhYWJiMlsxXSkgKiAwLjUgKyBhYWJiMlsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBDRU5URVI6XG4gICAgICAgIG91dF92ZWMyWzBdID0gKGFhYmIyWzJdIC0gYWFiYjJbMF0pICogMC41ICsgYWFiYjJbMF07XG4gICAgICAgIG91dF92ZWMyWzFdID0gKGFhYmIyWzNdIC0gYWFiYjJbMV0pICogMC41ICsgYWFiYjJbMV07XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ0VOVEVSUklHSFQ6XG4gICAgICAgIG91dF92ZWMyWzBdID0gYWFiYjJbMl07XG4gICAgICAgIG91dF92ZWMyWzFdID0gKGFhYmIyWzNdIC0gYWFiYjJbMV0pICogMC41ICsgYWFiYjJbMV07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBCT1RUT01MRUZUOlxuICAgICAgICBvdXRfdmVjMlswXSA9IGFhYmIyWzBdO1xuICAgICAgICBvdXRfdmVjMlsxXSA9IGFhYmIyWzNdO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIEJPVFRPTTpcbiAgICAgICAgb3V0X3ZlYzJbMF0gPSAoYWFiYjJbMl0gLSBhYWJiMlswXSkgKiAwLjUgKyBhYWJiMlswXTtcbiAgICAgICAgb3V0X3ZlYzJbMV0gPSBhYWJiMlszXTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBCT1RUT01SSUdIVDpcbiAgICAgICAgb3V0X3ZlYzJbMF0gPSBhYWJiMlsyXTtcbiAgICAgICAgb3V0X3ZlYzJbMV0gPSBhYWJiMlszXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FBQkIyfSBhYWJiMlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZlYzJJbnNpZGUoYWFiYjIsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShhYWJiMikgfHwgYWFiYjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlswXSB8fCBhYWJiMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzFdIHx8IGFhYmIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMl0gfHwgYWFiYjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICByZXR1cm4gYWFiYjJbMF0gPCB2ZWMyWzBdICYmIGFhYmIyWzJdID4gdmVjMlswXSAmJiBhYWJiMlsxXSA8IHZlYzJbMV0gJiYgYWFiYjJbM10gPiB2ZWMyWzFdO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FBQkIyfSBhYWJiMlxuICogQHBhcmFtIHtBQUJCMn0gYWFiYjJfMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNBQUJCMkluc2lkZShhYWJiMiwgYWFiYjJfMikge1xuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyKSB8fCBhYWJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzBdIHx8IGFhYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMV0gfHwgYWFiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlsyXSB8fCBhYWJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBhYWJiMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkoYWFiYjJfMikgfHwgYWFiYjJfMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMlswXSB8fCBhYWJiMl8yWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJfMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMl8yWzFdIHx8IGFhYmIyXzJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMl8yWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyXzJbMl0gfHwgYWFiYjJfMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyXzJbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJfMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJfMlwiKVxufVxuXG4gICAgcmV0dXJuIGFhYmIyWzBdIDw9IGFhYmIyXzJbMF0gJiZcbiAgICAgICAgYWFiYjJbMV0gPD0gYWFiYjJfMlsxXSAmJlxuICAgICAgICBhYWJiMl8yWzJdIDw9IGFhYmIyWzJdICYmXG4gICAgICAgIGFhYmIyXzJbM10gPD0gYWFiYjJbM107XG59XG4vKipcbiAqIEBwYXJhbSB7QUFCQjJ9IGFhYmIyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHBlcmltZXRlcihhYWJiMikge1xuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyKSB8fCBhYWJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzBdIHx8IGFhYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMV0gfHwgYWFiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlsyXSB8fCBhYWJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBhYWJiMlwiKVxufVxuXG4gICAgcmV0dXJuIChhYWJiMlsyXSAtIGFhYmIyWzBdKSAqIDIgKyAoYWFiYjJbM10gLSBhYWJiMlsxXSkgKiAyO1xufVxuXG4vKipcbiAqIEBjbGFzcyBBQUJCMlxuICovXG52YXIgQUFCQjIgPSAge1xuICAgIC8vIGRlZmluZXNcbiAgICBUT1BMRUZUOiBUT1BMRUZULFxuICAgIFRPUE1JRERMRTogVE9QTUlERExFLFxuICAgIFRPUFJJR0hUOiBUT1BSSUdIVCxcbiAgICBDRU5URVJMRUZUOiBDRU5URVJMRUZULFxuICAgIENFTlRFUjogQ0VOVEVSLFxuICAgIENFTlRFUlJJR0hUOiBDRU5URVJSSUdIVCxcbiAgICBCT1RUT01MRUZUOiBCT1RUT01MRUZULFxuICAgIEJPVFRPTTogQk9UVE9NLFxuICAgIEJPVFRPTVJJR0hUOiBCT1RUT01SSUdIVCxcblxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGZyb21BQUJCMkRpdmlzaW9uOiBmcm9tQUFCQjJEaXZpc2lvbixcbiAgICBmcm9tU2VnbWVudDI6IGZyb21TZWdtZW50MixcbiAgICBmcm9tQ2lyY2xlOiBmcm9tQ2lyY2xlLFxuICAgIGZyb21SZWN0YW5nbGU6IGZyb21SZWN0YW5nbGUsXG4gICAgemVybzogemVybyxcbiAgICBjbG9uZTogY2xvbmUsXG4gICAgY29weTogY29weSxcbiAgICBleHBhbmQ6IGV4cGFuZCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgb2Zmc2V0TWVyZ2U6IG9mZnNldE1lcmdlLFxuICAgIG9zTWVyZ2U6IG9zTWVyZ2UsXG4gICAgYXJlYTogYXJlYSxcbiAgICBub3JtYWxpemU6IG5vcm1hbGl6ZSxcbiAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZSxcbiAgICBjbGFtcFZlYzogY2xhbXBWZWMsXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgYWxpZ246IGFsaWduLFxuICAgIGlzVmVjMkluc2lkZTogaXNWZWMySW5zaWRlLFxuICAgIGlzQUFCQjJJbnNpZGU6IGlzQUFCQjJJbnNpZGUsXG4gICAgcGVyaW1ldGVyOiBwZXJpbWV0ZXIsXG5cbiAgICAvLyBhbGlhc1xuICAgIGNvbnRhaW5zOiBpc0FBQkIySW5zaWRlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFBQkIyOyIsIi8qKlxuICogU3RhYmlsaXR5OiAxIChPbmx5IGFkZGl0aW9ucyAmIGZpeGVzKVxuICpcbiAqIEByZWZlcmVuY2UgaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvL1xuICogQHJlZmVyZW5jZSBodHRwczovL2dpdGh1Yi5jb20vamFja2N2aWVycy9EZWdyYWZhL2Jsb2IvbWFzdGVyL0RlZ3JhZmEvY29tL2RlZ3JhZmEvZ2VvbWV0cnkvdXRpbGl0aWVzL0JlemllclV0aWxzLmFzXG4gKiBAcmVmZXJlbmNlIGh0dHA6Ly9jYWdkLmNzLmJ5dS5lZHUvfjU1Ny90ZXh0L2NoNy5wZGZcbiAqIEByZWZlcmVuY2UgaHR0cDovL2FsZ29yaXRobWlzdC53b3JkcHJlc3MuY29tLzIwMDkvMDIvMDIvZGVncmFmYS1jbG9zZXN0LXBvaW50LW9uLXF1YWQtYmV6aWVyL1xuICogQHJlZmVyZW5jZSBodHRwOi8vYWxnb3JpdGhtaXN0LndvcmRwcmVzcy5jb20vMjAwOS8wMS8yNi9kZWdyYWZhLWJlemllcnV0aWxzLWNsYXNzL1xuKi9cbnZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIGNsMCA9IDAsXG4gICAgY2wxID0gMCxcbiAgICBjbDIgPSAwLFxuICAgIGNsMyA9IDAsXG4gICAgdDEgPSAwLFxuICAgIHQyID0gMCxcbiAgICB0MyA9IDA7XG5cbi8qKlxuICogY3AwIC0gc3RhcnQgcG9pbnRcbiAqIGNwMSAtIHN0YXJ0IGNvbnRyb2wgcG9pbnRcbiAqIGNwMiAtIGVuZCBjb250cm9sIHBvaW50XG4gKiBjcDMgLSBlbmQgcG9pbnRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY3AweFxuICogQHBhcmFtIHtOdW1iZXJ9IGNwMHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcDF4XG4gKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuICogQHBhcmFtIHtOdW1iZXJ9IGNwMnhcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ5XG4gKiBAcGFyYW0ge051bWJlcn0gY3AzeFxuICogQHBhcmFtIHtOdW1iZXJ9IGNwM3lcbiAqIEByZXR1cm4ge0JlaXplcn1cbiAqL1xuZnVuY3Rpb24gY3ViaWMoY3AweCwgY3AweSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgY3AzeCwgY3AzeSkge1xuaWYgKGNwMHggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjcDB4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNwMHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcDB4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjcDB5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3AweSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjcDB5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3AweSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoY3AxeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNwMXgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgY3AxeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNwMXggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGNwMXkgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjcDF5KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNwMXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcDF5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjcDJ4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3AyeCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjcDJ4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3AyeCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoY3AyeSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNwMnkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgY3AyeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNwMnkgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGNwM3ggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjcDN4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNwM3gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcDN4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjcDN5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3AzeSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjcDN5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3AzeSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuIFtbY3AweCwgY3AweV0sIFtjcDF4LCBjcDF5XSwgW2NwMngsIGNwMnldLCBbY3AzeCwgY3AzeV1dO1xufVxuLyoqXG4gKiBGb3IgaW1wbGVtZW50YXRpb24gc2VlIEZpZ3VyZSAyMS4yXG4gKiBAcmVmZXJlbmNlIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby9cbiAqIEB0b2RvIERPIElUIVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcDB4XG4gKiBAcGFyYW0ge051bWJlcn0gY3AweVxuICogQHBhcmFtIHtOdW1iZXJ9IGNwMXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcDF5XG4gKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuICogQHBhcmFtIHtOdW1iZXJ9IGNwMnlcbiAqIEByZXR1cm4ge0JlaXplcn1cbiAqL1xuZnVuY3Rpb24gZnJvbTNQb2ludHMoY3AweCwgY3AweSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSkge1xuaWYgKGNwMHggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjcDB4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNwMHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcDB4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjcDB5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3AweSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjcDB5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3AweSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoY3AxeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNwMXgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgY3AxeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNwMXggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGNwMXkgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjcDF5KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNwMXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcDF5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjcDJ4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3AyeCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjcDJ4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3AyeCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoY3AyeSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNwMnkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgY3AyeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNwMnkgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxufVxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gY3AweFxuICogQHBhcmFtIHtOdW1iZXJ9IGNwMHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcDF4XG4gKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuICogQHBhcmFtIHtOdW1iZXJ9IGNwMnhcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ5XG4gKiBAcmV0dXJuIHtCZWl6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHF1YWRyaWMoY3AweCwgY3AweSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSkge1xuaWYgKGNwMHggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjcDB4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNwMHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcDB4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjcDB5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3AweSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjcDB5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3AweSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoY3AxeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNwMXgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgY3AxeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNwMXggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGNwMXkgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjcDF5KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNwMXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcDF5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjcDJ4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3AyeCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjcDJ4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3AyeCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoY3AyeSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNwMnkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgY3AyeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNwMnkgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiBbW2NwMHgsIGNwMHldLCBbY3AxeCwgY3AxeV0sIFtjcDJ4LCBjcDJ5XV07XG59XG4vKipcbiAqIEZvciBpbXBsZW1lbnRhdGlvbiBzZWUgRmlndXJlIDIxLjFcbiAqIEByZWZlcmVuY2UgaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvL1xuICogQHBhcmFtIHtOdW1iZXJ9IGNwMHhcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcDB5XG4gKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuICogQHBhcmFtIHtOdW1iZXJ9IGNwMXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ4XG4gKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuICovXG5mdW5jdGlvbiBxdWFkcmljRnJvbTNQb2ludHMoY3AweCwgY3AweSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSkge1xuaWYgKGNwMHggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjcDB4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNwMHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcDB4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjcDB5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3AweSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjcDB5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3AweSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoY3AxeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNwMXgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgY3AxeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNwMXggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGNwMXkgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjcDF5KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNwMXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcDF5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjcDJ4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3AyeCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjcDJ4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3AyeCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoY3AyeSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNwMnkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgY3AyeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNwMnkgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuXG59XG4vKipcbiAqIFNvbHZlcyB0aGUgY3VydmUgKHF1YWRyaWMgb3IgY3ViaWMpIGZvciBhbnkgZ2l2ZW4gcGFyYW1ldGVyIHQuXG4gKiBAc291cmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9oeXBlcmFuZHJvaWQvQ0FBVC9ibG9iL21hc3Rlci9zcmMvTWF0aC9CZXppZXIuanNcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7QmVpemVyfSBjdXJ2ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHQgWzAtMV1cbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIHNvbHZlKG91dF92ZWMyLCBjdXJ2ZSwgdCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKHQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBpZiAoY3VydmUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIC8vY3ViaWNcbiAgICAgICAgdDIgPSB0ICogdDtcbiAgICAgICAgdDMgPSB0ICogdDI7XG4gICAgICAgIGNsMCA9IGN1cnZlWzBdO1xuICAgICAgICBjbDEgPSBjdXJ2ZVsxXTtcbiAgICAgICAgY2wyID0gY3VydmVbMl07XG4gICAgICAgIGNsMyA9IGN1cnZlWzNdO1xuXG4gICAgICAgIG91dF92ZWMyWzBdID0gKGNsMFswXSArIHQgKiAoLWNsMFswXSAqIDMgKyB0ICogKDMgKiBjbDBbMF0gLSBjbDBbMF0gKiB0KSkpICtcbiAgICAgICAgICAgICAgICAgICB0ICogKDMgKiBjbDFbMF0gKyB0ICogKC02ICogY2wxWzBdICsgY2wxWzBdICogMyAqIHQpKSArXG4gICAgICAgICAgICAgICAgICAgdDIgKiAoY2wyWzBdICogMyAtIGNsMlswXSAqIDMgKiB0KSArXG4gICAgICAgICAgICAgICAgICAgY2wzWzBdICogdDM7XG4gICAgICAgIG91dF92ZWMyWzFdID0gKGNsMFsxXSArIHQgKiAoLWNsMFsxXSAqIDMgKyB0ICogKDMgKiBjbDBbMV0gLSBjbDBbMV0gKiB0KSkpICtcbiAgICAgICAgICAgICAgICAgICB0ICogKDMgKiBjbDFbMV0gKyB0ICogKC02ICogY2wxWzFdICsgY2wxWzFdICogMyAqIHQpKSArXG4gICAgICAgICAgICAgICAgICAgdDIgKiAoY2wyWzFdICogMyAtIGNsMlsxXSAqIDMgKiB0KSArXG4gICAgICAgICAgICAgICAgICAgY2wzWzFdICogdDM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcXVhZHJpY1xuXG4gICAgICAgIGNsMCA9IGN1cnZlWzBdO1xuICAgICAgICBjbDEgPSBjdXJ2ZVsxXTtcbiAgICAgICAgY2wyID0gY3VydmVbMl07XG4gICAgICAgIHQxID0gMSAtIHQ7XG5cbiAgICAgICAgb3V0X3ZlYzJbMF0gPSB0MSAqIHQxICogY2wwWzBdICsgMiAqIHQxICogdCAqIGNsMVswXSArIHQgKiB0ICogY2wyWzBdO1xuICAgICAgICBvdXRfdmVjMlsxXSA9IHQxICogdDEgKiBjbDBbMV0gKyAyICogdDEgKiB0ICogY2wxWzFdICsgdCAqIHQgKiBjbDJbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBTb2x2ZSB0aGUgY3VydmUgbnBvaW50cyB0aW1lcyBhbmQgcmV0dXJuIHRoZSBzb2x1dGlvbiBhcnJheS5cbiAqXG4gKiBAc2VlIFBvbHlnb24uZnJvbUJlaXplclxuICpcbiAqIEBwYXJhbSB7QmVpemVyfSBjdXJ2ZVxuICogQHBhcmFtIHtOdW1iZXJ9IG5wb2ludHNcbiAqIEByZXR1cm4ge1ZlYzJbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRzKGN1cnZlLCBucG9pbnRzKSB7XG5pZiAobnBvaW50cyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG5wb2ludHMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbnBvaW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm5wb2ludHMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHZhciBpbnZfbnBvaW50cyA9IDEgLyBucG9pbnRzLFxuICAgICAgICBpLFxuICAgICAgICBvdXRwdXQgPSBbXSxcbiAgICAgICAgdmVjMjtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gMTsgaSArPSBpbnZfbnBvaW50cykge1xuICAgICAgICB2ZWMyID0gWzAsIDBdO1xuICAgICAgICBvdXRwdXQucHVzaChzb2x2ZSh2ZWMyLCBjdXJ2ZSwgaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgY3VydmUgbGVuZ3RoIGJ5IGluY3JlbWVudGFsbHkgc29sdmluZyB0aGUgY3VydmUgZXZlcnkgc3Vic3RlcD1DQUFULkN1cnZlLmsuIFRoaXMgdmFsdWUgZGVmYXVsdHNcbiAqIHRvIC4wNSBzbyBhdCBsZWFzdCAyMCBpdGVyYXRpb25zIHdpbGwgYmUgcGVyZm9ybWVkLlxuICogQHRvZG8gc29tZSBraW5kIG9mIGNhY2hlIG1heWJlIGl0J3MgbmVlZGVkIVxuICogQHBhcmFtIHtCZWl6ZXJ9IGN1cnZlXG4gKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgYXBwcm94aW1hdGUgY3VydmUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBsZW5ndGgoY3VydmUsIHN0ZXApIHtcbmlmIChzdGVwID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oc3RlcCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBzdGVwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3RlcCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgc3RlcCA9IHN0ZXAgfHwgMC4wNTtcblxuICAgIHZhciB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIGxsZW5ndGggPSAwLFxuICAgICAgICBwdCA9IFswLCAwXSxcbiAgICAgICAgdDtcblxuICAgIHgxID0gY3VydmVbMF1bMF07XG4gICAgeTEgPSBjdXJ2ZVswXVsxXTtcbiAgICBmb3IgKHQgPSBzdGVwOyB0IDw9IDEgKyBzdGVwOyB0ICs9IHN0ZXApIHtcbiAgICAgICAgc29sdmUocHQsIGN1cnZlLCB0KTtcbiAgICAgICAgbGxlbmd0aCArPSBzcXJ0KChwdFswXSAtIHgxKSAqIChwdFswXSAtIHgxKSArIChwdFsxXSAtIHkxKSAqIChwdFsxXSAtIHkxKSk7XG4gICAgICAgIHgxID0gcHRbMF07XG4gICAgICAgIHkxID0gcHRbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxsZW5ndGg7XG59XG5cbi8qKlxuICogY3JlZGl0cyAtIENBQVRcbiAqXG4gKiBAY2xhc3MgQmVpemVyXG4gKi9cbnZhciBCZWl6ZXIgPSB7XG4gICAgY3ViaWM6IGN1YmljLFxuICAgIHF1YWRyaWM6IHF1YWRyaWMsXG4gICAgc29sdmU6IHNvbHZlLFxuICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgIGdldFBvaW50czogZ2V0UG9pbnRzXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmVpemVyOyIsIi8qKlxuICogU3RhYmlsaXR5OiAxIChPbmx5IGFkZGl0aW9ucyAmIGZpeGVzKVxuICpcbiAqIENpcmNsZSBpcyByZXByZXNlbnRlZCBhcyBhIHR3byBjb29yZGluYXRlcyBhcnJheVxuICogW2M6VmVjMiwgcjpOdW1iZXJdXG4gKi9cblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi92ZWMyLmpzXCIpLFxuICAgIHZlYzJfc3ViID0gVmVjMi5zdWIsXG4gICAgdmVjMl9kaXN0YW5jZSA9IFZlYzIuZGlzdGFuY2UsXG4gICAgdmVjMl9kaXN0YW5jZV9zcSA9IFZlYzIuZGlzdGFuY2VTcSxcbiAgICB2ZWMyX21pZHBvaW50ID0gVmVjMi5taWRQb2ludCxcblxuICAgIFJlY3RhbmdsZSA9IHJlcXVpcmUoXCIuL3JlY3RhbmdsZS5qc1wiKSxcbiAgICByZWN0YW5nbGVfY2VudGVyID0gUmVjdGFuZ2xlLmNlbnRlcixcblxuICAgIFRyaWFuZ2xlID0gcmVxdWlyZShcIi4vdHJpYW5nbGUuanNcIiksXG4gICAgdHJpYW5nbGVfY2lyY3VtY2VudGVyID0gVHJpYW5nbGUuY2lyY3VtY2VudGVyLFxuICAgIHRyaWFuZ2xlX2NlbnRlciA9IFRyaWFuZ2xlLmNlbnRlcixcbiAgICB0cmlhbmdsZV9hYm1pZHBvaW50ID0gVHJpYW5nbGUuYWJNaWRQb2ludCxcbiAgICB0cmlhbmdsZV9iY21pZHBvaW50ID0gVHJpYW5nbGUuYmNNaWRQb2ludCxcbiAgICB0cmlhbmdsZV9jYW1pZHBvaW50ID0gVHJpYW5nbGUuY2FNaWRQb2ludCxcblxuICAgIG1heCA9IE1hdGgubWF4LFxuICAgIFRXT1BJID0gTWF0aC5UV09QSSxcbiAgICBRVUFURVJfUEkgPSBNYXRoLlBJICogMC4yNSxcbiAgICBQSSA9IE1hdGguUEksXG4gICAgc3FydCA9IE1hdGguc3FydCxcbiAgICBhdXhfdmVjMiA9IFswLCAwXSxcbiAgICBhdXhfbnVtLFxuICAgIGF1eF9udW0yO1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAqIEByZXR1cm4ge0NpcmNsZX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHgsIHksIHJhZGl1cykge1xuaWYgKHggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAocmFkaXVzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmFkaXVzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGl1cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl1cyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuIFtbeCwgeV0sIHJhZGl1c107XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICogQHJldHVybiB7Q2lyY2xlfVxuICovXG5mdW5jdGlvbiBmcm9tVmVjMih2ZWMyLCByYWRpdXMpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG5pZiAocmFkaXVzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmFkaXVzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGl1cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl1cyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuIFtbdmVjMlswXSwgdmVjMlsxXV0sIHJhZGl1c107XG59XG4vKipcbiAqIENyZWF0ZSBhIENpcmNsZSB3aXRoIHNlZzIgYXMgZGlhbWV0ZXJcbiAqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcmV0dXJuIHtDaXJjbGV9XG4gKi9cbmZ1bmN0aW9uIGZyb21TZWdtZW50MihzZWcyKSB7XG4gICAgdmFyIG91dCA9IFtbMCwgMF0sIDBdO1xuXG4gICAgb3V0WzBdWzBdID0gKHNlZzJbMF0gKyBzZWcyWzJdKSAqIDAuNTtcbiAgICBvdXRbMF1bMV0gPSAoc2VnMlsxXSArIHNlZzJbM10pICogMC41O1xuXG4gICAgLy9zdWJ0cmFjdFxuICAgIGF1eF9udW0gPSBvdXRbMF1bMF0gLSBzZWcyWzBdO1xuICAgIGF1eF9udW0yID0gb3V0WzBdWzFdIC0gc2VnMlsxXTtcbiAgICAvL3Nxckxlbmd0aFxuICAgIG91dFsxXSA9IHNxcnQoYXV4X251bSAqIGF1eF9udW0gKyBhdXhfbnVtMiAqIGF1eF9udW0yKTtcblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW49fSBpbnNpZGVcbiAqIEByZXR1cm4ge0NpcmNsZX1cbiAqL1xuZnVuY3Rpb24gZnJvbVJlY3RhbmdsZShyZWN0LCBpbnNpZGUpIHtcbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzBdIHx8IHJlY3RbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMV0gfHwgcmVjdFsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVswXSB8fCByZWN0WzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBSZWN0YW5nbGUgcmVjdFwiKVxufVxuXG5pZiAoaW5zaWRlICE9PSB1bmRlZmluZWQpIHtcbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBpbnNpZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnNpZGUgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG59XG4gICAgdmFyIG91dCA9IFtbMCwgMF0sIDBdO1xuICAgIHJlY3RhbmdsZV9jZW50ZXIob3V0WzBdLCByZWN0KTtcblxuICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgYXV4X3ZlYzJbMF0gPSByZWN0WzBdWzBdICsgKHJlY3RbMV1bMF0gLSByZWN0WzBdWzBdKSAqIDAuNTtcbiAgICAgICAgYXV4X3ZlYzJbMV0gPSByZWN0WzBdWzFdO1xuXG4gICAgICAgIG91dFsxXSA9IHZlYzJfZGlzdGFuY2Uob3V0WzBdLCBhdXhfdmVjMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzFdID0gdmVjMl9kaXN0YW5jZShvdXRbMF0sIHJlY3RbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEB0b2RvIHJldmlldyBpbnNpZGUgY2FzZXNcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHRyaVxuICogQHBhcmFtIHtCb29sZWFuPX0gaW5zaWRlXG4gKiBAcGFyYW0ge0Jvb2xlYW49fSBjaXJjdW1jZW50ZXJcbiAqIEByZXR1cm4ge0NpcmNsZX1cbiAqL1xuZnVuY3Rpb24gZnJvbVRyaWFuZ2xlKHRyaSwgaW5zaWRlLCBjaXJjdW1jZW50ZXIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh0cmkpIHx8IHRyaVswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMF1bMF0gfHwgdHJpWzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVsxXSB8fCB0cmlbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzFdWzBdIHx8IHRyaVsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMV0gfHwgdHJpWzJdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzJdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsyXVswXSB8fCB0cmlbMl1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBUcmFpbmdsZSB0cmlcIilcbn1cblxuaWYgKGluc2lkZSAhPT0gdW5kZWZpbmVkKSB7XG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgaW5zaWRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5zaWRlIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxufVxuaWYgKGNpcmN1bWNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY2lyY3VtY2VudGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2lyY3VtY2VudGVyIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxufVxuICAgIHZhciBvdXQgPSBbWzAsIDBdLCAwXTtcblxuICAgIGlmIChjaXJjdW1jZW50ZXIgJiYgIWluc2lkZSkge1xuICAgICAgICB0cmlhbmdsZV9jaXJjdW1jZW50ZXIob3V0WzBdLCB0cmkpO1xuXG4gICAgICAgIC8vIHVzZSBkaXN0YW5jZV4yIGZvciBjb21wYXJpc29uXG4gICAgICAgIG91dFsxXSA9IHZlYzJfZGlzdGFuY2Vfc3Eob3V0WzBdLCB0cmlbMF0pO1xuICAgICAgICBhdXhfbnVtID0gdmVjMl9kaXN0YW5jZV9zcShvdXRbMF0sIHRyaVsxXSk7XG4gICAgICAgIGlmIChhdXhfbnVtID4gb3V0WzFdKSB7XG4gICAgICAgICAgICBvdXRbMV0gPSBhdXhfbnVtO1xuICAgICAgICB9XG4gICAgICAgIG91dFsxXSA9IHZlYzJfZGlzdGFuY2Vfc3Eob3V0WzBdLCB0cmlbMl0pO1xuICAgICAgICBpZiAoYXV4X251bSA+IG91dFsxXSkge1xuICAgICAgICAgICAgb3V0WzFdID0gYXV4X251bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbmQgbm93IHJldHVybiB0aGUgZ29vZCBvbmUgOilcbiAgICAgICAgb3V0WzFdID0gc3FydChvdXRbMV0pO1xuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgdHJpYW5nbGVfY2VudGVyKG91dFswXSwgdHJpKTtcblxuICAgIC8vIHVzZSBkaXN0YW5jZV4yIGZvciBjb21wYXJpc29uXG4gICAgdHJpYW5nbGVfYWJtaWRwb2ludChhdXhfdmVjMiwgdHJpKTtcbiAgICBvdXRbMV0gPSB2ZWMyX2Rpc3RhbmNlX3NxKG91dFswXSwgYXV4X3ZlYzIpO1xuXG4gICAgdHJpYW5nbGVfYmNtaWRwb2ludChhdXhfdmVjMiwgdHJpKTtcbiAgICBhdXhfbnVtID0gdmVjMl9kaXN0YW5jZV9zcShvdXRbMF0sIGF1eF92ZWMyKTtcbiAgICBpZiAoYXV4X251bSA8IG91dFsxXSkge1xuICAgICAgICBvdXRbMV0gPSBhdXhfbnVtO1xuICAgIH1cblxuICAgIHRyaWFuZ2xlX2NhbWlkcG9pbnQoYXV4X3ZlYzIsIHRyaSk7XG4gICAgYXV4X251bSA9IHZlYzJfZGlzdGFuY2Vfc3Eob3V0WzBdLCBhdXhfdmVjMik7XG4gICAgaWYgKGF1eF9udW0gPCBvdXRbMV0pIHtcbiAgICAgICAgb3V0WzFdID0gYXV4X251bTtcbiAgICB9XG5cbiAgICAvLyBhbmQgbm93IHJldHVybiB0aGUgZ29vZCBvbmUgOilcbiAgICBvdXRbMV0gPSBzcXJ0KG91dFsxXSk7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEByZXR1cm4ge0NpcmNsZX1cbiAqL1xuZnVuY3Rpb24gY2xvbmUoY2lyY2xlKSB7XG4gICAgcmV0dXJuIFtbY2lyY2xlWzBdWzBdLCBjaXJjbGVbMF1bMV1dLCBjaXJjbGVbMV1dO1xufVxuLyoqXG4gKiBAcGFyYW0ge0NpcmNsZX0gb3V0XG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlXG4gKiBAcmV0dXJuIHtDaXJjbGV9XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBjaXJjbGUpIHtcbiAgICBvdXRbMF1bMF0gPSBjaXJjbGVbMF1bMF07XG4gICAgb3V0WzBdWzFdID0gY2lyY2xlWzBdWzFdO1xuICAgIG91dFsxXSA9IGNpcmNsZVsxXTtcblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7Q2lyY2xlfSBvdXRcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHJldHVybiB7Q2lyY2xlfVxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBjaXJjbGUsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgb3V0WzBdWzBdID0gY2lyY2xlWzBdWzBdICsgdmVjMlswXTtcbiAgICBvdXRbMF1bMV0gPSBjaXJjbGVbMF1bMV0gKyB2ZWMyWzFdO1xuICAgIG91dFsxXSA9IGNpcmNsZVsxXTtcblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7Q2lyY2xlfSBvdXRcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHJldHVybiB7Q2lyY2xlfVxuICovXG5mdW5jdGlvbiBtb3ZlVG8ob3V0LCBjaXJjbGUsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgb3V0WzBdWzBdID0gdmVjMlswXTtcbiAgICBvdXRbMF1bMV0gPSB2ZWMyWzFdO1xuICAgIG91dFsxXSA9IGNpcmNsZVsxXTtcblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVfMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZShjaXJjbGUsIGNpcmNsZV8yKSB7XG4gICAgcmV0dXJuIG1heCgwLCB2ZWMyX2Rpc3RhbmNlKGNpcmNsZVswXSwgY2lyY2xlXzJbMF0pIC0gY2lyY2xlWzFdIC0gY2lyY2xlXzJbMV0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChjaXJjbGUpIHtcbiAgICByZXR1cm4gVFdPUEkgKiBjaXJjbGVbMV07XG59XG4vKipcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gYXJlYShjaXJjbGUpIHtcbiAgICByZXR1cm4gUEkgKiBjaXJjbGVbMV0gKiBjaXJjbGVbMV07XG59XG4vKipcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWZWMySW5zaWRlKGNpcmNsZSwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICByZXR1cm4gdmVjMl9kaXN0YW5jZShjaXJjbGVbMF0sIHZlYzIpIDwgY2lyY2xlWzFdO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3RQb2ludChvdXRfdmVjMiwgY2lyY2xlLCB2ZWMyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIC8vY29uc3QgVmVjdG9yJiBQLCBjb25zdCBWZWN0b3ImIENlbnRyZSwgZmxvYXQgcmFkaXVzLCBib29sKiBpbnNpZGUpXG4gICAgdmVjMl9zdWIob3V0X3ZlYzIsIHZlYzIgLSBjaXJsY2VbMF0pO1xuXG4gICAgdmFyIGRpc3QyID0gdmVjMl9sZW5ndGgob3V0X3ZlYzIpO1xuXG4gICAgLy8gaXMgaW5zaWRlPyAoZGlzdDIgPD0gcmFkaXVzICogcmFkaXVzKTtcblxuICAgIC8vaWYoZGlzdDIgPiBFUFMpIERlbHRhIC89IHNxcnQoZGlzdDIpO1xuXG4gICAgdmVjMl9zY2FsZShvdXRfdmVjMiwgb3V0X3ZlYzIsIHNjYWxlKTtcbiAgICB2ZWMyX2FkZChvdXRfdmVjMiwgY2lybGNlWzBdLCBzY2FsZSk7XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaXJjbGV9IGNpcmNsZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1hc3NcbiAqL1xuZnVuY3Rpb24gbW9tZW50T2ZJbmVydGlhKGNpcmNsZSwgbWFzcykge1xuaWYgKG1hc3MgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXNzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXNzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICB2YXIgciA9IGNpcmNsZVsxXTtcbiAgICByZXR1cm4gbWFzcyAqIHIgKiByICogMC41O1xuXG59XG5cbi8qKlxuICogQGNsYXNzIENpcmNsZVxuICovXG52YXIgQ2lyY2xlID0ge1xuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGZyb21WZWMyOiBmcm9tVmVjMixcbiAgICBmcm9tU2VnbWVudDI6IGZyb21TZWdtZW50MixcbiAgICBmcm9tUmVjdGFuZ2xlOiBmcm9tUmVjdGFuZ2xlLFxuICAgIGZyb21UcmlhbmdsZTogZnJvbVRyaWFuZ2xlLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICBjb3B5OiBjb3B5LFxuICAgIHRyYW5zbGF0ZTogdHJhbnNsYXRlLFxuICAgIG1vdmVUbzogbW92ZVRvLFxuICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICBhcmVhOiBhcmVhLFxuICAgIGlzVmVjMkluc2lkZTogaXNWZWMySW5zaWRlLFxuXG4gICAgLy9waHlzaWNzXG4gICAgbW9tZW50T2ZJbmVydGlhOiBtb21lbnRPZkluZXJ0aWEsXG5cbiAgICAvLyBhbGlhc1xuICAgIHBlcmltZXRlcjogbGVuZ3RoLFxuICAgIG1vdmU6IG1vdmVUb1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTsiLCIvKipcbiAqIFN0YWJpbGl0eTogMCAoQW55dGhpbmcgY291bGQgaGFwcGVuKVxuICpcbiAqIFRoaXMgbmVlZCByZXZpc2lvbi5cbiAqICoqaW5zaWRlOkJvb2xlYW4qKiBwYXJhbSBtdXN0IGJlIGFkZGVkIHRvIGFsbCBmdW5jdGlvbnNcbiAqICpOb3RlKiogdGhpcyBub3QgcmV0dXJuIHRoZSBjb250YWN0IHBvaW50cywgdXNlIGludGVyc2VjdGlvbnMgZm9yIHRoYXQuXG4gKlxuICogQHNvdXJjZSBodHRwOi8vbWVtYmVycy5nYW1lZGV2Lm5ldC9vbGlpaS9zYXRwb3N0L1NwaGVyZVBvbHlnb25Db2xsaXNpb24uY3BwXG4gKi9cblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi92ZWMyLmpzXCIpLFxuICAgIHZlYzJfZGlzdGFuY2UgPSBWZWMyLmRpc3RhbmNlLFxuICAgIHZlYzJfZGlzdGFuY2Vfc3EgPSBWZWMyLmRpc3RhbmNlU3EsXG4gICAgdmVjMl9taWRwb2ludCA9IFZlYzIubWlkUG9pbnQsXG4gICAgdmVjMl8kbmVhciA9IFZlYzIuJG5lYXIsXG4gICAgdmVjMl9zdWIgPSBWZWMyLnN1YixcbiAgICB2ZWMyX2RvdCA9IFZlYzIuZG90LFxuXG4gICAgU2VnbWVudDIgPSByZXF1aXJlKFwiLi9zZWdtZW50Mi5qc1wiKSxcbiAgICBTZWdtZW50Ml8kY2xvc2VzdFBvaW50ID0gU2VnbWVudDIuJGNsb3Nlc3RQb2ludCxcblxuICAgIGF1eF92ZWMyID0gWzAsIDBdLFxuICAgIGNhID0gWzAsIDBdLFxuICAgIGJhID0gWzAsIDBdLFxuICAgIHBhID0gWzAsIDBdLFxuXG4gICAgRVBTID0gTWF0aC5FUFMgPSAwLjAwMTtcblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtMlxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RcbiAqL1xuZnVuY3Rpb24gX25lYXIobnVtLCBudW0yLCBkaXN0KSB7XG5pZiAobnVtID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obnVtKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG51bSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm51bSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAobnVtMiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG51bTIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbnVtMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm51bTIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGRpc3QgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihkaXN0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGRpc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXN0IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gbnVtID4gbnVtMiAtIGRpc3QgJiYgbnVtIDwgbnVtMiArIGRpc3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHgxXG4gKiBAcGFyYW0ge051bWJlcn0geTFcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gKiBAcGFyYW0ge051bWJlcn0geDNcbiAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICovXG5mdW5jdGlvbiBfcmVjdGFuZ2xlX3ZlYzIoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuaWYgKHgxID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDEpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeDMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MykgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4Mykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiAoeDEgPiB4MyB8fCB4MiA8IHgzIHx8IHkxID4geTMgfHwgeTIgPCB5MykgPyBmYWxzZSA6IHRydWU7XG59XG4vKipcbiAqIEBwYXJhbSB7QUFCQjJ9IGJiMlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBiYjJfdmVjMihiYjIsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShiYjIpIHx8IGJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbMF0gfHwgYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlsxXSB8fCBiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyWzJdIHx8IGJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbM10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFBQkIyIGJiMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIHJldHVybiBfcmVjdGFuZ2xlX3ZlYzIoYmIyWzBdLCBiYjJbMV0sIGJiMlsyXSwgYmIyWzNdLCB2ZWMyWzBdLCB2ZWMyWzFdKTtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcGFyYW0ge0FBQkIyfSBiYjJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZlYzJfYmIyKHZlYzIsIGJiMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShiYjIpIHx8IGJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbMF0gfHwgYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlsxXSB8fCBiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyWzJdIHx8IGJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbM10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFBQkIyIGJiMlwiKVxufVxuXG4gICAgcmV0dXJuIF9yZWN0YW5nbGVfdmVjMihiYjJbMF0sIGJiMlsxXSwgYmIyWzJdLCBiYjJbM10sIHZlYzJbMF0sIHZlYzJbMV0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdFxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiByZWN0YW5nbGVfdmVjMihyZWN0LCB2ZWMyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkocmVjdCkgfHwgcmVjdFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVswXSB8fCByZWN0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzFdIHx8IHJlY3RbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMF0gfHwgcmVjdFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgUmVjdGFuZ2xlIHJlY3RcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICB2YXIgdGwgPSByZWN0WzBdLCBiciA9IHJlY3RbMV07XG4gICAgcmV0dXJuIF9yZWN0YW5nbGVfdmVjMih0bFswXSwgdGxbMV0sIGJyWzBdLCBiclsxXSwgdmVjMlswXSwgdmVjMlsxXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZlYzJfcmVjdGFuZ2xlKHZlYzIsIHJlY3QpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkocmVjdCkgfHwgcmVjdFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVswXSB8fCByZWN0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzFdIHx8IHJlY3RbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMF0gfHwgcmVjdFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgUmVjdGFuZ2xlIHJlY3RcIilcbn1cblxuICAgIHZhciB0bCA9IHJlY3RbMF0sIGJyID0gcmVjdFsxXTtcbiAgICByZXR1cm4gX3JlY3RhbmdsZV92ZWMyKHRsWzBdLCB0bFsxXSwgYnJbMF0sIGJyWzFdLCB2ZWMyWzBdLCB2ZWMyWzFdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBiZW5jaG1hcmtcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNlZ21lbnQyX3ZlYzIoc2VnMiwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICB2YXIgeCA9IHZlYzJbMF0sXG4gICAgICAgIHkgPSB2ZWMyWzFdO1xuXG4gICAgU2VnbWVudDJfJGNsb3Nlc3RQb2ludChhdXhfdmVjMiwgc2VnMlswXSwgc2VnMlsxXSwgc2VnMlsyXSwgc2VnMlszXSwgeCwgeSk7XG5cbiAgICByZXR1cm4gdmVjMl8kbmVhcihhdXhfdmVjMlswXSwgYXV4X3ZlYzJbMV0sIHgsIHkpO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZlYzJfc2VnbWVudDIodmVjMiwgc2VnMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICByZXR1cm4gc2VnbWVudDJfdmVjMihzZWcyLCB2ZWMyKTtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcGFyYW0ge0xpbmUyfSBsaW5lMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmVjMl9saW5lMih2ZWMyLCBsaW5lMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICAvL3JldHVybiBfbmVhcih2ZWMyWzFdLCBsaW5lMlsxXSAqIHZlYzJbMF0gLSBsaW5lMlswXVsxXSk7XG4gICAgdmFyIHAgPSBsaW5lMlswXTtcbiAgICByZXR1cm4gX25lYXIobGluZTJbMV0sICh2ZWMyWzFdIC0gcFsxXSkgLyAodmVjMlswXSAtIHBbMF0pLCBFUFMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZTJ9IGxpbmUyXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGxpbmUyX3ZlYzIobGluZTIsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgLy9yZXR1cm4gX25lYXIodmVjMlsxXSwgbGluZTJbMV0gKiB2ZWMyWzBdIC0gbGluZTJbMF1bMV0pO1xuICAgIHZhciBwID0gbGluZTJbMF07XG4gICAgcmV0dXJuIF9uZWFyKGxpbmUyWzFdLCAodmVjMlsxXSAtIHBbMV0pIC8gKHZlYzJbMF0gLSBwWzBdKSwgRVBTKTtcbn1cblxuXG5cbi8qKlxuICogQHBhcmFtIHtDaXJjbGV9IGNpcmNsZV8xXG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlXzJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNpcmNsZV9jaXJjbGUoY2lyY2xlXzEsIGNpcmNsZV8yKSB7XG4gICAgc3RyaWN0ID0gc3RyaWN0IHx8IGZhbHNlO1xuXG4gICAgdmFyIC8vIERldGVybWluZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHJhZGl1cyB3aGVyZSBjaXJjbGVzIGNhbiBpbnRlcnNlY3RcbiAgICAgICAgcl9tYXggPSBjaXJjbGVfMVsxXSArIGNpcmNsZV8yWzFdLFxuICAgICAgICAvLyBEZXRlcm1pbmUgYWN0dWFsIGRpc3RhbmNlIGJldHdlZW4gY2lyY2xlIGNpcmNsZXNcbiAgICAgICAgY19kaXN0X3NxID0gVmVjMi5kaXN0YW5jZVNxKGNpcmNsZV8xWzBdLCBjaXJjbGVfMlswXSk7XG5cbiAgICBpZiAoY19kaXN0X3NxID4gcl9tYXggKiByX21heCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaXJjbGV9IGNpcmNsZVxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjaXJjbGVfdmVjMihjaXJjbGUsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgdmFyIGRpc3RhbmNlX3RvX2NlbnRlciA9IHZlYzJfZGlzdGFuY2Vfc3EoY2lyY2xlWzBdLCB2ZWMyKSxcbiAgICAgICAgciA9IGNpcmNsZVsxXSxcbiAgICAgICAgcjIgPSByICogcjtcblxuICAgIHJldHVybiBkaXN0YW5jZV90b19jZW50ZXIgPD0gcjI7XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHBhcmFtIHtDaXJjbGV9IGNpcmNsZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmVjMl9jaXJjbGUodmVjMiwgY2lyY2xlKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIGNpcmNsZV92ZWMyKGNpcmNsZSwgdmVjMik7XG59XG4vKipcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHRyaVxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiB0cmlhbmdsZV92ZWMyKHRyaSwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHRyaSkgfHwgdHJpWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVswXSB8fCB0cmlbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzFdIHx8IHRyaVsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMF0gfHwgdHJpWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVsxXSB8fCB0cmlbMl1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzBdIHx8IHRyaVsyXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRyYWluZ2xlIHRyaVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIC8vIENvbXB1dGUgdmVjdG9yc1xuICAgIGNhID0gdmVjMl9zdWIodHJpWzJdLCB0cmlbMF0pOyAvLyB2MCA9IEMgLSBBXG4gICAgYmEgPSB2ZWMyX3N1Yih0cmlbMV0sIHRyaVswXSk7IC8vIHYxID0gQiAtIEFcbiAgICBwYSA9IHZlYzJfc3ViKHZlYzIsIHRyaVswXSk7IC8vIHYyID0gUCAtIEFcblxuICAgIC8vIENvbXB1dGUgZG90IHByb2R1Y3RzXG4gICAgdmFyIGRvdDAwID0gdmVjMl9kb3QoY2EsIGNhKTsgLy9kb3QwMCA9IGRvdCh2MCwgdjApXG4gICAgdmFyIGRvdDAxID0gdmVjMl9kb3QoY2EsIGJhKTsgLy9kb3QwMSA9IGRvdCh2MCwgdjEpXG4gICAgdmFyIGRvdDAyID0gdmVjMl9kb3QoY2EsIHBhKTsgLy9kb3QwMiA9IGRvdCh2MCwgdjIpXG4gICAgdmFyIGRvdDExID0gdmVjMl9kb3QoYmEsIGJhKTsgLy9kb3QxMSA9IGRvdCh2MSwgdjEpXG4gICAgdmFyIGRvdDEyID0gdmVjMl9kb3QoYmEsIHBhKTsgLy9kb3QxMiA9IGRvdCh2MSwgdjIpXG5cbiAgICAvLyBDb21wdXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXG4gICAgdmFyIGludkRlbm9tID0gMSAvIChkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSk7XG4gICAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgdmFyIHYgPSAoZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpICogaW52RGVub207XG5cbiAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbiB0cmlhbmdsZVxuICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcblxufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHRyaVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmVjMl90cmlhbmdsZSh2ZWMyLCB0cmkpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodHJpKSB8fCB0cmlbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzBdIHx8IHRyaVswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMF1bMV0gfHwgdHJpWzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVswXSB8fCB0cmlbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzFdWzFdIHx8IHRyaVsyXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMF0gfHwgdHJpWzJdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzJdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsyXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVHJhaW5nbGUgdHJpXCIpXG59XG5cbiAgICByZXR1cm4gdHJpYW5nbGVfdmVjMih0cmksIHZlYzIpXG59XG5cbi8qKlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJfMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmVjMl92ZWMyKHZlYzIsIHZlYzJfMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyXzIpIHx8IHZlYzJfMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJfMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyXzJbMF0gfHwgdmVjMl8yWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMl8yWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJfMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXzJcIilcbn1cblxuICAgIHJldHVybiBfbmVhcih2ZWMyWzBdLCB2ZWMyXzJbMF0sIEVQUykgJiZcbiAgICAgICAgX25lYXIodmVjMlsxXSwgdmVjMl8yWzFdLCBFUFMpO1xufVxuXG52YXIgQ29sbGlkZSA9IHtcbiAgICBjaXJjbGVfY2lyY2xlOiBjaXJjbGVfY2lyY2xlLFxuXG4gICAgLy9cbiAgICAvLyB2ZWMyIGFnYWluc3QgdGhlIHdvcmxkIVxuICAgIC8vXG4gICAgYmIyX3ZlYzI6IGJiMl92ZWMyLFxuICAgIHZlYzJfYmIyOiB2ZWMyX2JiMixcblxuICAgIHJlY3RhbmdsZV92ZWMyOiByZWN0YW5nbGVfdmVjMixcbiAgICB2ZWMyX3JlY3RhbmdsZTogdmVjMl9yZWN0YW5nbGUsXG5cbiAgICBzZWdtZW50Ml92ZWMyOiBzZWdtZW50Ml92ZWMyLFxuICAgIHZlYzJfc2VnbWVudDI6IHZlYzJfc2VnbWVudDIsXG5cbiAgICBjaXJjbGVfdmVjMjogY2lyY2xlX3ZlYzIsXG4gICAgdmVjMl9jaXJjbGU6IHZlYzJfY2lyY2xlLFxuXG4gICAgdmVjMl9saW5lMjogdmVjMl9saW5lMixcbiAgICBsaW5lMl92ZWMyOiBsaW5lMl92ZWMyLFxuXG4gICAgdHJpYW5nbGVfdmVjMjogdHJpYW5nbGVfdmVjMixcbiAgICB2ZWMyX3RyaWFuZ2xlOiB2ZWMyX3RyaWFuZ2xlLFxuXG4gICAgdmVjMl92ZWMyOiB2ZWMyX3ZlYzIsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpZGU7XG5cbi8qXG52YXIgcHJpbWl0aXZlcyA9IFtcImNpcmNsZVwiLCBcInJlY3RhbmdsZVwiLCBcInZlYzJcIiwgXCJsaW5lMlwiLCBcInNlZ21lbnQyXCIsIFwiYmIyXCIsIFwidHJpYW5nbGVcIl0sXG4gICAgaSxcbiAgICBqLFxuICAgIGZuO1xuZm9yIChpID0gMDsgaSA8IHByaW1pdGl2ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgcHJpbWl0aXZlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBmbiA9IHByaW1pdGl2ZXNbaV0gKyBcIl9cIiArIHByaW1pdGl2ZXNbal07XG4gICAgICAgIGlmICghQ29sbGlzaW9uc1tmbl0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidG9kbzogQ29sbGlzaW9ucy5cIiwgZm4pO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmNvbnNvbGUubG9nKHZlYzJfbGluZTIoWzEsIDFdLCBbWzAsMF0sIDFdKSk7XG5jb25zb2xlLmxvZyh2ZWMyX2xpbmUyKFsxLCAyXSwgW1swLDBdLCAyXSkpO1xuXG4qLyIsIi8qKlxuICogQHJlZmVyZW5jZSBodHRwOi8vd3d3LmNvZGV6ZWFsb3Qub3JnL2FyY2hpdmVzLzE4MFxuICogQHJlZmVyZW5jZSBodHRwczovL2dpdGh1Yi5jb20vTFNGTi9keW40Z28vYmxvYi8zODM0NzRlZTM5MjRkNjI2YTFjMTA2YmM3MTdmMDdkZWI3NmI5NjM1L2NvbGxpc2lvbi9uYXJyb3dwaGFzZS9FUEEuZ29cbiAqIEByZWZlcmVuY2UgaHR0cHM6Ly9naXRodWIuY29tL0JyYW5kb25MaXR0ZWxsL1BpbmJhbGxHTC9ibG9iL2QyNjc4ZjBlOTE2Y2RiOGI4YTIzNDI0M2ZlZWRhMDNhMTk2ZTViYzgvR3JvdXAzX0ZpbmFsUHJvamVjdC9Db2xsaXNpb24uY3BwXG4gKi9cblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vdmVjMi5qc1wiKSxcbiAgICB2ZWMyX3N1YiA9IFZlYzIuc3ViLFxuICAgIHZlYzJfY3Jvc3MgPSBWZWMyLmNyb3NzLFxuICAgIHZlYzJfdHJpcGxlUHJvZHVjdCA9IFZlYzIudHJpcGxlUHJvZHVjdCxcbiAgICB2ZWMyX25vcm1hbGl6ZSA9IFZlYzIubm9ybWFsaXplLFxuICAgIHZlYzJfZG90ID0gVmVjMi5kb3QsXG4gICAgUG9seWdvbiA9IHJlcXVpcmUoXCIuLi9wb2x5Z29uLmpzXCIpLFxuICAgIGNsZWFyID0gcmVxdWlyZShcIi4vcmVzcG9uc2UuanNcIikuY2xlYXIsXG4gICAgcG9seWdvbl9mdXJ0aGVzdE1pbmtvd3NraSA9IFBvbHlnb24uZnVydGhlc3RNaW5rb3dza2k7XG5cbnZhciBnd19hdXggPSBbMCwgMF07XG52YXIgZ3dfYXV4MiA9IFswLCAwXTtcbi8qKlxuICogQHBhcmFtIHtQb2x5Z29ufSBzaW1wbGV4XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIF9nZXRXaW5kaW5nKHNpbXBsZXgpIHtcbiAgICB2ZWMyX3N1Yihnd19hdXgsIHNpbXBsZXhbMV0sIHNpbXBsZXhbMF0pO1xuICAgIHZlYzJfc3ViKGd3X2F1eDIsIHNpbXBsZXhbMl0sIHNpbXBsZXhbMV0pO1xuICAgIHJldHVybiB2ZWMyX2Nyb3NzKGd3X2F1eCwgZ3dfYXV4Mik7XG5cblxuICAgIHZhciBsZW4gPSBzaW1wbGV4Lmxlbmd0aCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGosXG4gICAgICAgIGY7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgaWYgKGogPT09IGxlbikge1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZiA9IHZlYzJfY3Jvc3Moc2ltcGxleFtpXSwgc2ltcGxleFtqXSk7XG5cbiAgICAgICAgaWYgKGYgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChmIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG52YXIgZWRnZSA9IFswLCAwXTtcbi8qKlxuICogQHBhcmFtIHtQb2x5Z29ufSBzaW1wbGV4XG4gKiBAcGFyYW0ge051bWJlcn0gd2luZGluZ1xuICovXG5mdW5jdGlvbiBfZmluZENsb3Nlc3RFZGdlKHNpbXBsZXgsIHdpbmRpbmcpIHtcbmlmICh3aW5kaW5nID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4od2luZGluZykgfHwgJ251bWJlcicgIT09IHR5cGVvZiB3aW5kaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwid2luZGluZyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgLy8gcHJpbWUgdGhlIGRpc3RhbmNlIG9mIHRoZSBlZGdlIHRvIHRoZSBtYXhcbiAgICB2YXIgZGlzdGFuY2UgPSBJbmZpbml0eSxcbiAgICAgICAgYSxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgZCxcbiAgICAgICAgbiA9IFswLCAwXSxcbiAgICAgICAgbm9ybWFsID0gWzAsIDBdLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbGVuID0gc2ltcGxleC5sZW5ndGgsXG4gICAgICAgIGxlbm0xID0gbGVuIC0gMTtcblxuICAgIC8vIHNpbXBsZXggaXMgdGhlIHBhc3NlZCBpbiBzaW1wbGV4XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIGNvbXB1dGUgdGhlIG5leHQgcG9pbnRzIGluZGV4XG4gICAgICAgIGogPSBpID09PSBsZW5tMSA/IDAgOiBpICsgMTtcbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHBvaW50IGFuZCB0aGUgbmV4dCBvbmVcbiAgICAgICAgYSA9IHNpbXBsZXhbaV07XG4gICAgICAgIC8vIGIgPSBzaW1wbGV4W2pdO1xuICAgICAgICAvLyBjcmVhdGUgdGhlIGVkZ2UgdmVjdG9yXG4gICAgICAgIHZlYzJfc3ViKGVkZ2UsIHNpbXBsZXhbal0sIGEpOyAvLyBvciBhLnRvKGIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImVkZ2VcIiwgZWRnZSwgXCJAXCIsIGksIGosIGEsIHNpbXBsZXhbal0pO1xuICAgICAgICAvLyBnZXQgdGhlIHZlY3RvciBmcm9tIHRoZSBvcmlnaW4gdG8gYVxuICAgICAgICAvL1ZlY3RvciBvYSA9IGE7IC8vIG9yIGEgLSBPUklHSU5cblxuICAgICAgICAvLyBnZXQgdGhlIHZlY3RvciBmcm9tIHRoZSBlZGdlIHRvd2FyZHMgdGhlIG9yaWdpblxuICAgICAgICAvL3ZlYzJfdHJpcGxlUHJvZHVjdChuLCBlZGdlLCBhLCBlZGdlKTtcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIEBsbGFmdWVudGU6IHdpbmRpbmcgbWV0aG9kIHNlZW1zIHRvIGJlIG1vcmUgcmVsaWFibGUgdG8gZmluZCBNVFZcbiAgICAgICAgaWYgKHdpbmRpbmcgPiAwKSB7XG4gICAgICAgICAgICBWZWMyLnJvdGF0ZUNXKG4sIGVkZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVmVjMi5yb3RhdGVDQ1cobiwgZWRnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9ybWFsaXplIHRoZSB2ZWN0b3JcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgdmVjMl9ub3JtYWxpemUobiwgbik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwidHJpcGxlUHJvZHVjdFwiLCBuLCBlZGdlLCBhLCBlZGdlKTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4gdG8gdGhlIGVkZ2VcbiAgICAgICAgZCA9IHZlYzJfZG90KGEsIG4pOyAvLyBjb3VsZCB1c2UgYiBvciBhIGhlcmVcbiAgICAgICAgLy8gY2hlY2sgdGhlIGRpc3RhbmNlIGFnYWluc3QgdGhlIG90aGVyIGRpc3RhbmNlc1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImQgPSBhLmRvdChuKSA9XCIsIGQsIGRpc3RhbmNlKTtcbiAgICAgICAgaWYgKGQgPCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBlZGdlIGlzIGNsb3NlciB0aGVuIHVzZSBpdFxuICAgICAgICAgICAgZGlzdGFuY2UgPSBkO1xuICAgICAgICAgICAgbm9ybWFsWzBdID0gblswXTtcbiAgICAgICAgICAgIG5vcm1hbFsxXSA9IG5bMV07XG4gICAgICAgICAgICBpbmRleCA9IGo7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIHRoZSBjbG9zZXN0IGVkZ2Ugd2UgZm91bmRcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgIG5vcm1hbDogbm9ybWFsLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAVE9ETyB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBoYXMgbm8gbWF4IGl0ZXJhdGlvbnMsIGJ1dCBzZWVtcyB0byB3b3JrIHJldmlldyBlZGdlIGNhc2VzXG4gKlxuICogQHBhcmFtIHtSZXNwb25zZX0gb3V0X3Jlc3BvbnNlXG4gKiBAcGFyYW0ge1BvbHlnb259IEFcbiAqIEBwYXJhbSB7UG9seWdvbn0gQlxuICogQHBhcmFtIHtQb2x5Z29ufSBzaW1wbGV4IHJlc3VsdCBvZiBHSktcbiAqL1xuZnVuY3Rpb24gRVBBKG91dF9yZXNwb25zZSwgQSwgQiwgc2ltcGxleCkge1xuICAgIC8vc2ltcGxleCA9IFtbNCwgMl0sIFstOCwgLTJdLCBbLTEsIC0yXV07XG4gICAgY2xlYXIob3V0X3Jlc3BvbnNlKTtcblxuICAgIHZhciBlZGdlLFxuICAgICAgICBkZXB0aCxcbiAgICAgICAgcCxcbiAgICAgICAgd2luZGluZyA9IF9nZXRXaW5kaW5nKHNpbXBsZXgpO1xuICAgIGNvbnNvbGUubG9nKFwid2luZGluZ1wiLCB3aW5kaW5nKTtcblxuICAgIC8vcmVkbyB0aGUgc2ltcGxleFxuICAgIGlmICh3aW5kaW5nIDw9IDApIHtcbiAgICAgICAgc2ltcGxleC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgLy8gbG9vcCB0byBmaW5kIHRoZSBjb2xsaXNpb24gaW5mb3JtYXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIioqKioqKioqKioqKioqKioqKioqKioqKioqKlwiLCBQb2x5Z29uLnRvU3RyaW5nKHNpbXBsZXgpKTtcbiAgICAgICAgLy8gb2J0YWluIHRoZSBmZWF0dXJlIChlZGdlIGZvciAyRCkgY2xvc2VzdCB0byB0aGUgb3JpZ2luIG9uIHRoZSBNaW5rb3dza2kgRGlmZmVyZW5jZVxuICAgICAgICBlZGdlID0gX2ZpbmRDbG9zZXN0RWRnZShzaW1wbGV4LCB3aW5kaW5nKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJfZmluZENsb3Nlc3RFZGdlXCIsIGVkZ2UpO1xuICAgICAgICAvLyBvYnRhaW4gYSBuZXcgc3VwcG9ydCBwb2ludCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlIG5vcm1hbFxuICAgICAgICBwID0gcG9seWdvbl9mdXJ0aGVzdE1pbmtvd3NraShbMCwgMF0sIEEsIEIsIGVkZ2Uubm9ybWFsKTtcbiAgICAgICAgLy8gY2hlY2sgdGhlIGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiB0byB0aGUgZWRnZSBhZ2FpbnN0IHRoZVxuICAgICAgICAvLyBkaXN0YW5jZSBwIGlzIGFsb25nIGVkZ2Uubm9ybWFsXG4gICAgICAgIGRlcHRoID0gdmVjMl9kb3QocCwgZWRnZS5ub3JtYWwpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhtYXgsIFwiZGlzdGFuY2VcIiwgZGVwdGgsIGVkZ2UuZGlzdGFuY2UpO1xuICAgICAgICBpZiAoZGVwdGggLSBlZGdlLmRpc3RhbmNlIDwgTWF0aC5FUFMpIHtcbiAgICAgICAgICAgIC8vIHRoZSB0b2xlcmFuY2Ugc2hvdWxkIGJlIHNvbWV0aGluZyBwb3NpdGl2ZSBjbG9zZSB0byB6ZXJvIChleC4gMC4wMDAwMSlcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGRpZmZlcmVuY2UgaXMgbGVzcyB0aGFuIHRoZSB0b2xlcmFuY2UgdGhlbiB3ZSBjYW5cbiAgICAgICAgICAgIC8vIGFzc3VtZSB0aGF0IHdlIGNhbm5vdCBleHBhbmQgdGhlIHNpbXBsZXggYW55IGZ1cnRoZXIgYW5kXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIG91ciBzb2x1dGlvblxuICAgICAgICAgICAgb3V0X3Jlc3BvbnNlLm10diA9IGVkZ2Uubm9ybWFsO1xuICAgICAgICAgICAgb3V0X3Jlc3BvbnNlLmRlcHRoID0gZGVwdGg7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBlZGdlIG9mIHRoZSBNaW5rb3dza2kgRGlmZmVyZW5jZVxuICAgICAgICAgICAgLy8gc28gY29udGludWUgZXhwYW5kaW5nIGJ5IGFkZGluZyB0aGUgbmV3IHBvaW50IHRvIHRoZSBzaW1wbGV4XG4gICAgICAgICAgICAvLyBpbiBiZXR3ZWVuIHRoZSBwb2ludHMgdGhhdCBtYWRlIHRoZSBjbG9zZXN0IGVkZ2VcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHNpbXBsZXhbZWRnZS5pbmRleF0sIHApO1xuICAgICAgICAgICAgc2ltcGxleC5zcGxpY2UoZWRnZS5pbmRleCwgMCwgcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBFUEE7XG4iLCIvKipcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIEphc3BlciBQYWxmcmVlIGh0dHA6Ly93ZWxsY2FmZmVpbmF0ZWQubmV0L1BoeXNpY3NKUy9cbipcbiogQWRhcHRlZCBhbmQgb3B0aW1pemVkIGJ5IEx1aXMgTGFmdWVudGUgPGxsYWZ1ZW50ZUBub2JveG91dC5jb20+XG4qXG4qIEB0b2RvIHN0cmVzcyB0ZXN0XG4qIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL3dlbGxjYWZmZWluYXRlZC9QaHlzaWNzSlNcbiogQHJlZmVyZW5jZSBodHRwczovL2dpdGh1Yi5jb20vZmVsaXBldGF2YXJlcy9ib21iZXJtYW4vYmxvYi9tYXN0ZXIvd2ViL21vZHVsZXMvY29sbGlzaW9uLmpzXG4qIEByZWZlcmVuY2UgaHR0cDovL3d3dy5jb2RlemVhbG90Lm9yZy9hcmNoaXZlcy84OFxuKiBAcmVmZXJlbmNlIGh0dHA6Ly9tb2xseXJvY2tldC5jb20vODQ5XG4qL1xuXG5cbi8vIHRoZSBhbGdvcml0aG0gZG9lc24ndCBhbHdheXMgY29udmVyZ2UgZm9yIGN1cnZlZCBzaGFwZXMuXG4vLyBuZWVkIHRoZXNlIGNvbnN0YW50cyB0byBkaWN0YXRlIGhvdyBhY2N1cmF0ZSB3ZSB3YW50IHRvIGJlLlxudmFyIEVQUyA9IE1hdGguRVBTLFxuICAgIGFicyA9IE1hdGguYWJzLFxuICAgIGdqa01heEl0ZXJhdGlvbnMgPSAxMDAsXG4gICAgVmVjMiA9IHJlcXVpcmUoXCIuLi92ZWMyLmpzXCIpLFxuICAgIHZlYzJfbGVuZ3RoU3EgPSBWZWMyLmxlbmd0aFNxLFxuICAgIHZlYzJfZG90ID0gVmVjMi5kb3QsXG4gICAgdmVjMl9uZWdhdGUgPSBWZWMyLm5lZ2F0ZSxcbiAgICB2ZWMyX3N1YiA9IFZlYzIuc3ViLFxuICAgIHZlYzJfcGVycCA9IFZlYzIucGVycCxcbiAgICB2ZWMyX3JwZXJwID0gVmVjMi5ycGVycCxcbiAgICB2ZWMyX2NvcHkgPSBWZWMyLmNvcHksXG4gICAgdmVjMl9uZWFyID0gVmVjMi5uZWFyLFxuICAgIHZlYzJfWkVSTyA9IFZlYzIuWkVSTyxcbiAgICB2ZWMyX3NjYWxlID0gVmVjMi5zY2FsZSxcbiAgICB2ZWMyX2FkZCA9IFZlYzIuYWRkLFxuICAgIHZlYzJfbm9ybWFsaXplID0gVmVjMi5ub3JtYWxpemUsXG4gICAgdmVjMl9zd2FwID0gVmVjMi5zd2FwLFxuICAgIHZlYzJfY3Jvc3MgPSBWZWMyLmNyb3NzLFxuICAgIFBvbHlnb24gPSByZXF1aXJlKFwiLi4vcG9seWdvbi5qc1wiKTtcblxuLy8gZ2V0IHRoZSBuZXh0IHNlYXJjaCBkaXJlY3Rpb24gZnJvbSB0d28gc2ltcGxleCBwb2ludHNcbi8qKlxuICogQHBhcmFtIHtWZWMyfSBwdEFcbiAqIEBwYXJhbSB7VmVjMn0gcHRCXG4gKiBAcGFyYW0ge1ZlYzJ9IGRpclxuICovXG5mdW5jdGlvbiBfZ2V0TmV4dFNlYXJjaERpcihwdEEsIHB0QiwgZGlyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkocHRBKSB8fCBwdEFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihwdEFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcHRBWzBdIHx8IHB0QVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHB0QVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBwdEFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgcHRBXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShwdEIpIHx8IHB0QlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHB0QlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBwdEJbMF0gfHwgcHRCWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocHRCWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHB0QlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBwdEJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGRpcikgfHwgZGlyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oZGlyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGRpclswXSB8fCBkaXJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihkaXJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgZGlyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIGRpclwiKVxufVxuXG5cbiAgICB2YXIgQUJkb3RCID0gdmVjMl9sZW5ndGhTcShwdEIpIC0gdmVjMl9kb3QocHRCLCBwdEEpLFxuICAgICAgICBBQmRvdEEgPSB2ZWMyX2RvdChwdEIsIHB0QSkgLSB2ZWMyX2xlbmd0aFNxKHB0QSk7XG5cbiAgICAvLyBpZiB0aGUgb3JpZ2luIGlzIGZhcnRoZXIgdGhhbiBlaXRoZXIgb2YgdGhlc2UgcG9pbnRzXG4gICAgLy8gZ2V0IHRoZSBkaXJlY3Rpb24gZnJvbSBvbmUgb2YgdGhvc2UgcG9pbnRzIHRvIHRoZSBvcmlnaW5cbiAgICBpZiAoQUJkb3RCIDwgMCkge1xuICAgICAgICByZXR1cm4gdmVjMl9uZWdhdGUoZGlyLCBwdEIpO1xuICAgIH0gZWxzZSBpZiAoQUJkb3RBID4gMCkge1xuICAgICAgICByZXR1cm4gdmVjMl9uZWdhdGUoZGlyLCBwdEEpO1xuICAgIC8vIG90aGVyd2lzZSwgdXNlIHRoZSBwZXJwZW5kaWN1bGFyIGRpcmVjdGlvbiBmcm9tIHRoZSBzaW1wbGV4XG4gICAgfVxuXG4gICAgLy8gZGlyID0gQUIgPSBCIC0gQVxuICAgIHZlYzJfc3ViKGRpciwgcHRCLCBwdEEpO1xuICAgIC8vIGlmIChsZWZ0IGhhbmRlZCBjb29yZGluYXRlIHN5c3RlbSlcbiAgICAvLyBBIGNyb3NzIEFCIDwgMCB0aGVuIGdldCBwZXJwZW5kaWN1bGFyIGNvdW50ZXJjbG9ja3dpc2VcbiAgICAvL3JldHVybiBkaXIucGVycCggKHB0QS5jcm9zcyggZGlyICkgPiAwKSApO1xuICAgIHJldHVybiB2ZWMyX3BlcnAoZGlyLCBkaXIpO1xufVxuXG5cbnZhciBnY3BfQSA9IFswLCAwXSxcbiAgICBnY3BfTCA9IFswLCAwXSxcbiAgICBnY3BfYXV4ID0gWzAsIDBdO1xuXG4vKiogaGlkZVxuKiBfZ2V0Q2xvc2VzdFBvaW50cyggc2ltcGxleCApIC0+IE9iamVjdFxuKiAtIHNpbXBsZXggKEFycmF5KTogVGhlIHNpbXBsZXhcbipcbiogRmlndXJlIG91dCB0aGUgY2xvc2VzdCBwb2ludHMgb24gdGhlIG9yaWdpbmFsIG9iamVjdHNcbiogZnJvbSB0aGUgbGFzdCB0d28gZW50cmllcyBvZiB0aGUgc2ltcGxleFxuKiBAcGFyYW0ge1BvbHlnb259IHNpbXBsZXhcbiogQHJldHVybiB7T2JqZWN0fVxuKiovXG5mdW5jdGlvbiBfZ2V0Q2xvc2VzdFBvaW50cyhzaW1wbGV4KSB7XG5cbiAgICAvLyBzZWUgaHR0cDovL3d3dy5jb2RlemVhbG90Lm9yZy9hcmNoaXZlcy8xNTNcbiAgICAvLyBmb3IgYWxnb3JpdGhtIGRldGFpbHNcblxuICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgcG9pbnRcbiAgICAvLyBpcyB2ZXJ5IGNsb3NlIHRvIHRoZSBwcmV2aW91cy4gKGJ5IG5hdHVyZSBvZiB0aGUgZGlzdGFuY2UgdGVzdClcbiAgICAvLyB0aGlzIHdvbid0IGdpdmUgZ3JlYXQgcmVzdWx0cyBmb3IgdGhlIGNsb3Nlc3RcbiAgICAvLyBwb2ludHMgYWxnb3JpdGhtLCBzbyBsZXQncyB1c2UgdGhlIHByZXZpb3VzIHR3b1xuICAgIHZhciBsZW4gPSBzaW1wbGV4Lmxlbmd0aCxcbiAgICAgICAgbGFzdCA9IHNpbXBsZXhbbGVuIC0gMl0sXG4gICAgICAgIHByZXYgPSBzaW1wbGV4W2xlbiAtIDNdLFxuICAgICAgICBsYW1iZGFCLFxuICAgICAgICBsYW1iZGFBO1xuXG4gICAgdmVjMl9jb3B5KGdjcF9BLCBsYXN0KTtcblxuICAgIC8vIEwgPSBCIC0gQVxuICAgIHZlYzJfc3ViKGdjcF9MLCBwcmV2LCBnY3BfQSk7XG5cbiAgICBpZiAodmVjMl9uZWFyKGdjcF9MLCB2ZWMyX1pFUk8sIEVQUykpIHtcbiAgICAgICAgLy8gb2guLiBpdCdzIGEgemVybyB2ZWN0b3IuIFNvIEEgYW5kIEIgYXJlIGJvdGggdGhlIGNsb3Nlc3QuXG4gICAgICAgIC8vIGp1c3QgdXNlIG9uZSBvZiB0aGVtXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiBsYXN0LmEsXG4gICAgICAgICAgICBiOiBsYXN0LmJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBsYW1iZGFCID0gLSB2ZWMyX2RvdChnY3BfTCwgZ2NwX0EpIC8gdmVjMl9sZW5ndGhTcShnY3BfTCk7XG4gICAgbGFtYmRhQSA9IDEgLSBsYW1iZGFCO1xuXG4gICAgaWYgKGxhbWJkYUEgPD0gMCkge1xuICAgICAgICAvLyB3b29wcy4uIHRoYXQgbWVhbnMgdGhlIGNsb3Nlc3Qgc2ltcGxleCBwb2ludFxuICAgICAgICAvLyBpc24ndCBvbiB0aGUgbGluZSBpdCdzIHBvaW50IEIgaXRzZWxmXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiBwcmV2LmEsXG4gICAgICAgICAgICBiOiBwcmV2LmJcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGxhbWJkYUIgPD0gMCkge1xuICAgICAgICAvLyB2aWNlIHZlcnNhXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiBsYXN0LmEsXG4gICAgICAgICAgICBiOiBsYXN0LmJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBndWVzcyB3ZSdkIGJldHRlciBkbyB0aGUgbWF0aCBub3cuLi5cbiAgICB2YXIgYSA9IFswLCAwXSxcbiAgICAgICAgYiA9IFswLCAwXTtcblxuICAgIHZlYzJfc2NhbGUoYSwgbGFzdC5hLCBsYW1iZGFBKTtcbiAgICB2ZWMyX3NjYWxlKGdjcF9hdXgsIHByZXYuYSwgbGFtYmRhQik7XG4gICAgdmVjMl9hZGQoYSwgYSwgZ2NwX2F1eCk7XG5cbiAgICB2ZWMyX3NjYWxlKGIsIGxhc3QuYiwgbGFtYmRhQSk7XG4gICAgdmVjMl9zY2FsZShnY3BfYXV4LCBwcmV2LmIsIGxhbWJkYUIpO1xuICAgIHZlYzJfYWRkKGIsIGIsIGdjcF9hdXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gYSBjbG9zZXN0ID0gbGFtYmRhQSAqIEFhICsgbGFtYmRhQiAqIEJhXG4gICAgICAgIGE6IGEsXG4gICAgICAgIC8vIGIgY2xvc2VzdCA9IGxhbWJkYUEgKiBBYiArIGxhbWJkYUIgKiBCYlxuICAgICAgICBiOiBiXG4gICAgfTtcbn1cblxuLyoqXG4qXG4qIEltcGxlbWVudGF0aW9uIG9mIEdpbGJlcnTigJNKb2huc29u4oCTS2VlcnRoaSAoR0pLKVxuKlxuKlxuKiBSZXR1cm5lZCBvYmplY3RcbipcbiogYGBgamF2YXNjcmlwdFxuKiB7XG4qICAgb3ZlcmxhcDogQm9vbGVhbixcbiogICBzaW1wbGV4OiBQb2x5Z29uLFxuKiAgIGRpc3RhbmNlOiBOdW1iZXIsXG4qICAgY2xvc2VzdDogVmVjMlxuKiB9XG4qIGBgYFxuKiBAdG9kbyBkaXN0YW5jZSBzZWVtIHRvIGJlIG5vdCAxMDAlIHJpZ2h0XG4qIEBwYXJhbSB7UG9seWdvbn0gYV9wb2ludHNcbiogQHBhcmFtIHtQb2x5Z29ufSBiX3BvaW50c1xuKiBAcmV0dXJuIHtPYmplY3R9XG4qKi9cbmZ1bmN0aW9uIGdldFBvbHlnb25Qb2x5Z29uKGFfcG9pbnRzLCBiX3BvaW50cykge1xuXG4gICAgdmFyIG92ZXJsYXAgPSBmYWxzZSxcbiAgICAgICAgbm9PdmVybGFwID0gZmFsc2UsIC8vIGlmIHdlJ3JlIHN1cmUgd2UncmUgbm90IG92ZXJsYXBwaW5nXG4gICAgICAgIGRpc3RhbmNlID0gZmFsc2UsXG4gICAgICAgIHNpbXBsZXggPSBbXSxcbiAgICAgICAgc2ltcGxleExlbiA9IDEsXG4gICAgICAgIC8vIHVzZSBzZWVkIGFzIHN0YXJ0aW5nIGRpcmVjdGlvbiBvciB1c2UgeCBheGlzXG4gICAgICAgIGRpciA9IFswLCAxXSxcbiAgICAgICAgbGFzdCA9IFswLCAwXSxcbiAgICAgICAgbGFzdGxhc3QgPSBbMCwgMF0sXG4gICAgICAgIC8vIHNvbWUgdGVtcCB2ZWN0b3JzXG4gICAgICAgIGFiLFxuICAgICAgICBhYyxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdG1wLFxuICAgICAgICBpdGVyYXRpb25zID0gMCxcbiAgICAgICAgZGVhZCA9IFtdLFxuICAgICAgICBkZWFkbGVuO1xuXG4gICAgLy8gZ2V0IHRoZSBmaXJzdCBNaW5rb3dza2kgRGlmZmVyZW5jZSBwb2ludFxuICAgIC8vdG1wID0gc3VwcG9ydChkaXIpO1xuICAgIHRtcCA9IFBvbHlnb24uZnVydGhlc3RNaW5rb3dza2koWzAsIDBdLCBhX3BvaW50cywgYl9wb2ludHMsIGRpcik7XG4gICAgc2ltcGxleExlbiA9IHNpbXBsZXgucHVzaCh0bXApO1xuICAgIHZlYzJfY29weShsYXN0LCB0bXApO1xuICAgIC8vIG5lZ2F0ZSBkIGZvciB0aGUgbmV4dCBwb2ludFxuICAgIHZlYzJfbmVnYXRlKGRpciwgZGlyKTtcblxuICAgIC8vY29uc29sZS5sb2coXCJzaW1wbGV4XCIsIFBvbHlnb24udG9TdHJpbmcoc2ltcGxleCkpO1xuXG4gICAgLy8gc3RhcnQgbG9vcGluZ1xuICAgIGdqa19lbmQ6XG4gICAgd2hpbGUgKCsraXRlcmF0aW9ucykge1xuXG4gICAgICAgIC8vIHN3YXAgbGFzdCBhbmQgbGFzdGxhc3QsIHRvIHNhdmUgb24gbWVtb3J5L3NwZWVkXG4gICAgICAgIHZlYzJfc3dhcChsYXN0LCBsYXN0bGFzdCk7XG4gICAgICAgIC8vIHB1c2ggYSBuZXcgcG9pbnQgdG8gdGhlIHNpbXBsZXggYmVjYXVzZSB3ZSBoYXZlbid0IHRlcm1pbmF0ZWQgeWV0XG4gICAgICAgIC8vdG1wID0gc3VwcG9ydChkaXIpO1xuICAgICAgICB0bXAgPSBQb2x5Z29uLmZ1cnRoZXN0TWlua293c2tpKFswLCAwXSwgYV9wb2ludHMsIGJfcG9pbnRzLCBkaXIpO1xuICAgICAgICBzaW1wbGV4TGVuID0gc2ltcGxleC5wdXNoKHRtcCk7XG4gICAgICAgIHZlYzJfY29weShsYXN0LCB0bXApO1xuXG4gICAgICAgIC8vPGRlYnVnPlxuICAgICAgICAvL0RyYXcucG9seWdvbihjdHgsIHNpbXBsZXgsIFwicmdiYSgyNTUsIDAsIDAsIDAuMSlcIiwgdHJ1ZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJzaW1wbGV4XCIsIGl0ZXJhdGlvbnMsIFBvbHlnb24udG9TdHJpbmcoc2ltcGxleCksIFwibGFzdFwiLCBWZWMyLnRvU3RyaW5nKGxhc3QpKTtcbiAgICAgICAgLy9AVE9ETyBoaXN0b3J5IVxuICAgICAgICAvLzwvZGVidWc+XG5cbiAgICAgICAgLy8gQFRPRE8gZXhwZXJpbWVudGFsLCBzZWVtcyB0byB3b3JrLCBjb25maXJtIGl0IVxuICAgICAgICBpZiAoZGVhZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYWRsZW4gPSBkZWFkLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoZGVhZGxlbi0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYWRbZGVhZGxlbl1bMF0gPT09IGxhc3RbMF0gJiYgZGVhZFtkZWFkbGVuXVsxXSA9PT0gbGFzdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBnamtfZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHZlYzJfbmVhcihsYXN0LCB2ZWMyX1pFUk8sIEVQUykpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhcHBlbmVkIHRvIHBpY2sgdGhlIG9yaWdpbiBhcyBhIHN1cHBvcnQgcG9pbnQuLi4gbHVja3kuXG4gICAgICAgICAgICBvdmVybGFwID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGxhc3QgcG9pbnQgd2UgYWRkZWQgYWN0dWFsbHkgcGFzc2VkIHRoZSBvcmlnaW5cbiAgICAgICAgaWYgKCFub092ZXJsYXAgJiYgdmVjMl9kb3QobGFzdCwgZGlyKSA8PSAwLjApIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludCBhZGRlZCBsYXN0IHdhcyBub3QgcGFzdCB0aGUgb3JpZ2luIGluIHRoZSBkaXJlY3Rpb24gb2YgZFxuICAgICAgICAgICAgLy8gdGhlbiB0aGUgTWlua293c2tpIGRpZmZlcmVuY2UgY2Fubm90IHBvc3NpYmx5IGNvbnRhaW4gdGhlIG9yaWdpbiBzaW5jZVxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcG9pbnQgYWRkZWQgaXMgb24gdGhlIGVkZ2Ugb2YgdGhlIE1pbmtvd3NraSBEaWZmZXJlbmNlXG5cbiAgICAgICAgICAgIG5vT3ZlcmxhcCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpdCdzIGEgbGluZS4uLlxuICAgICAgICBpZiAoc2ltcGxleExlbiA9PT0gMikge1xuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBkZXRlcm1pbmUgaWYgdGhlIG9yaWdpbiBpcyBpblxuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgc2ltcGxleCBhbmQgYWN0IGFjY29yZGluZ2x5XG5cbiAgICAgICAgICAgIGRpciA9IF9nZXROZXh0U2VhcmNoRGlyKGxhc3QsIGxhc3RsYXN0LCBkaXIpO1xuICAgICAgICAgICAgLy8gY29udGludWUuLi5cblxuICAgICAgICAvLyBpZiBpdCdzIGEgdHJpYW5nbGUuLi4gYW5kIHdlJ3JlIGxvb2tpbmcgZm9yIHRoZSBkaXN0YW5jZVxuICAgICAgICB9IGVsc2UgaWYgKG5vT3ZlcmxhcCkge1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBrbm93IHRoZXJlIGlzbid0IGFueSBvdmVybGFwIGFuZFxuICAgICAgICAgICAgLy8gd2UncmUganVzdCB0cnlpbmcgdG8gZmluZCB0aGUgZGlzdGFuY2UuLi5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSdyZSBnZXR0aW5nIGNsb3NlciB0byB0aGUgb3JpZ2luXG4gICAgICAgICAgICB2ZWMyX25vcm1hbGl6ZShkaXIsIGRpcik7XG4gICAgICAgICAgICB0bXAgPSB2ZWMyX2RvdChsYXN0bGFzdCwgZGlyKTtcblxuICAgICAgICAgICAgaWYgKGFicyh0bXAgLSB2ZWMyX2RvdChsYXN0LCBkaXIpKSA8IEVQUykge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gLXRtcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHN0aWxsIGdldHRpbmcgY2xvc2VyIHRoZW4gb25seSBrZWVwXG4gICAgICAgICAgICAvLyB0aGUgcG9pbnRzIGluIHRoZSBzaW1wbGV4IHRoYXQgYXJlIGNsb3Nlc3QgdG9cbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW4gKHdlIGFscmVhZHkga25vdyB0aGF0IGxhc3QgaXMgY2xvc2VyXG4gICAgICAgICAgICAvLyB0aGFuIHRoZSBwcmV2aW91cyB0d28pXG4gICAgICAgICAgICAvLyB0aGUgbm9ybSBpcyB0aGUgc2FtZSBhcyBkaXN0YW5jZShvcmlnaW4sIGEpXG4gICAgICAgICAgICAvLyB1c2Ugbm9ybSBzcXVhcmVkIHRvIGF2b2lkIHRoZSBzcXJ0IG9wZXJhdGlvbnNcbiAgICAgICAgICAgIGlmICh2ZWMyX2xlbmd0aFNxKGxhc3RsYXN0KSA8IHZlYzJfbGVuZ3RoU3Eoc2ltcGxleFswXSkpIHtcbiAgICAgICAgICAgICAgICBkZWFkLnB1c2goc2ltcGxleC5zaGlmdCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVhZC5wdXNoKHNpbXBsZXguc3BsaWNlKDEsIDEpWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlyID0gX2dldE5leHRTZWFyY2hEaXIoc2ltcGxleFsxXSwgc2ltcGxleFswXSwgZGlyKTtcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlLi4uXG5cbiAgICAgICAgLy8gaWYgaXQncyBhIHRyaWFuZ2xlXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdHJpbSB0aGUgdXNlbGVzcyBwb2ludC4uLlxuXG4gICAgICAgICAgICBhYiA9IGFiIHx8IFswLCAwXTtcbiAgICAgICAgICAgIGFjID0gYWMgfHwgWzAsIDBdO1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGVkZ2VzIEFCIGFuZCBBQ1xuICAgICAgICAgICAgdmVjMl9zdWIoYWIsIGxhc3RsYXN0LCBsYXN0KTtcbiAgICAgICAgICAgIHZlYzJfc3ViKGFjLCBzaW1wbGV4WzBdLCBsYXN0KTtcblxuICAgICAgICAgICAgLy8gaGVyZSBub3JtYWxseSBwZW9wbGUgdGhpbmsgYWJvdXQgdGhpcyBhcyBnZXR0aW5nIG91dHdhcmQgZmFjaW5nXG4gICAgICAgICAgICAvLyBub3JtYWxzIGFuZCBjaGVja2luZyBkb3QgcHJvZHVjdHMuIFNpbmNlIHdlJ3JlIGluIDJEXG4gICAgICAgICAgICAvLyB3ZSBjYW4gYmUgY2xldmVyLi4uXG4gICAgICAgICAgICBzaWduID0gdmVjMl9jcm9zcyhhYiwgYWMpID4gMDtcblxuICAgICAgICAgICAgaWYgKHNpZ24gXiAodmVjMl9jcm9zcyhsYXN0LCBhYikgPiAwKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gb2suLi4gc28gdGhlcmUncyBhbiBYT1IgaGVyZS4uLiBkb24ndCBmcmVhayBvdXRcbiAgICAgICAgICAgICAgICAvLyByZW1lbWJlciBsYXN0ID0gQSA9IC1BT1xuICAgICAgICAgICAgICAgIC8vIGlmIEFCIGNyb3NzIEFDIGFuZCBBTyBjcm9zcyBBQiBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICAgICAgICAgICAgICAvLyB0aGVuIHRoZSBvcmlnaW4gaXMgYWxvbmcgdGhlIG91dHdhcmQgZmFjaW5nIG5vcm1hbCBvZiBBQlxuICAgICAgICAgICAgICAgIC8vIHNvIGlmIEFCIGNyb3NzIEFDIGFuZCBBIGNyb3NzIEFCIGhhdmUgX2RpZmZlcmVudF8gKFhPUikgc2lnbnNcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHRoaXMgaXMgYWxzbyB0aGUgY2FzZS4uLiBzbyB3ZSBwcm9jZWVkLi4uXG5cbiAgICAgICAgICAgICAgICAvLyBwb2ludCBDIGlzIGRlYWQgdG8gdXMgbm93Li4uXG4gICAgICAgICAgICAgICAgZGVhZC5wdXNoKHNpbXBsZXguc2hpZnQoKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IGRlZHVjZWQgdGhhdCB3ZSd2ZSBlbmNsb3NlZCB0aGUgb3JpZ2luXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBrbm93IHdoaWNoIHdheSB0byBsb29rLi4uXG4gICAgICAgICAgICAgICAgLy8gbW9ycGggdGhlIGFiIHZlY3RvciBpbnRvIGl0cyBvdXR3YXJkIGZhY2luZyBub3JtYWxcblxuICAgICAgICAgICAgICAgIC8vYWIucGVycCggIXNpZ24gKTtcbiAgICAgICAgICAgICAgICAvLy8vIHN3YXBcbiAgICAgICAgICAgICAgICAvL2Rpci5zd2FwKCBhYiApO1xuXG4gICAgICAgICAgICAgICAgc2lnbiA/IHZlYzJfcGVycChkaXIsIGFiKSA6IHZlYzJfcnBlcnAoZGlyLCBhYik7XG5cblxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlLi4uXG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBnZXQgdG8gdGhpcyBpZiwgdGhlbiBpdCBtZWFucyB3ZSBjYW4gY29udGludWUgdG8gbG9vayBhbG9uZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSBvdGhlciBvdXR3YXJkIG5vcm1hbCBkaXJlY3Rpb24gKEFDcGVycClcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBzZWUgdGhlIG9yaWdpbi4uLiB0aGVuIHdlIG11c3QgaGF2ZSBpdCBlbmNsb3NlZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaWduIF4gKHZlYzJfY3Jvc3MoYWMsIGxhc3QpID4gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHRoZSBvcmlnaW4gaXMgYWxvbmcgdGhlIG91dHdhcmQgZmFjaW5nIG5vcm1hbFxuICAgICAgICAgICAgICAgIC8vIG9mIEFDOyAoQUNwZXJwKVxuXG4gICAgICAgICAgICAgICAgLy8gcG9pbnQgQiBpcyBkZWFkIHRvIHVzIG5vdy4uLlxuICAgICAgICAgICAgICAgIGRlYWQucHVzaChzaW1wbGV4LnNwbGljZSgxLCAxKVswXSk7XG5cbiAgICAgICAgICAgICAgICAvL2FjLnBlcnAoIHNpZ24gKTtcbiAgICAgICAgICAgICAgICAvLy8vIHN3YXBcbiAgICAgICAgICAgICAgICAvL2Rpci5zd2FwKCBhYiApO1xuXG4gICAgICAgICAgICAgICAgc2lnbiA/IHZlYzJfcnBlcnAoZGlyLCBhYykgOiB2ZWMyX3BlcnAoZGlyLCBhYyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZS4uLlxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBlbmNsb3NlZCB0aGUgb3JpZ2luIVxuICAgICAgICAgICAgICAgIG92ZXJsYXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGZld2YuLi4gdGFrZSBhIGJyZWFrXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3b2FoIG5lbGx5Li4uIHRoYXQncyBhIGxvdCBvZiBpdGVyYXRpb25zLlxuICAgICAgICAvLyBTdG9wIGl0IVxuICAgICAgICBpZiAoaXRlcmF0aW9ucyA+IGdqa01heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2ltcGxleDogc2ltcGxleCxcbiAgICAgICAgICAgICAgICBpdGVyYXRpb25zOiBpdGVyYXRpb25zLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICAgICAgICAgIG1heEl0ZXJhdGlvbnNSZWFjaGVkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG1wID0ge1xuICAgICAgICBvdmVybGFwOiBvdmVybGFwLFxuICAgICAgICBzaW1wbGV4OiBzaW1wbGV4LFxuICAgICAgICBpdGVyYXRpb25zOiBpdGVyYXRpb25zXG4gICAgfTtcblxuICAgIGlmIChkaXN0YW5jZSAhPT0gZmFsc2UpIHtcblxuICAgICAgICB0bXAuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgdG1wLmNsb3Nlc3QgPSBfZ2V0Q2xvc2VzdFBvaW50cyhzaW1wbGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG1wO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRQb2x5Z29uUG9seWdvbjogZ2V0UG9seWdvblBvbHlnb25cbn07IiwiLyoqXG4gKiBAdG9kbyBOT1JNQUxJWkUgT1VUUFVUXG4gKi9cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL3ZlYzIuanNcIiksXG4gICAgUG9seWdvbiA9IHJlcXVpcmUoXCIuLi9wb2x5Z29uLmpzXCIpLFxuICAgIHBvbHlnb25fZnVydGhlc3RQb2ludCA9IFBvbHlnb24uZnVydGhlc3RQb2ludCxcbiAgICBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIGFicyA9IE1hdGguYWJzLFxuICAgIHZlYzJfc3ViID0gVmVjMi5zdWIsXG4gICAgdmVjMl9hZGQgPSBWZWMyLmFkZCxcbiAgICB2ZWMyX2Nsb25lID0gVmVjMi5jbG9uZSxcbiAgICB2ZWMyX2RvdCA9IFZlYzIuZG90LFxuICAgIHZlYzJfc2NhbGUgPSBWZWMyLnNjYWxlLFxuICAgIHZlYzJfbmVnYXRlID0gVmVjMi5uZWdhdGUsXG4gICAgdmVjMl9ub3JtYWxpemUgPSBWZWMyLm5vcm1hbGl6ZSxcbiAgICB2ZWMyX3BlcnAgPSBWZWMyLnBlcnAsXG4gICAgdmVjMl9sZW5ndGhTcSA9IFZlYzIubGVuZ3RoU3EsXG4gICAgdmVjMl9kaXYgPSBWZWMyLmRpdjtcblxudmFyIGwgPSBbMCwgMF0sXG4gICAgciA9IFswLCAwXSxcbiAgICB2ID0gWzAsIDBdO1xuXG4vKipcbiAqIEZpbmQgdGhlIHNlcGFyYXRpbmcgZWRnZSBmb3IgdGhlIGdpdmVuIGRpcmVjdGlvblxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5Z29uXG4gKiBAcGFyYW0ge1ZlYzJ9IG4gbm9ybWFsXG4gKi9cbmZ1bmN0aW9uIF9maW5kU2VwYXJhdGlvbkVkZ2UocG9seWdvbiwgbikge1xuaWYgKCFBcnJheS5pc0FycmF5KG4pIHx8IG5bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihuWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG5bMF0gfHwgblsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG5bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgblsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBuXCIpXG59XG5cblxuICAgIC8vIENvbXB1dGUgZmFydGhlc3QgcG9seWdvbiBwb2ludCBpbiBwYXJ0aWN1bGFyIGRpcmVjdGlvbi5cbiAgICB2YXIgaW5kZXggPSBwb2x5Z29uX2Z1cnRoZXN0UG9pbnQodiwgcG9seWdvbiwgbik7XG5cbiAgICB2YXIgaW5kZXhfcHJldiA9IChpbmRleCArIHBvbHlnb24ubGVuZ3RoIC0gMSkgJSBwb2x5Z29uLmxlbmd0aDtcbiAgICB2YXIgaW5kZXhfbmV4dCA9IChpbmRleCArIDEpICUgcG9seWdvbi5sZW5ndGg7XG5cbiAgICB2YXIgdl9wcmV2ID0gdmVjMl9jbG9uZShwb2x5Z29uW2luZGV4X3ByZXZdKTtcbiAgICB2YXIgdl9uZXh0ID0gdmVjMl9jbG9uZShwb2x5Z29uW2luZGV4X25leHRdKTtcbiAgICB2ZWMyX3N1YihsLCB2LCB2X25leHQpO1xuICAgIHZlYzJfc3ViKHIsIHYsIHZfcHJldik7XG5cbiAgICBpZiAodmVjMl9kb3QociwgbikgPD0gdmVjMl9kb3QobCwgbikpIHtcbiAgICAgICAgcmV0dXJuIFt2X3ByZXYsIHZlYzJfY2xvbmUodildO1xuICAgIH1cblxuICAgIHJldHVybiBbdmVjMl9jbG9uZSh2KSwgdl9uZXh0XTtcbn1cblxudmFyIGRlbHRhID0gWzAsIDBdLFxuICAgIF9wID0gWzAsIDBdO1xuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcGFyYW0ge1ZlYzJ9IG5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvXG4gKi9cbmZ1bmN0aW9uIF9jbGlwTGluZVNlZ21lbnQodjEsIHYyLCBuLCBvKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjIpIHx8IHYyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMF0gfHwgdjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobikgfHwgblswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG5bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgblswXSB8fCBuWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oblsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBuWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG5cIilcbn1cblxuaWYgKG8gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICB2YXIgZDEgPSB2ZWMyX2RvdChuLCB2MSkgLSBvO1xuICAgIHZhciBkMiA9IHZlYzJfZG90KG4sIHYyKSAtIG87XG4gICAgdmFyIGNwID0gW107XG5cbiAgICBpZiAoZDEgPj0gMCkge1xuICAgICAgICBjcC5wdXNoKHYxKTtcbiAgICB9XG5cbiAgICBpZiAoZDIgPj0gMCkge1xuICAgICAgICBjcC5wdXNoKHYyKTtcbiAgICB9XG5cbiAgICBpZiAoZDEgKiBkMiA8IDApIHtcbiAgICAgICAgdmVjMl9zdWIoZGVsdGEsIHYyLCB2MSk7XG4gICAgICAgIHZhciBwID0gdmVjMl9hZGQoWzAsIDBdLCB2MSwgdmVjMl9zY2FsZShfcCwgZGVsdGEsIGQxIC8gKGQxIC0gZDIpKSk7XG4gICAgICAgIGNwLnB1c2gocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNwO1xufVxudmFyIGNjcF9ubiA9IFswLCAwXSxcbiAgICBlMWQgPSBbMCwgMF0sXG4gICAgZTJkID0gWzAsIDBdLFxuICAgIHJlZl9uID0gWzAsIDBdLFxuICAgIHJlZl9ubiA9IFswLCAwXSxcbiAgICByZWZfcGVycCA9IFswLCAwXTtcbi8qKlxuICogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20vanVobC9jb2xsaXNpb24tZGV0ZWN0aW9uLTJkXG4gKiBAcGFyYW0ge1BvbHlnb259IGFfcG9pbnRzXG4gKiBAcGFyYW0ge1BvbHlnb259IGJfcG9pbnRzXG4gKiBAcGFyYW0ge1ZlYzJ9IG4gbm9ybWFsXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIEVkZ2VDbGlwcGluZyhhX3BvaW50cywgYl9wb2ludHMsIG4pIHtcbmlmICghQXJyYXkuaXNBcnJheShuKSB8fCBuWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oblswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBuWzBdIHx8IG5bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihuWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG5bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgblwiKVxufVxuXG4gICAgdmFyIGUxID0gX2ZpbmRTZXBhcmF0aW9uRWRnZShhX3BvaW50cywgbik7XG4gICAgdmVjMl9uZWdhdGUoY2NwX25uLCBuKTtcbiAgICB2YXIgZTIgPSBfZmluZFNlcGFyYXRpb25FZGdlKGJfcG9pbnRzLCBjY3Bfbm4pO1xuXG5cbiAgICB2ZWMyX3N1YihlMWQsIGUxWzFdLCBlMVswXSk7XG4gICAgdmVjMl9zdWIoZTJkLCBlMlsxXSwgZTJbMF0pO1xuXG4gICAgdmFyIHJlZjtcbiAgICB2YXIgaW5jO1xuICAgIHZhciBmbGlwO1xuXG4gICAgLy8gVGhlIHJlZmVyZW5jZSBlZGdlIGlzIHRoZSBlZGdlIG1vc3QgcGVycGVuZGljdWxhciB0byB0aGUgc2VwYXJhdGlvbiBub3JtYWwuXG4gICAgLy8gU28gYXMgdG8gc2VwYXJhdGUgYm90aCBwb2x5Z29ucyBhcyBsaXR0bGUgYXMgcG9zc2libGUuXG4gICAgdmFyIGVuMSA9IGFicyh2ZWMyX2RvdChlMWQsIG4pKTtcbiAgICB2YXIgZW4yID0gYWJzKHZlYzJfZG90KGUyZCwgbikpO1xuICAgIGlmIChlbjEgPD0gZW4yKSB7XG4gICAgICAgIHJlZiA9IGUxO1xuICAgICAgICB2ZWMyX25vcm1hbGl6ZShyZWZfbiwgZTFkKTtcbiAgICAgICAgaW5jID0gZTI7XG4gICAgICAgIGZsaXAgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZWYgPSBlMjtcbiAgICAgICAgdmVjMl9ub3JtYWxpemUocmVmX24sIGUyZCk7XG4gICAgICAgIGluYyA9IGUxO1xuICAgICAgICBmbGlwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDbGlwIGluY2lkZW50IGVkZ2UgdmVydGljZXMgdXNpbmcgcmVmZXJlbmNlIGVkZ2UgdjFcbiAgICB2YXIgbzEgPSB2ZWMyX2RvdChyZWZfbiwgcmVmWzBdKTtcbiAgICB2YXIgdiA9IF9jbGlwTGluZVNlZ21lbnQoaW5jWzBdLCBpbmNbMV0sIHJlZl9uLCBvMSk7XG4gICAgaWYgKHYubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDbGlwIGluY2lkZW50IGVkZ2UgdmVydGljZXMgdXNpbmcgcmVmZXJlbmNlIGVkZ2UgdjJcbiAgICB2YXIgbzIgPSB2ZWMyX2RvdChyZWZfbiwgcmVmWzFdKTtcbiAgICB2ZWMyX25lZ2F0ZShyZWZfbm4sIHJlZl9uKTtcbiAgICB2ID0gX2NsaXBMaW5lU2VnbWVudCh2WzBdLCB2WzFdLCByZWZfbm4sIC1vMik7XG4gICAgaWYgKHYubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2ZWMyX3BlcnAocmVmX3BlcnAsIHJlZl9uKTtcblxuICAgIGlmIChmbGlwKSB7XG4gICAgICAgIHZlYzJfbmVnYXRlKHJlZl9wZXJwLCByZWZfcGVycCk7XG4gICAgfVxuXG4gICAgdmFyIGNwID0gW107XG4gICAgdmFyIG1heCA9IHZlYzJfZG90KHJlZl9wZXJwLCByZWZbMF0pO1xuICAgIHZhciBkZXB0aDAgPSB2ZWMyX2RvdChyZWZfcGVycCwgdlswXSkgLSBtYXg7XG4gICAgdmFyIGRlcHRoMSA9IHZlYzJfZG90KHJlZl9wZXJwLCB2WzFdKSAtIG1heDtcblxuICAgIGlmIChkZXB0aDAgPj0gMCkge1xuICAgICAgICBjcC5wdXNoKHtwb2ludDogdmVjMl9jbG9uZSh2WzBdKSwgbm9ybWFsOiB2ZWMyX2Nsb25lKG4pLCBkZXB0aDogLWRlcHRoMH0pO1xuICAgIH1cblxuICAgIGlmIChkZXB0aDEgPj0gMCkge1xuICAgICAgICBjcC5wdXNoKHtwb2ludDogdmVjMl9jbG9uZSh2WzFdKSwgbm9ybWFsOiB2ZWMyX2Nsb25lKG4pLCBkZXB0aDogLWRlcHRoMX0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRhY3RzOiBjcCwgaW5jaWRlbnRfZWRnZTogaW5jLCByZWZlcmVuY2VfZWRnZTogcmVmIH07XG59XG5cblxudmFyIGNjX24gPSBbMCwgMF07XG4vKipcbiAqIEBzb3VyY2UgaHR0cDovL3d3dy5yYW5keWdhdWwubmV0LzIwMTMvMDMvMjgvY3VzdG9tLXBoeXNpY3MtZW5naW5lLXBhcnQtMi1tYW5pZm9sZC1nZW5lcmF0aW9uL1xuICogQHBhcmFtIHtDaXJjbGV9IGFfY2lyY2xlXG4gKiBAcGFyYW0ge0NpcmNsZX0gYl9jaXJjbGVcbiAqL1xuZnVuY3Rpb24gQ2lyY2xlQ2lyY2xlKGFfY2lyY2xlLCBiX2NpcmNsZSkge1xuICAgIC8vIFNldHVwIGEgY291cGxlIHBvaW50ZXJzIHRvIGVhY2ggb2JqZWN0XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBBIHRvIEJcbiAgICB2ZWMyX3N1YihjY19uLCBiX2NpcmNsZVswXSwgYV9jaXJjbGVbMF0pO1xuXG4gICAgdmFyIHIgPSBiX2NpcmNsZVsxXSArIGFfY2lyY2xlWzFdO1xuICAgIHIgKj0gcjtcblxuICAgIHZhciBsZW5ndGhfc3EgPSB2ZWMyX2xlbmd0aFNxKGNjX24pO1xuICAgIGlmIChsZW5ndGhfc3EgPiByKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaXJjbGVzIGhhdmUgY29sbGlkZWQsIG5vdyBjb21wdXRlIG1hbmlmb2xkXG4gICAgdmFyIGQgPSBzcXJ0KGxlbmd0aF9zcSk7IC8vIHBlcmZvcm0gYWN0dWFsIHNxcnRcblxuICAgIC8vIElmIGRpc3RhbmNlIGJldHdlZW4gY2lyY2xlcyBpcyBub3QgemVyb1xuICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIC8vIERpc3RhbmNlIGlzIGRpZmZlcmVuY2UgYmV0d2VlbiByYWRpdXMgYW5kIGRpc3RhbmNlXG4gICAgICAgIHZhciBub3JtYWwgPSB2ZWMyX2RpdihbMCwgMF0sIGNjX24sIGQpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB2ZWMyX3NjYWxlKFswLCAwXSwgbm9ybWFsICogYV9jaXJjbGVbMV0pO1xuICAgICAgICB2ZWMyX2FkZChwb3NpdGlvbiwgcG9zaXRpb24sIGFfY2lyY2xlWzBdKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGVuZXRyYXRpb246IHIgLSBkLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgbm9ybWFsOiBub3JtYWxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaXJjbGVzIGFyZSBvbiBzYW1lIHBvc2l0aW9uXG4gICAgLy8gQ2hvb3NlIHJhbmRvbSAoYnV0IGNvbnNpc3RlbnQpIHZhbHVlc1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiBhX2NpcmNsZVswXSxcbiAgICAgICAgcGVuZXRyYXRpb246IGFfY2lyY2xlWzFdLFxuICAgICAgICBub3JtYWw6IFsxLCAwXVxuICAgIH07XG59XG5cbi8qXG5FZGdlQ2xpcHBpbmcoXG4gICAgW1s4LCA0XSwgWzE0LCA0XSwgWzgsIDEwXSwgWzE0LCAxMF1dLFxuICAgIFtbMTIsIDVdLCBbNCwgNV0sIFsxMiwgMF0sIFs0LCAwXV0sXG4gICAgWzAsIC0xXVxuKTtcblxucHJvY2Vzcy5leGl0KCk7XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBFZGdlQ2xpcHBpbmc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRWRnZUNsaXBwaW5nOiBFZGdlQ2xpcHBpbmcsXG4gICAgQ2lyY2xlQ2lyY2xlOiBDaXJjbGVDaXJjbGUsXG5cblxuICAgIC8vIGFsaWFzXG4gICAgUG9seWdvblBvbHlnb246IEVkZ2VDbGlwcGluZ1xufTtcbiIsInZhciBWZWMyID0gcmVxdWlyZShcIi4uL3ZlYzIuanNcIiksXG4gICAgdmVjMl9zY2FsZSA9IFZlYzIuc2NhbGUsXG4gICAgdmVjMl9kb3QgPSBWZWMyLmRvdCxcbiAgICB2ZWMyX3N1YiA9IFZlYzIuc3ViLFxuICAgIGFicyA9IE1hdGguYWJzLFxuICAgIG1heCA9IE1hdGgubWF4LFxuICAgIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgIGNvcyA9IE1hdGguY29zLFxuICAgIHNpbiA9IE1hdGguc2luLFxuICAgIEhBTEZfUEkgPSBNYXRoLkhBTEZfUEk7XG5cbnZhciBtdHZfdiA9IFswLCAwXTtcbi8qKlxuICogS2VlcCB5b3VyIG9iamVjdCBvdXRzaWRlIHRoZSBvdGhlclxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3Bvc2l0aW9uXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWxvY2l0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHBlbmV0cmF0aW9uX2RlcHRoXG4gKiBAcGFyYW0ge1ZlYzJ9IG10dlxuICovXG5mdW5jdGlvbiBvdXRzaWRlKG91dF9wb3NpdGlvbiwgb3V0X3ZlbG9jaXR5LCBwZW5ldHJhdGlvbl9kZXB0aCwgbXR2KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3Bvc2l0aW9uKSB8fCBvdXRfcG9zaXRpb25bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfcG9zaXRpb25bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3Bvc2l0aW9uWzBdIHx8IG91dF9wb3NpdGlvblsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF9wb3NpdGlvblsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfcG9zaXRpb25bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3Bvc2l0aW9uXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVsb2NpdHkpIHx8IG91dF92ZWxvY2l0eVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWxvY2l0eVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVsb2NpdHlbMF0gfHwgb3V0X3ZlbG9jaXR5WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlbG9jaXR5WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWxvY2l0eVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVsb2NpdHlcIilcbn1cblxuaWYgKHBlbmV0cmF0aW9uX2RlcHRoID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocGVuZXRyYXRpb25fZGVwdGgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcGVuZXRyYXRpb25fZGVwdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwZW5ldHJhdGlvbl9kZXB0aCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobXR2KSB8fCBtdHZbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtdHZbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbXR2WzBdIHx8IG10dlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG10dlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtdHZbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgbXR2XCIpXG59XG5cbiAgICB2ZWMyX3NjYWxlKG10dl92LCBtdHYsIHBlbmV0cmF0aW9uX2RlcHRoKTtcbiAgICAvLyBsZWZ0LXJpZ2h0IHBlbmV0cmF0aW9uXG4gICAgaWYgKG10dl92WzBdICE9PSAwKSB7XG4gICAgICAgIG91dF9wb3NpdGlvblswXSA9IG10dl92WzBdO1xuICAgICAgICBvdXRfdmVsb2NpdHlbMF0gPSAwO1xuICAgIH1cblxuICAgIC8vIHVwLWRvd24gcGVuZXRyYXRpb25cbiAgICBpZiAobXR2X3ZbMV0gIT09IDApIHtcbiAgICAgICAgb3V0X3Bvc2l0aW9uWzFdID0gbXR2X3ZbMV07XG4gICAgICAgIG91dF92ZWxvY2l0eVsxXSA9IG1heChvdXRfdmVsb2NpdHlbMV0sIDApO1xuICAgIH1cbn1cblxudmFyIGF1eF92ZWMyID0gWzAsIDBdLFxuICAgIGNvbF9pbXB1bHNlID0gWzAsIDBdLFxuICAgIGZyaWNfaW1wdWxzZSA9IFswLCAwXSxcbiAgICBpbXB1bHNlID0gWzAsIDBdLFxuICAgIHRhbmdlbnRfdmVsID0gWzAsIDBdLFxuICAgIHJ2ID0gWzAsIDBdO1xuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF9hX3ZlbG9jaXR5IFZlbG9jaXR5IG9mIEFcbiAqIEBwYXJhbSB7TnVtYmVyfSBhX3Jlc3RpdHV0aW9uIENvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uIG9mIEFcbiAqIEBwYXJhbSB7TnVtYmVyfSBhX2ltYXNzIEludmVyc2UgbWFzcyBvZiBBXG4gKiBAcGFyYW0ge051bWJlcn0gYV9wb2ludCBQb2ludCBvZiBjb2xsaXNpb24gaW4gQVxuICogQHBhcmFtIHtWZWMyfSBvdXRfYl92ZWxvY2l0eSBWZWxvY2l0eSBvZiBCXG4gKiBAcGFyYW0ge051bWJlcn0gYl9yZXN0aXR1dGlvbiBDb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiBCXG4gKiBAcGFyYW0ge051bWJlcn0gYl9pbWFzcyBJbnZlcnNlIG1hc3Mgb2YgQlxuICogQHBhcmFtIHtOdW1iZXJ9IGJfcG9pbnQgUG9pbnQgb2YgY29sbGlzaW9uIGluIEJcbiAqIEBwYXJhbSB7VmVjMn0gbm9ybWFsIGNvbGxpc2lvblxuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBpcyB0aGUgdmVsb2NpdHkgbW9kaWZpZWQgP1xuICovXG5mdW5jdGlvbiBsaW5lYXIob3V0X2FfdmVsb2NpdHksIGFfcmVzdGl0dXRpb24sIGFfaW1hc3MsIGFfcG9pbnQsIG91dF9iX3ZlbG9jaXR5LCBiX3Jlc3RpdHV0aW9uLCBiX2ltYXNzLCBiX3BvaW50LCBub3JtYWwpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfYV92ZWxvY2l0eSkgfHwgb3V0X2FfdmVsb2NpdHlbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfYV92ZWxvY2l0eVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfYV92ZWxvY2l0eVswXSB8fCBvdXRfYV92ZWxvY2l0eVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF9hX3ZlbG9jaXR5WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF9hX3ZlbG9jaXR5WzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF9hX3ZlbG9jaXR5XCIpXG59XG5cbmlmIChhX3Jlc3RpdHV0aW9uID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYV9yZXN0aXR1dGlvbikgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhX3Jlc3RpdHV0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYV9yZXN0aXR1dGlvbiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoYV9pbWFzcyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFfaW1hc3MpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYV9pbWFzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFfaW1hc3MgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGFfcG9pbnQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhX3BvaW50KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFfcG9pbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhX3BvaW50IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShvdXRfYl92ZWxvY2l0eSkgfHwgb3V0X2JfdmVsb2NpdHlbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfYl92ZWxvY2l0eVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfYl92ZWxvY2l0eVswXSB8fCBvdXRfYl92ZWxvY2l0eVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF9iX3ZlbG9jaXR5WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF9iX3ZlbG9jaXR5WzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF9iX3ZlbG9jaXR5XCIpXG59XG5cbmlmIChiX3Jlc3RpdHV0aW9uID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYl9yZXN0aXR1dGlvbikgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiX3Jlc3RpdHV0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYl9yZXN0aXR1dGlvbiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoYl9pbWFzcyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJfaW1hc3MpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYl9pbWFzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJfaW1hc3MgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGJfcG9pbnQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiX3BvaW50KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJfcG9pbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiX3BvaW50IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShub3JtYWwpIHx8IG5vcm1hbFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG5vcm1hbFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBub3JtYWxbMF0gfHwgbm9ybWFsWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obm9ybWFsWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG5vcm1hbFsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBub3JtYWxcIilcbn1cblxuICAgIC8vIENhbGN1bGF0ZSByZWxhdGl2ZSB2ZWxvY2l0eVxuICAgIHZlYzJfc3ViKHJ2LCBvdXRfYl92ZWxvY2l0eSwgb3V0X2FfdmVsb2NpdHkpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHJlbGF0aXZlIHZlbG9jaXR5IGluIHRlcm1zIG9mIHRoZSBub3JtYWwgZGlyZWN0aW9uXG4gICAgdmFyIG5vcm1hbF92ZWwgPSB2ZWMyX2RvdChydiwgbm9ybWFsKTtcblxuICAgIC8vIERvIG5vdCByZXNvbHZlIGlmIHZlbG9jaXRpZXMgYXJlIHNlcGFyYXRpbmdcbiAgICBpZiAobm9ybWFsX3ZlbCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSByZXN0aXR1dGlvblxuICAgIHZhciBlID0gTWF0aC5taW4oYV9yZXN0aXR1dGlvbiwgYl9yZXN0aXR1dGlvbik7XG5cbiAgICAvLyBDYWxjdWxhdGUgaW1wdWxzZSBzY2FsYXJcbiAgICB2YXIgaiA9IC0oMSArIGUpICogbm9ybWFsX3ZlbDtcbiAgICBqIC89IGFfaW1hc3MgKyBiX2ltYXNzO1xuXG4gICAgLy8gQXBwbHkgaW1wdWxzZVxuICAgIFZlYzIuc2NhbGUoY29sX2ltcHVsc2UsIG5vcm1hbCwgaik7XG5cbiAgICAvL3J2IC0gRG90KCBydiwgbm9ybWFsICkgKiBub3JtYWxcbiAgICB2ZWMyX3N1Yih0YW5nZW50X3ZlbCwgcnYsIFZlYzIuc2NhbGUodGFuZ2VudF92ZWwsIG5vcm1hbCwgbm9ybWFsX3ZlbCkpO1xuICAgIFZlYzIubm9ybWFsaXplKHRhbmdlbnRfdmVsLCB0YW5nZW50X3ZlbCk7XG5cbiAgICAvLyBTb2x2ZSBmb3IgbWFnbml0dWRlIHRvIGFwcGx5IGFsb25nIHRoZSBmcmljdGlvbiB2ZWN0b3JcbiAgICB2YXIganQgPSAtdmVjMl9kb3QocnYsIHRhbmdlbnRfdmVsKTtcbiAgICBqdCAvPSBhX2ltYXNzICsgYl9pbWFzcztcblxuICAgIHZhciBhX3NmcmljdGlvbiA9IDAuMjtcbiAgICB2YXIgYl9zZnJpY3Rpb24gPSAwLjI7XG5cbiAgICB2YXIgYV9kZnJpY3Rpb24gPSAwLjI7XG4gICAgdmFyIGJfZGZyaWN0aW9uID0gMC4yO1xuXG4gICAgLy8gUHl0aGFnb3JlYW5Tb2x2ZSA9IEFeMiArIEJeMiA9IENeMiwgc29sdmluZyBmb3IgQyBnaXZlbiBBIGFuZCBCXG4gICAgLy8gVXNlIHRvIGFwcHJveGltYXRlIG11IGdpdmVuIGZyaWN0aW9uIGNvZWZmaWNpZW50cyBvZiBlYWNoIGJvZHlcbiAgICB2YXIgbXUgPSBzcXJ0KGFfc2ZyaWN0aW9uICogYV9zZnJpY3Rpb24gKyBiX3NmcmljdGlvbiAqIGJfc2ZyaWN0aW9uKTtcblxuICAgIC8vIENsYW1wIG1hZ25pdHVkZSBvZiBmcmljdGlvbiBhbmQgY3JlYXRlIGltcHVsc2UgdmVjdG9yXG4gICAgaWYgKGFicyhqdCkgPCBqICogbXUpIHtcbiAgICAgICAgVmVjMi5zY2FsZShmcmljX2ltcHVsc2UsIHRhbmdlbnRfdmVsLCBqdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGR5bmFtaWNGcmljdGlvbiA9IHNxcnQoYV9kZnJpY3Rpb24gKiBhX2RmcmljdGlvbiArIGJfZGZyaWN0aW9uICogYl9kZnJpY3Rpb24pO1xuICAgICAgICAvL2ZyaWN0aW9uSW1wdWxzZSA9IC1qICogdCAqIGR5bmFtaWNGcmljdGlvblxuICAgICAgICBWZWMyLnNjYWxlKGZyaWNfaW1wdWxzZSwgdGFuZ2VudF92ZWwsIC1qdCAqIGR5bmFtaWNGcmljdGlvbik7XG4gICAgfVxuXG4gICAgVmVjMi5hZGQoaW1wdWxzZSwgY29sX2ltcHVsc2UsIGZyaWNfaW1wdWxzZSk7XG5cbiAgICBpZiAoYV9pbWFzcyAhPT0gMCkge1xuICAgICAgICB2ZWMyX3N1YihvdXRfYV92ZWxvY2l0eSwgb3V0X2FfdmVsb2NpdHksIFZlYzIuc2NhbGUoYXV4X3ZlYzIsIGltcHVsc2UsIGFfaW1hc3MpKTtcbiAgICB9XG5cbiAgICBpZiAoYl9pbWFzcyAhPT0gMCkge1xuICAgICAgICBWZWMyLmFkZChvdXRfYl92ZWxvY2l0eSwgb3V0X2JfdmVsb2NpdHksIFZlYzIuc2NhbGUoYXV4X3ZlYzIsIGltcHVsc2UsIGJfaW1hc3MpKTtcbiAgICB9XG5cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbi8qXG4gKiBQZXJmb3JtIGEgZnVsbHkgZWxhc3RpYyBjb2xsaXNpb24gYmV0d2VlbiB0aGUgdHdvIG9iamVjdHNcbiAqIEByZWZlcmVuY2UgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbGFzdGljX2NvbGxpc2lvblxuICogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20vYmVubXVycmVsbC9ub2RlLW11bHRpcGxheWVyLWFzdGVyb2lkc1xuICpcbiAqIEBwYXJhbSB7VmVjMn0gYV9wb3NcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X2FfdmVsb2NpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBhX21hc3NcbiAqIEBwYXJhbSB7VmVjMn0gYl9wb3NcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X2JfdmVsb2NpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBiX21hc3NcbiAqL1xuZnVuY3Rpb24gZWxhc3RpYyhhX3Bvcywgb3V0X2FfdmVsb2NpdHksIGFfbWFzcywgYl9wb3MsIG91dF9iX3ZlbG9jaXR5LCBiX21hc3MpIHtcbmlmICghQXJyYXkuaXNBcnJheShhX3BvcykgfHwgYV9wb3NbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhX3Bvc1swXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhX3Bvc1swXSB8fCBhX3Bvc1sxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFfcG9zWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFfcG9zWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIGFfcG9zXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShvdXRfYV92ZWxvY2l0eSkgfHwgb3V0X2FfdmVsb2NpdHlbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfYV92ZWxvY2l0eVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfYV92ZWxvY2l0eVswXSB8fCBvdXRfYV92ZWxvY2l0eVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF9hX3ZlbG9jaXR5WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF9hX3ZlbG9jaXR5WzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF9hX3ZlbG9jaXR5XCIpXG59XG5cbmlmIChhX21hc3MgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhX21hc3MpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYV9tYXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYV9tYXNzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShiX3BvcykgfHwgYl9wb3NbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiX3Bvc1swXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiX3Bvc1swXSB8fCBiX3Bvc1sxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJfcG9zWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJfcG9zWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIGJfcG9zXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShvdXRfYl92ZWxvY2l0eSkgfHwgb3V0X2JfdmVsb2NpdHlbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfYl92ZWxvY2l0eVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfYl92ZWxvY2l0eVswXSB8fCBvdXRfYl92ZWxvY2l0eVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF9iX3ZlbG9jaXR5WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF9iX3ZlbG9jaXR5WzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF9iX3ZlbG9jaXR5XCIpXG59XG5cbmlmIChiX21hc3MgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiX21hc3MpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYl9tYXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYl9tYXNzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICAvLyBEZXRlcm1pbmUgY29udGFjdCBhbmdsZVxuICAgIHZhciBjb250YWN0QW5nbGUgPSBhdGFuMihhX3Bvc1sxXSAtIGJfcG9zWzFdLCBhX3Bvc1swXSAtIGJfcG9zWzBdKTtcblxuICAgIC8vIERldGVybWluZSB2ZWxvY2l0aWVzIGFmdGVyIGNvbGxpc2lvblxuICAgIHZhciB2TGVmdCA9IHNxcnQob3V0X2FfdmVsb2NpdHlbMF0gKiBvdXRfYV92ZWxvY2l0eVswXSArIG91dF9hX3ZlbG9jaXR5WzFdICogb3V0X2FfdmVsb2NpdHlbMV0pO1xuICAgIHZhciB0aGV0YUxlZnQgPSBhdGFuMihvdXRfYV92ZWxvY2l0eVsxXSwgb3V0X2FfdmVsb2NpdHlbMF0pO1xuXG4gICAgdmFyIHZSaWdodCA9IHNxcnQob3V0X2JfdmVsb2NpdHlbMF0gKiBvdXRfYl92ZWxvY2l0eVswXSArIG91dF9iX3ZlbG9jaXR5WzFdICogb3V0X2JfdmVsb2NpdHlbMV0pO1xuICAgIHZhciB0aGV0YVJpZ2h0ID0gYXRhbjIob3V0X2JfdmVsb2NpdHlbMV0sIG91dF9iX3ZlbG9jaXR5WzBdKTtcblxuICAgIHZhciBsY190Y2EgPSBjb3ModGhldGFMZWZ0IC0gY29udGFjdEFuZ2xlKSxcbiAgICAgICAgcmNfdGNhID0gY29zKHRoZXRhUmlnaHQgLSBjb250YWN0QW5nbGUpLFxuICAgICAgICBsc190Y2EgPSBzaW4odGhldGFMZWZ0IC0gY29udGFjdEFuZ2xlKSxcbiAgICAgICAgcnNfdGNhID0gc2luKHRoZXRhUmlnaHQgLSBjb250YWN0QW5nbGUpLFxuICAgICAgICBjQ29udGFjdEFuZ2xlID0gY29zKGNvbnRhY3RBbmdsZSksXG4gICAgICAgIHNDb250YWN0QW5nbGUgPSBzaW4oY29udGFjdEFuZ2xlKSxcbiAgICAgICAgbWFzc19zdW0gPSAoYV9tYXNzICsgYl9tYXNzKSxcbiAgICAgICAgbG1hc3NfZGlmID0gKGFfbWFzcyAtIGJfbWFzcyksXG4gICAgICAgIHJtYXNzX2RpZiA9IChiX21hc3MgLSBhX21hc3MpLFxuICAgICAgICBsZWZ0X251bSA9ICh2TGVmdCAqIGxjX3RjYSAqIGxtYXNzX2RpZiArIDIgKiBiX21hc3MgKiB2UmlnaHQgKiByY190Y2EpLFxuICAgICAgICByaWdodF9udW0gPSAodlJpZ2h0ICogcmNfdGNhICogcm1hc3NfZGlmICsgMiAqIGFfbWFzcyAqIHZMZWZ0ICogbGNfdGNhKTtcblxuICAgIC8vIGVsYXN0aWMgY29sbGlzaW9uIHdpdGggbWFzc1xuICAgIG91dF9hX3ZlbG9jaXR5WzBdID0gbGVmdF9udW0gLyBtYXNzX3N1bSAqIGNDb250YWN0QW5nbGUgKyB2TGVmdCAqIGxzX3RjYSAqIGNvcyhjb250YWN0QW5nbGUgKyBIQUxGX1BJKTtcbiAgICBvdXRfYV92ZWxvY2l0eVsxXSA9IGxlZnRfbnVtIC8gbWFzc19zdW0gKiBzQ29udGFjdEFuZ2xlICsgdkxlZnQgKiBsc190Y2EgKiBzaW4oY29udGFjdEFuZ2xlICsgSEFMRl9QSSk7XG5cbiAgICBvdXRfYl92ZWxvY2l0eVswXSA9IHJpZ2h0X251bSAvIG1hc3Nfc3VtICogY0NvbnRhY3RBbmdsZSArIHZSaWdodCAqIHJzX3RjYSAqIGNvcyhjb250YWN0QW5nbGUgKyBIQUxGX1BJKTtcbiAgICBvdXRfYl92ZWxvY2l0eVsxXSA9IHJpZ2h0X251bSAvIG1hc3Nfc3VtICogc0NvbnRhY3RBbmdsZSArIHZSaWdodCAqIHJzX3RjYSAqIHNpbihjb250YWN0QW5nbGUgKyBIQUxGX1BJKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZWxhc3RpYzogZWxhc3RpYyxcbiAgICBvdXRzaWRlOiBvdXRzaWRlLFxuICAgIGxpbmVhcjogbGluZWFyXG59O1xuIiwiLyoqXG4gKiBSZXN1bHQgb2YgYW4gaW50ZXJzZWN0aW9uLlxuICogVXNlIGNyZWF0ZSBvciBuZXcsIGluc3RhbmNlcyBzdXBwb3J0IGluc3RhbmNlb2YgQ29sbGlzaW9uLlJlc3BvbnNlXG4gKlxuICogKiAqKmEqKiBmaXJzdCBvYmplY3QgcGFydGljaXBhdGluZ1xuICogKiAqKmIqKiBzZWNvbmQgb2JqZWN0IHBhcnRpY2lwYXRpbmdcbiAqICogKiphSW5CKiogSXMgYSBpbnNpZGUgYSAob25seSBTQVQpXG4gKiAqICoqYkluQSoqIElzIGIgaW5zaWRlIGEgKG9ubHkgU0FUKVxuICogKiAqKmRlcHRoKiogcGVuZXRyYXRpb24gYW1vdW50XG4gKiAqICoqbXR2KiogTWluaW11bSB0cmFuc2xhdGUgdmVjdG9yICgqKm5vcm1hbGl6ZWQqKikuIElmIHlvdSBzdWJ0cmFjdCBtdHYgKiBkZXB0aCB0byBhLCB0aGVyZSB3aWxsIGJlIG5vIGNvbGxpc2lvbi5cbiAqICogKipub3JtYWwqKiBObyB1c2VkIGF0IHRoaXMgbW9tZW50LiBUaGlzIHdpbGwgYmUgdXNlZCBpbiBtYW5pZm9sZCBnZW5lcmF0aW9uLlxuICogKiAqKnBvYyoqIE5vIHVzZWQgYXQgdGhpcyBtb21lbnQuIFBvaW50IG9mIGNvbGxpc2lvbi4gVGhpcyB3aWxsIGJlIHVzZWQgaW4gbWFuaWZvbGQgZ2VuZXJhdGlvbi5cbiAqL1xudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vdmVjMi5qc1wiKSxcbiAgICB2ZWMyX3NjYWxlID0gVmVjMi5zY2FsZTtcblxuZnVuY3Rpb24gUmVzcG9uc2UoKSB7XG4gICAgdGhpcy5ub3JtYWwgPSBbMCwgMF07XG4gICAgdGhpcy5tdHYgPSBbMCwgMF07XG59XG5cblJlc3BvbnNlLnByb3RvdHlwZS5hID0gbnVsbDtcblJlc3BvbnNlLnByb3RvdHlwZS5iID0gbnVsbDtcblJlc3BvbnNlLnByb3RvdHlwZS5hSW5CID0gdHJ1ZTtcblJlc3BvbnNlLnByb3RvdHlwZS5iSW5BID0gdHJ1ZTtcblJlc3BvbnNlLnByb3RvdHlwZS5kZXB0aCA9IE51bWJlci5NQVhfVkFMVUU7XG5SZXNwb25zZS5wcm90b3R5cGUubm9ybWFsID0gbnVsbDtcblJlc3BvbnNlLnByb3RvdHlwZS5tdHYgPSBudWxsO1xuLyoqXG4gKiBlcXVpdmFsZW50IHRvIG5ldyBDb2xsaXNpb24uUmVzcG9uc2UoKVxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSgpO1xufVxuXG4vKipcbiAqIFJlc3RvcmUgZGVmYXVsdCB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSBvdXRfcmVzcG9uc2VcbiAqIEByZXR1cm4ge1Jlc3BvbnNlfVxuICovXG5mdW5jdGlvbiBjbGVhcihvdXRfcmVzcG9uc2UpIHtcbiAgICBvdXRfcmVzcG9uc2UuYUluQiA9IHRydWU7XG4gICAgb3V0X3Jlc3BvbnNlLmJJbkEgPSB0cnVlO1xuICAgIG91dF9yZXNwb25zZS5kZXB0aCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICBvdXRfcmVzcG9uc2Uubm9ybWFsWzBdID0gMDtcbiAgICBvdXRfcmVzcG9uc2Uubm9ybWFsWzFdID0gMDtcblxuICAgIG91dF9yZXNwb25zZS5tdHZbMF0gPSAwO1xuICAgIG91dF9yZXNwb25zZS5tdHZbMV0gPSAwO1xuXG4gICAgcmV0dXJuIG91dF9yZXNwb25zZTtcbn1cbi8qKlxuICogQ29tcHV0ZSByZWFsIG10diBzY2FsaW5nIHJlc3BvbnNlLm10diAqIHJlc3BvbnNlLmRlcHRoXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIG10dihvdXRfdmVjMiwgcmVzcG9uc2UpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbiAgICB2ZWMyX3NjYWxlKG91dF92ZWMyLCByZXNwb25zZS5tdHYsIHJlc3BvbnNlLmRlcHRoKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlO1xuXG5SZXNwb25zZS5jcmVhdGUgPSBjcmVhdGU7XG5SZXNwb25zZS5jbGVhciA9IGNsZWFyO1xuUmVzcG9uc2UubXR2ID0gbXR2O1xuIiwiLyoqIVxuKiBAc291cmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmllY2tlbi9zYXQtanNcbiogQHJlZmVyZW5jZSBodHRwOi8vcGh5c2ljczJkLmNvbS9jb250ZW50L3NlcGFyYXRpb24tYXhpc1xuKlxuKiBWZXJzaW9uIDAuNC4xIC0gQ29weXJpZ2h0IDIwMTQgLSAgSmltIFJpZWNrZW4gPGppbXJAamltci5jYT5cbiogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4qIEFkYXB0ZWQgdG8ganMtMmRtYXRoIGJ5IEx1aXMgTGFmdWVudGUgPGxsYWZ1ZW50ZUBub2JveG91dC5jb20+XG4qXG4qIEEgc2ltcGxlIGxpYnJhcnkgZm9yIGRldGVybWluaW5nIGludGVyc2VjdGlvbnMgb2YgY2lyY2xlcyBhbmQgcG9seWdvbnMgdXNpbmcgdGhlIFNlcGFyYXRpbmcgQXhpcyBUaGVvcmVtLlxuKi9cblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vdmVjMi5qc1wiKSxcbiAgICBQb2x5Z29uID0gcmVxdWlyZShcIi4uL3BvbHlnb24uanNcIiksXG4gICAgUmVzcG9uc2UgPSByZXF1aXJlKFwiLi9yZXNwb25zZS5qc1wiKSxcbiAgICByZXNwb25zZV9jbGVhciA9IFJlc3BvbnNlLmNsZWFyLFxuICAgIHZlYzJfZG90ID0gVmVjMi5kb3QsXG4gICAgdmVjMl9zdWIgPSBWZWMyLnN1YixcbiAgICB2ZWMyX2xlbmd0aCA9IFZlYzIubGVuZ3RoLFxuICAgIHZlYzJfbGVuZ3RoU3EgPSBWZWMyLmxlbmd0aFNxLFxuICAgIHZlYzJfY29weSA9IFZlYzIuY29weSxcbiAgICB2ZWMyX25vcm1hbGl6ZSA9IFZlYzIubm9ybWFsaXplLFxuICAgIHZlYzJfbmVnYXRlID0gVmVjMi5uZWdhdGUsXG4gICAgdmVjMl9zY2FsZSA9IFZlYzIuc2NhbGUsXG4gICAgdmVjMl9wZXJwID0gVmVjMi5wZXJwLFxuXG4gICAgYWJzID0gTWF0aC5hYnMsXG4gICAgc3FydCA9IE1hdGguc3FydDtcblxuXG5cbi8vIFVuaXQgc3F1YXJlIHBvbHlnb24gdXNlZCBmb3IgcG9seWdvbiBoaXQgZGV0ZWN0aW9uLlxuLyoqXG4gKiBAdHlwZSB7UG9seWdvbn1cbiAqL1xudmFyIFVOSVRfU1FVQVJFID0gW1sxLCAwXSwgWzEsIDFdLCBbMCwgMV0sIFswLCAwXV0sXG4gICAgVU5JVF9TUVVBUkVfTU9WRUQgPSBbWzEsIDBdLCBbMSwgMV0sIFswLCAxXSwgWzAsIDBdXTtcblxuLy8gIyMgSGVscGVyIEZ1bmN0aW9uc1xuXG4vKipcbiAqIEZsYXR0ZW5zIHRoZSBzcGVjaWZpZWQgYXJyYXkgb2YgcG9pbnRzIG9udG8gYSB1bml0IHZlY3RvciBheGlzLFxuICogcmVzdWx0aW5nIGluIGEgb25lIGRpbWVuc2lvbmFsIHJhbmdlIG9mIHRoZSBtaW5pbXVtIGFuZFxuICogbWF4aW11bSB2YWx1ZSBvbiB0aGF0IGF4aXMuXG4gKlxuICogQHBhcmFtIHtBcnJheS48VmVjMj59IHBvaW50cyBUaGUgcG9pbnRzIHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge1ZlYzJ9IG5vcm1hbCBUaGUgdW5pdCB2ZWN0b3IgYXhpcyB0byBmbGF0dGVuIG9uLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmVzdWx0IEFuIGFycmF5LiBBZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIHJlc3VsdFswXSB3aWxsIGJlIHRoZSBtaW5pbXVtIHZhbHVlLCByZXN1bHRbMV0gd2lsbCBiZSB0aGUgbWF4aW11bSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gX2ZsYXR0ZW5Qb2ludHNPbihwb2ludHMsIG5vcm1hbCwgcmVzdWx0KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkobm9ybWFsKSB8fCBub3JtYWxbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihub3JtYWxbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygbm9ybWFsWzBdIHx8IG5vcm1hbFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG5vcm1hbFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBub3JtYWxbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgbm9ybWFsXCIpXG59XG5cbiAgICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgbWF4ID0gLU51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBkb3Q7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHByb2plY3Rpb24gb2YgdGhlIHBvaW50IG9udG8gdGhlIG5vcm1hbFxuICAgICAgICBkb3QgPSB2ZWMyX2RvdChwb2ludHNbaV0sIG5vcm1hbCk7XG4gICAgICAgIGlmIChkb3QgPCBtaW4pIHsgbWluID0gZG90OyB9XG4gICAgICAgIGlmIChkb3QgPiBtYXgpIHsgbWF4ID0gZG90OyB9XG4gICAgfVxuXG4gICAgcmVzdWx0WzBdID0gbWluO1xuICAgIHJlc3VsdFsxXSA9IG1heDtcbn1cblxudmFyIHJhbmdlQSA9IFswLCAwXSxcbiAgICByYW5nZUIgPSBbMCwgMF0sXG4gICAgb2Zmc2V0ViA9IFswLCAwXTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBjb252ZXggcG9seWdvbnMgYXJlIHNlcGFyYXRlZCBieSB0aGUgc3BlY2lmaWVkXG4gKiBheGlzIChtdXN0IGJlIGEgdW5pdCB2ZWN0b3IpLlxuICpcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IG91dF9yZXNwb25zZSBBIFJlc3BvbnNlIG9iamVjdCB3aGljaCB3aWxsIGJlIHBvcHVsYXRlZCBpZiB0aGUgYXhpcyBpcyBub3QgYSBzZXBhcmF0aW5nIGF4aXMuXG4gKiBAcGFyYW0ge1ZlYzJ9IGFfcG9zIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9seWdvbi5cbiAqIEBwYXJhbSB7VmVjMn0gYl9wb3MgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9seWdvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPFZlYzI+fSBhX3BvaW50cyBUaGUgcG9pbnRzIGluIHRoZSBmaXJzdCBwb2x5Z29uLlxuICogQHBhcmFtIHtBcnJheS48VmVjMj59IGJfcG9pbnRzIFRoZSBwb2ludHMgaW4gdGhlIHNlY29uZCBwb2x5Z29uLlxuICogQHBhcmFtIHtWZWMyfSBheGlzIFRoZSBheGlzICh1bml0IHNpemVkKSB0byB0ZXN0IGFnYWluc3QuICBUaGUgcG9pbnRzIG9mIGJvdGggcG9seWdvbnMgd2lsbCBiZSBwcm9qZWN0ZWQgb250byB0aGlzIGF4aXMuXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzIGEgc2VwYXJhdGluZyBheGlzLCBmYWxzZSBvdGhlcndpc2UuICBJZiBmYWxzZSwgYW5kIGEgcmVzcG9uc2UgaXMgcGFzc2VkIGluLCBpbmZvcm1hdGlvbiBhYm91dCBob3cgbXVjaCBvdmVybGFwIGFuZCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBvdmVybGFwIHdpbGwgYmUgcG9wdWxhdGVkLlxuICovXG5mdW5jdGlvbiBfaXNTZXBhcmF0aW5nQXhpcyhvdXRfcmVzcG9uc2UsIGFfcG9zLCBiX3BvcywgYV9wb2ludHMsIGJfcG9pbnRzLCBheGlzKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkoYV9wb3MpIHx8IGFfcG9zWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYV9wb3NbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYV9wb3NbMF0gfHwgYV9wb3NbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhX3Bvc1sxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhX3Bvc1sxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBhX3Bvc1wiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkoYl9wb3MpIHx8IGJfcG9zWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYl9wb3NbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYl9wb3NbMF0gfHwgYl9wb3NbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiX3Bvc1sxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiX3Bvc1sxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBiX3Bvc1wiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkoYXhpcykgfHwgYXhpc1swXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGF4aXNbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYXhpc1swXSB8fCBheGlzWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYXhpc1sxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBheGlzWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIGF4aXNcIilcbn1cblxuICAgIC8vIFRoZSBtYWduaXR1ZGUgb2YgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSB0d28gcG9seWdvbnNcbiAgICB2ZWMyX3N1YihvZmZzZXRWLCBiX3BvcywgYV9wb3MpO1xuICAgIHZhciBwcm9qZWN0ZWRPZmZzZXQgPSB2ZWMyX2RvdChvZmZzZXRWLCBheGlzKTtcbiAgICAvLyBQcm9qZWN0IHRoZSBwb2x5Z29ucyBvbnRvIHRoZSBheGlzLlxuICAgIF9mbGF0dGVuUG9pbnRzT24oYV9wb2ludHMsIGF4aXMsIHJhbmdlQSk7XG4gICAgX2ZsYXR0ZW5Qb2ludHNPbihiX3BvaW50cywgYXhpcywgcmFuZ2VCKTtcbiAgICAvLyBNb3ZlIEIncyByYW5nZSB0byBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gQS5cbiAgICByYW5nZUJbMF0gKz0gcHJvamVjdGVkT2Zmc2V0O1xuICAgIHJhbmdlQlsxXSArPSBwcm9qZWN0ZWRPZmZzZXQ7XG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBnYXAuIElmIHRoZXJlIGlzLCB0aGlzIGlzIGEgc2VwYXJhdGluZyBheGlzIGFuZCB3ZSBjYW4gc3RvcFxuICAgIGlmIChyYW5nZUFbMF0gPiByYW5nZUJbMV0gfHwgcmFuZ2VCWzBdID4gcmFuZ2VBWzFdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIG5vdCBhIHNlcGFyYXRpbmcgYXhpcy4gSWYgd2UncmUgY2FsY3VsYXRpbmcgYSByZXNwb25zZSwgY2FsY3VsYXRlIHRoZSBvdmVybGFwLlxuXG4gICAgdmFyIG92ZXJsYXAgPSAwLFxuICAgICAgICBvcHRpb24xLFxuICAgICAgICBvcHRpb24yO1xuICAgIC8vIEEgc3RhcnRzIGZ1cnRoZXIgbGVmdCB0aGFuIEJcbiAgICBpZiAocmFuZ2VBWzBdIDwgcmFuZ2VCWzBdKSB7XG4gICAgICAgIG91dF9yZXNwb25zZS5hSW5CID0gZmFsc2U7XG4gICAgICAgIC8vIEEgZW5kcyBiZWZvcmUgQiBkb2VzLiBXZSBoYXZlIHRvIHB1bGwgQSBvdXQgb2YgQlxuICAgICAgICBpZiAocmFuZ2VBWzFdIDwgcmFuZ2VCWzFdKSB7XG4gICAgICAgICAgICBvdmVybGFwID0gcmFuZ2VBWzFdIC0gcmFuZ2VCWzBdO1xuICAgICAgICAgICAgb3V0X3Jlc3BvbnNlLmJJbkEgPSBmYWxzZTtcbiAgICAgICAgLy8gQiBpcyBmdWxseSBpbnNpZGUgQS4gIFBpY2sgdGhlIHNob3J0ZXN0IHdheSBvdXQuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb24xID0gcmFuZ2VBWzFdIC0gcmFuZ2VCWzBdO1xuICAgICAgICAgICAgb3B0aW9uMiA9IHJhbmdlQlsxXSAtIHJhbmdlQVswXTtcbiAgICAgICAgICAgIG92ZXJsYXAgPSBvcHRpb24xIDwgb3B0aW9uMiA/IG9wdGlvbjEgOiAtb3B0aW9uMjtcbiAgICAgICAgfVxuICAgIC8vIEIgc3RhcnRzIGZ1cnRoZXIgbGVmdCB0aGFuIEFcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRfcmVzcG9uc2UuYkluQSA9IGZhbHNlO1xuICAgICAgICAvLyBCIGVuZHMgYmVmb3JlIEEgZW5kcy4gV2UgaGF2ZSB0byBwdXNoIEEgb3V0IG9mIEJcbiAgICAgICAgaWYgKHJhbmdlQVsxXSA+IHJhbmdlQlsxXSkge1xuICAgICAgICAgICAgb3ZlcmxhcCA9IHJhbmdlQVswXSAtIHJhbmdlQlsxXTtcbiAgICAgICAgICAgIG91dF9yZXNwb25zZS5hSW5CID0gZmFsc2U7XG4gICAgICAgIC8vIEEgaXMgZnVsbHkgaW5zaWRlIEIuICBQaWNrIHRoZSBzaG9ydGVzdCB3YXkgb3V0LlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uMSA9IHJhbmdlQVsxXSAtIHJhbmdlQlswXTtcbiAgICAgICAgICAgIG9wdGlvbjIgPSByYW5nZUJbMV0gLSByYW5nZUFbMF07XG4gICAgICAgICAgICBvdmVybGFwID0gb3B0aW9uMSA8IG9wdGlvbjIgPyBvcHRpb24xIDogLW9wdGlvbjI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgc21hbGxlc3QgYW1vdW50IG9mIG92ZXJsYXAgd2UndmUgc2VlbiBzbyBmYXIsIHNldCBpdCBhcyB0aGUgbWluaW11bSBvdmVybGFwLlxuICAgIHZhciBhYnNPdmVybGFwID0gYWJzKG92ZXJsYXApO1xuICAgIGlmIChhYnNPdmVybGFwIDwgb3V0X3Jlc3BvbnNlLmRlcHRoKSB7XG4gICAgICAgIG91dF9yZXNwb25zZS5kZXB0aCA9IGFic092ZXJsYXA7XG4gICAgICAgIHZlYzJfY29weShvdXRfcmVzcG9uc2UubXR2LCBheGlzKTtcbiAgICAgICAgaWYgKG92ZXJsYXAgPCAwKSB7XG4gICAgICAgICAgICB2ZWMyX25lZ2F0ZShvdXRfcmVzcG9uc2UubXR2LCBvdXRfcmVzcG9uc2UubXR2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gQ2FsY3VsYXRlcyB3aGljaCBWb3Jub2kgcmVnaW9uIGEgcG9pbnQgaXMgb24gYSBsaW5lIHNlZ21lbnQuXG4vLyBJdCBpcyBhc3N1bWVkIHRoYXQgYm90aCB0aGUgbGluZSBhbmQgdGhlIHBvaW50IGFyZSByZWxhdGl2ZSB0byBgKDAsMClgXG4vL1xuLy8gICAgICAgICAgICB8ICAgICAgICgwKSAgICAgIHxcbi8vICAgICAoLTEpICBbU10tLS0tLS0tLS0tLS0tLVtFXSAgKDEpXG4vLyAgICAgICAgICAgIHwgICAgICAgKDApICAgICAgfFxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IGxpbmUgVGhlIGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7VmVjMn0gcG9pbnQgVGhlIHBvaW50LlxuICogQHJldHVybiAge051bWJlcn0gTEVGVF9WT1JOT0lfUkVHSU9OICgtMSkgaWYgaXQgaXMgdGhlIGxlZnQgcmVnaW9uLCBNSURETEVfVk9STk9JX1JFR0lPTiAoMCkgaWYgaXQgaXMgdGhlIG1pZGRsZSByZWdpb24sIFJJR0hUX1ZPUk5PSV9SRUdJT04gKDEpIGlmIGl0IGlzIHRoZSByaWdodCByZWdpb24uXG4gKi9cbmZ1bmN0aW9uIF92b3Jub2lSZWdpb24obGluZSwgcG9pbnQpIHtcbmlmICghQXJyYXkuaXNBcnJheShsaW5lKSB8fCBsaW5lWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obGluZVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBsaW5lWzBdIHx8IGxpbmVbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihsaW5lWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGxpbmVbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgbGluZVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkocG9pbnQpIHx8IHBvaW50WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocG9pbnRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcG9pbnRbMF0gfHwgcG9pbnRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihwb2ludFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBwb2ludFsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBwb2ludFwiKVxufVxuXG4gICAgdmFyIGxlbjIgPSB2ZWMyX2xlbmd0aFNxKGxpbmUpLFxuICAgICAgICBkcCA9IHZlYzJfZG90KHBvaW50LCBsaW5lKTtcbiAgICAvLyBJZiB0aGUgcG9pbnQgaXMgYmV5b25kIHRoZSBzdGFydCBvZiB0aGUgbGluZSwgaXQgaXMgaW4gdGhlXG4gICAgLy8gbGVmdCB2b3Jub2kgcmVnaW9uLlxuICAgIGlmIChkcCA8IDApIHsgcmV0dXJuIExFRlRfVk9STk9JX1JFR0lPTjsgfVxuICAgIC8vIElmIHRoZSBwb2ludCBpcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbGluZSwgaXQgaXMgaW4gdGhlXG4gICAgLy8gcmlnaHQgdm9ybm9pIHJlZ2lvbi5cbiAgICBlbHNlIGlmIChkcCA+IGxlbjIpIHsgcmV0dXJuIFJJR0hUX1ZPUk5PSV9SRUdJT047IH1cbiAgICAvLyBPdGhlcndpc2UsIGl0J3MgaW4gdGhlIG1pZGRsZSBvbmUuXG4gICAgZWxzZSB7IHJldHVybiBNSURETEVfVk9STk9JX1JFR0lPTjsgfVxufVxuLy8gQ29uc3RhbnRzIGZvciBWb3Jub2kgcmVnaW9uc1xuLyoqXG4gKiBAY29uc3RcbiAqL1xudmFyIExFRlRfVk9STk9JX1JFR0lPTiA9IC0xO1xuLyoqXG4gKiBAY29uc3RcbiAqL1xudmFyIE1JRERMRV9WT1JOT0lfUkVHSU9OID0gMDtcbi8qKlxuICogQGNvbnN0XG4gKi9cbnZhciBSSUdIVF9WT1JOT0lfUkVHSU9OID0gMTtcblxuLy8gIyMgQ29sbGlzaW9uIFRlc3RzXG5cbnZhciBwaWNfZGlmZmVyZW5jZVYgPSBbMCwgMF07XG4vKipcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgY2lyY2xlLlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMiBUaGUgcG9pbnQgdG8gdGVzdC5cbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGUgVGhlIGNpcmNsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSBjaXJjbGUsIGZhbHNlIGlmIGl0IGlzIG5vdC5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRJbkNpcmNsZSh2ZWMyLCBjaXJjbGUpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgdmVjMl9zdWIocGljX2RpZmZlcmVuY2VWLCB2ZWMyLCBjaXJjbGVbMF0pO1xuXG4gICAgLy8gSWYgdGhlIGRpc3RhbmNlIGJldHdlZW4gaXMgc21hbGxlciB0aGFuIHRoZSByYWRpdXMgdGhlbiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSBjaXJjbGUuXG4gICAgcmV0dXJuIHZlYzJfbGVuZ3RoU3EocGljX2RpZmZlcmVuY2VWKSA8PSAoY2lyY2xlWzFdICogY2lyY2xlWzFdKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGlzIGluc2lkZSBhIGNvbnZleCBwb2x5Z29uLlxuICpcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IG91dF9yZXNwb25zZVxuICogQHBhcmFtIHtWZWMyfSB2ZWMyIFRoZSBwb2ludCB0byB0ZXN0LlxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5IFRoZSBwb2x5Z29uIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHBvbHlnb24sIGZhbHNlIGlmIGl0IGlzIG5vdC5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRJblBvbHlnb24ob3V0X3Jlc3BvbnNlLCB2ZWMyLCBwb2x5KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIFBvbHlnb24udHJhbnNsYXRlKFVOSVRfU1FVQVJFX01PVkVELCBVTklUX1NRVUFSRSwgdmVjMik7XG4gICAgcmVzcG9uc2VfY2xlYXIob3V0X3Jlc3BvbnNlKTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRQb2x5Z29uUG9seWdvbihvdXRfcmVzcG9uc2UsIFVOSVRfU1FVQVJFX01PVkVELCBwb2x5KTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IG91dF9yZXNwb25zZS5hSW5CO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgY2ljX2RpZmZlcmVuY2VWID0gWzAsIDBdO1xuLyoqXG4gKiBDaGVjayBpZiB0d28gY2lyY2xlcyBjb2xsaWRlLlxuICpcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IG91dF9yZXNwb25zZSBSZXNwb25zZSBvYmplY3QgdGhhdCB3aWxsIGJlIHBvcHVsYXRlZCBpZiB0aGUgY2lyY2xlcyBpbnRlcnNlY3QuXG4gKiBAcGFyYW0ge0NpcmNsZX0gYV9jaXJjbGUgVGhlIGZpcnN0IGNpcmNsZS5cbiAqIEBwYXJhbSB7Q2lyY2xlfSBiX2NpcmNsZSBUaGUgc2Vjb25kIGNpcmNsZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNpcmNsZXMgaW50ZXJzZWN0LCBmYWxzZSBpZiB0aGV5IGRvbid0LlxuICovXG5mdW5jdGlvbiBnZXRDaXJjbGVDaXJjbGUob3V0X3Jlc3BvbnNlLCBhX2NpcmNsZSwgYl9jaXJjbGUpIHtcbiAgICByZXNwb25zZV9jbGVhcihvdXRfcmVzcG9uc2UpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlcnMgb2YgdGhlIHR3b1xuICAgIC8vIGNpcmNsZXMgaXMgZ3JlYXRlciB0aGFuIHRoZWlyIGNvbWJpbmVkIHJhZGl1cy5cbiAgICB2ZWMyX3N1YihjaWNfZGlmZmVyZW5jZVYsIGJfY2lyY2xlWzBdLCBhX2NpcmNsZVswXSk7XG4gICAgdmFyIHRvdGFsUmFkaXVzID0gYV9jaXJjbGVbMV0gKyBiX2NpcmNsZVsxXSxcbiAgICAgICAgdG90YWxSYWRpdXNTcSA9IHRvdGFsUmFkaXVzICogdG90YWxSYWRpdXMsXG4gICAgICAgIGRpc3RhbmNlU3EgPSB2ZWMyX2xlbmd0aFNxKGNpY19kaWZmZXJlbmNlViksXG4gICAgICAgIGRpc3Q7XG5cbiAgICAvLyBJZiB0aGUgZGlzdGFuY2UgaXMgYmlnZ2VyIHRoYW4gdGhlIGNvbWJpbmVkIHJhZGl1cywgdGhleSBkb24ndCBpbnRlcnNlY3QuXG4gICAgaWYgKGRpc3RhbmNlU3EgPiB0b3RhbFJhZGl1c1NxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGV5IGludGVyc2VjdC4gIElmIHdlJ3JlIGNhbGN1bGF0aW5nIGEgcmVzcG9uc2UsIGNhbGN1bGF0ZSB0aGUgb3ZlcmxhcC5cbiAgICBkaXN0ID0gc3FydChkaXN0YW5jZVNxKTtcbiAgICBvdXRfcmVzcG9uc2UuYSA9IGFfY2lyY2xlO1xuICAgIG91dF9yZXNwb25zZS5iID0gYl9jaXJjbGU7XG4gICAgb3V0X3Jlc3BvbnNlLmRlcHRoID0gdG90YWxSYWRpdXMgLSBkaXN0O1xuXG4gICAgdmVjMl9ub3JtYWxpemUob3V0X3Jlc3BvbnNlLm10diwgY2ljX2RpZmZlcmVuY2VWKTtcblxuICAgIG91dF9yZXNwb25zZS5hSW5CID0gYV9jaXJjbGVbMV0gPD0gYl9jaXJjbGVbMV0gJiYgZGlzdCA8PSBiX2NpcmNsZVsxXSAtIGFfY2lyY2xlWzFdO1xuICAgIG91dF9yZXNwb25zZS5iSW5BID0gYl9jaXJjbGVbMV0gPD0gYV9jaXJjbGVbMV0gJiYgZGlzdCA8PSBhX2NpcmNsZVsxXSAtIGJfY2lyY2xlWzFdO1xuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBwY19jaXJjbGVQb3MgPSBbMCwgMF0sXG4gICAgZWRnZSA9ICBbMCwgMF0sXG4gICAgcG9pbnQgPSAgWzAsIDBdLFxuICAgIHBvaW50MiA9ICBbMCwgMF0sXG4gICAgbm9ybWFsID0gWzAsIDBdO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcG9seWdvbiBhbmQgYSBjaXJjbGUgY29sbGlkZS5cbiAqXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSBvdXRfcmVzcG9uc2UgUmVzcG9uc2Ugb2JqZWN0IHRoYXQgd2lsbCBiZSBwb3B1bGF0ZWQgaWYgdGhleSBpbnRlcnNldC5cbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seV9wb2ludHMgVGhlIHBvbHlnb24uXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHlfZWRnZXMgVGhlIHBvbHlnb24gZWRnZXNcbiAqIEBwYXJhbSB7VmVjMn0gcG9seV9wb3MgVGhlIHBvbHlnb24gcG9zaXRpb25cbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGUgVGhlIGNpcmNsZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhleSBpbnRlcnNlY3QsIGZhbHNlIGlmIHRoZXkgZG9uJ3QuXG4gKi9cbmZ1bmN0aW9uIGdldFBvbHlnb25DaXJjbGUob3V0X3Jlc3BvbnNlLCBwb2x5X3BvaW50cywgcG9seV9lZGdlcywgcG9seV9wb3MsIGNpcmNsZSkge1xuaWYgKCFBcnJheS5pc0FycmF5KHBvbHlfcG9zKSB8fCBwb2x5X3Bvc1swXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHBvbHlfcG9zWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHBvbHlfcG9zWzBdIHx8IHBvbHlfcG9zWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocG9seV9wb3NbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcG9seV9wb3NbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgcG9seV9wb3NcIilcbn1cblxuICAgIHJlc3BvbnNlX2NsZWFyKG91dF9yZXNwb25zZSk7XG5cbiAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgcmVsYXRpdmUgdG8gdGhlIHBvbHlnb24uXG4gICAgdmVjMl9zdWIocGNfY2lyY2xlUG9zLCBjaXJjbGVbMF0sIHBvbHlfcG9zKTtcblxuICAgIHZhciByYWRpdXMgPSBjaXJjbGVbMV0sXG4gICAgICAgIHJhZGl1czIgPSByYWRpdXMgKiByYWRpdXMsXG4gICAgICAgIGxlbiA9IHBvbHlfcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgZGlzdCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICAvLyBGb3IgZWFjaCBlZGdlIGluIHRoZSBwb2x5Z29uOlxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG5leHQgPSBpID09PSBsZW4gLSAxID8gMCA6IGkgKyAxO1xuICAgICAgICB2YXIgcHJldiA9IGkgPT09IDAgPyBsZW4gLSAxIDogaSAtIDE7XG4gICAgICAgIHZhciBvdmVybGFwID0gMDtcbiAgICAgICAgdmFyIG92ZXJsYXBOID0gbnVsbDtcblxuICAgICAgICAvLyBHZXQgdGhlIGVkZ2UuXG4gICAgICAgIHZlYzJfY29weShlZGdlLCBwb2x5X2VkZ2VzW2ldKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSByZWxhdGl2ZSB0byB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGVkZ2UuXG4gICAgICAgIHZlYzJfc3ViKHBvaW50LCBwY19jaXJjbGVQb3MsIHBvbHlfcG9pbnRzW2ldKTtcblxuICAgICAgICAvLyBJZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgYW5kIHRoZSBwb2ludFxuICAgICAgICAvLyBpcyBiaWdnZXIgdGhhbiB0aGUgcmFkaXVzLCB0aGUgcG9seWdvbiBpcyBkZWZpbml0ZWx5IG5vdCBmdWxseSBpblxuICAgICAgICAvLyB0aGUgY2lyY2xlLlxuICAgICAgICBpZiAodmVjMl9sZW5ndGhTcShwb2ludCkgPiByYWRpdXMyKSB7XG4gICAgICAgICAgICBvdXRfcmVzcG9uc2UuYUluQiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHdoaWNoIFZvcm5vaSByZWdpb24gdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGlzIGluLlxuICAgICAgICB2YXIgcmVnaW9uID0gX3Zvcm5vaVJlZ2lvbihlZGdlLCBwb2ludCk7XG4gICAgICAgIC8vIElmIGl0J3MgdGhlIGxlZnQgcmVnaW9uOlxuICAgICAgICBpZiAocmVnaW9uID09PSBMRUZUX1ZPUk5PSV9SRUdJT04pIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlJ3JlIGluIHRoZSBSSUdIVF9WT1JOT0lfUkVHSU9OIG9mIHRoZSBwcmV2aW91cyBlZGdlLlxuICAgICAgICAgICAgdmVjMl9jb3B5KGVkZ2UsIHBvbHlfZWRnZXNbcHJldl0pO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSByZWxhdGl2ZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIHByZXZpb3VzIGVkZ2VcbiAgICAgICAgICAgIHZlYzJfc3ViKHBvaW50MiwgcGNfY2lyY2xlUG9zLCBwb2x5X3BvaW50c1twcmV2XSk7XG4gICAgICAgICAgICByZWdpb24gPSBfdm9ybm9pUmVnaW9uKGVkZ2UsIHBvaW50Mik7XG4gICAgICAgICAgICBpZiAocmVnaW9uID09PSBSSUdIVF9WT1JOT0lfUkVHSU9OKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBpbiB0aGUgcmVnaW9uIHdlIHdhbnQuICBDaGVjayBpZiB0aGUgY2lyY2xlIGludGVyc2VjdHMgdGhlIHBvaW50LlxuICAgICAgICAgICAgICAgIGRpc3QgPSB2ZWMyX2xlbmd0aChwb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpbnRlcnNlY3RzLCBjYWxjdWxhdGUgdGhlIG92ZXJsYXAuXG4gICAgICAgICAgICAgICAgICAgIG91dF9yZXNwb25zZS5iSW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBOID0gWzAsIDBdO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyX25vcm1hbGl6ZShvdmVybGFwTiwgcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBvdmVybGFwID0gcmFkaXVzIC0gZGlzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIElmIGl0J3MgdGhlIHJpZ2h0IHJlZ2lvbjpcbiAgICAgICAgfSBlbHNlIGlmIChyZWdpb24gPT09IFJJR0hUX1ZPUk5PSV9SRUdJT04pIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlJ3JlIGluIHRoZSBsZWZ0IHJlZ2lvbiBvbiB0aGUgbmV4dCBlZGdlXG4gICAgICAgICAgICB2ZWMyX2NvcHkoZWRnZSwgcG9seV9lZGdlc1tuZXh0XSk7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIHJlbGF0aXZlIHRvIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgbmV4dCBlZGdlLlxuICAgICAgICAgICAgdmVjMl9zdWIocG9pbnQsIHBjX2NpcmNsZVBvcywgcG9seV9wb2ludHNbbmV4dF0pO1xuICAgICAgICAgICAgcmVnaW9uID0gX3Zvcm5vaVJlZ2lvbihlZGdlLCBwb2ludCk7XG4gICAgICAgICAgICBpZiAocmVnaW9uID09PSBMRUZUX1ZPUk5PSV9SRUdJT04pIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGluIHRoZSByZWdpb24gd2Ugd2FudC4gIENoZWNrIGlmIHRoZSBjaXJjbGUgaW50ZXJzZWN0cyB0aGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgZGlzdCA9IHZlYzJfbGVuZ3RoKHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IHJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGludGVyc2VjdHMsIGNhbGN1bGF0ZSB0aGUgb3ZlcmxhcC5cbiAgICAgICAgICAgICAgICAgICAgb3V0X3Jlc3BvbnNlLmJJbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcE4gPSBbMCwgMF07XG4gICAgICAgICAgICAgICAgICAgIHZlYzJfbm9ybWFsaXplKG92ZXJsYXBOLCBwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXAgPSByYWRpdXMgLSBkaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIHRoZSBtaWRkbGUgcmVnaW9uOlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgY2lyY2xlIGlzIGludGVyc2VjdGluZyB0aGUgZWRnZSxcbiAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgZWRnZSBpbnRvIGl0cyBcImVkZ2Ugbm9ybWFsXCIuXG4gICAgICAgICAgICB2ZWMyX25vcm1hbGl6ZShub3JtYWwsIHZlYzJfcGVycChlZGdlLCBlZGdlKSk7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBwZXJwZW5kaWN1bGFyIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlciBvZiB0aGVcbiAgICAgICAgICAgIC8vIGNpcmNsZSBhbmQgdGhlIGVkZ2UuXG4gICAgICAgICAgICBkaXN0ID0gdmVjMl9kb3QocG9pbnQsIG5vcm1hbCk7XG4gICAgICAgICAgICB2YXIgZGlzdEFicyA9IGFicyhkaXN0KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaXJjbGUgaXMgb24gdGhlIG91dHNpZGUgb2YgdGhlIGVkZ2UsIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cbiAgICAgICAgICAgIGlmIChkaXN0ID4gMCAmJiBkaXN0QWJzID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpbnRlcnNlY3RzLCBjYWxjdWxhdGUgdGhlIG92ZXJsYXAuXG4gICAgICAgICAgICAgICAgb3ZlcmxhcE4gPSBub3JtYWw7XG4gICAgICAgICAgICAgICAgb3ZlcmxhcCA9IHJhZGl1cyAtIGRpc3Q7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGlzIG9uIHRoZSBvdXRzaWRlIG9mIHRoZSBlZGdlLCBvciBwYXJ0IG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNpcmNsZSBpcyBvbiB0aGUgb3V0c2lkZSwgdGhlIGNpcmNsZSBpcyBub3QgZnVsbHkgaW5zaWRlIHRoZSBwb2x5Z29uLlxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID49IDAgfHwgb3ZlcmxhcCA8IDIgKiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0X3Jlc3BvbnNlLmJJbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBzbWFsbGVzdCBvdmVybGFwIHdlJ3ZlIHNlZW4sIGtlZXAgaXQuXG4gICAgICAgIC8vIChvdmVybGFwTiBtYXkgYmUgbnVsbCBpZiB0aGUgY2lyY2xlIHdhcyBpbiB0aGUgd3JvbmcgVm9ybm9pIHJlZ2lvbikuXG4gICAgICAgIGlmIChvdmVybGFwTiAmJiBhYnMob3ZlcmxhcCkgPCBhYnMob3V0X3Jlc3BvbnNlLmRlcHRoKSkge1xuICAgICAgICAgICAgb3V0X3Jlc3BvbnNlLmRlcHRoID0gb3ZlcmxhcDtcbiAgICAgICAgICAgIHZlYzJfY29weShvdXRfcmVzcG9uc2UubXR2LCBvdmVybGFwTik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGZpbmFsIG92ZXJsYXAgdmVjdG9yIC0gYmFzZWQgb24gdGhlIHNtYWxsZXN0IG92ZXJsYXAuXG4gICAgb3V0X3Jlc3BvbnNlLmEgPSBwb2x5X3BvaW50cztcbiAgICBvdXRfcmVzcG9uc2UuYiA9IGNpcmNsZTtcblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2lyY2xlIGFuZCBhIHBvbHlnb24gY29sbGlkZS5cbiAqXG4gKiBAbm90ZSBUaGlzIGlzIHNsaWdodGx5IGxlc3MgZWZmaWNpZW50IHRoYW4gcG9seWdvbkNpcmNsZSBhcyBpdCBqdXN0IHJ1bnMgcG9seWdvbkNpcmNsZSBhbmQgcmV2ZXJzZXMgZXZlcnl0aGluZyBhdCB0aGUgZW5kLlxuICogQHBhcmFtIHtSZXNwb25zZX0gb3V0X3Jlc3BvbnNlIFJlc3BvbnNlIG9iamVjdCB0aGF0IHdpbGwgYmUgcG9wdWxhdGVkIGlmIHRoZXkgaW50ZXJzZXQuXG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlIFRoZSBjaXJjbGUuXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHkgVGhlIHBvbHlnb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZXkgaW50ZXJzZWN0LCBmYWxzZSBpZiB0aGV5IGRvbid0LlxuICovXG5mdW5jdGlvbiBnZXRDaXJjbGVQb2x5Z29uKG91dF9yZXNwb25zZSwgY2lyY2xlLCBwb2x5KSB7XG4gICAgcmVzcG9uc2VfY2xlYXIob3V0X3Jlc3BvbnNlKTtcblxuICAgIC8vIFRlc3QgdGhlIHBvbHlnb24gYWdhaW5zdCB0aGUgY2lyY2xlLlxuICAgIHZhciByZXN1bHQgPSBnZXRQb2x5Z29uQ2lyY2xlKG91dF9yZXNwb25zZSwgcG9seSwgY2lyY2xlKTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gU3dhcCBBIGFuZCBCIGluIHRoZSByZXNwb25zZS5cbiAgICAgICAgdmFyIGEgPSBvdXRfcmVzcG9uc2UuYTtcbiAgICAgICAgdmFyIGFJbkIgPSBvdXRfcmVzcG9uc2UuYUluQjtcbiAgICAgICAgdmVjMl9uZWdhdGUob3V0X3Jlc3BvbnNlLm10diwgb3V0X3Jlc3BvbnNlLm10dik7XG4gICAgICAgIG91dF9yZXNwb25zZS5hID0gb3V0X3Jlc3BvbnNlLmI7XG4gICAgICAgIG91dF9yZXNwb25zZS5iID0gYTtcbiAgICAgICAgb3V0X3Jlc3BvbnNlLmFJbkIgPSBvdXRfcmVzcG9uc2UuYkluQTtcbiAgICAgICAgb3V0X3Jlc3BvbnNlLmJJbkEgPSBhSW5CO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHBvbHlnb25zIGNvbGxpZGUuXG4gKlxuICogQHBhcmFtIHtSZXNwb25zZX0gb3V0X3Jlc3BvbnNlIFJlc3BvbnNlIG9iamVjdCB0aGF0IHdpbGwgYmUgcG9wdWxhdGVkIGlmIHRoZXkgaW50ZXJzZXQuXG4gKiBAcGFyYW0ge1BvbHlnb259IGFfcG9pbnRzIFRoZSBmaXJzdCBwb2x5Z29uIHBvaW50c1xuICogQHBhcmFtIHtQb2x5Z29ufSBhX25vcm1hbHMgVGhlIGZpcnN0IHBvbHlnb24gbm9ybWFsc1xuICogQHBhcmFtIHtQb2x5Z29ufSBhX3BvcyBUaGUgZmlyc3QgcG9seWdvbiBwb3NpdGlvblxuICogQHBhcmFtIHtQb2x5Z29ufSBiX3BvaW50cyBUaGUgc2Vjb25kIHBvbHlnb24gcG9pbnRzXG4gKiBAcGFyYW0ge1BvbHlnb259IGJfbm9ybWFscyBUaGUgc2Vjb25kIHBvbHlnb24gbm9ybWFsc1xuICogQHBhcmFtIHtQb2x5Z29ufSBiX3BvcyBUaGUgc2Vjb25kIHBvbHlnb24gcG9zaXRpb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhleSBpbnRlcnNlY3QsIGZhbHNlIGlmIHRoZXkgZG9uJ3QuXG4gKi9cbmZ1bmN0aW9uIGdldFBvbHlnb25Qb2x5Z29uKG91dF9yZXNwb25zZSwgYV9wb2ludHMsIGFfbm9ybWFscywgYV9wb3MsIGJfcG9pbnRzLCBiX25vcm1hbHMsIGJfcG9zKSB7XG4gICAgcmVzcG9uc2VfY2xlYXIob3V0X3Jlc3BvbnNlKTtcblxuICAgIHZhciBhTGVuID0gYV9wb2ludHMubGVuZ3RoLFxuICAgICAgICBiTGVuID0gYl9wb2ludHMubGVuZ3RoLFxuICAgICAgICBpO1xuXG4gICAgLy8gSWYgYW55IG9mIHRoZSBlZGdlIG5vcm1hbHMgb2YgQSBpcyBhIHNlcGFyYXRpbmcgYXhpcywgbm8gaW50ZXJzZWN0aW9uLlxuICAgIGZvciAoaSA9IDA7IGkgPCBhTGVuOyArK2kpIHtcbiAgICAgICAgaWYgKF9pc1NlcGFyYXRpbmdBeGlzKG91dF9yZXNwb25zZSwgYV9wb3MsIGJfcG9zLCBhX3BvaW50cywgYl9wb2ludHMsIGFfbm9ybWFsc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiB0aGUgZWRnZSBub3JtYWxzIG9mIEIgaXMgYSBzZXBhcmF0aW5nIGF4aXMsIG5vIGludGVyc2VjdGlvbi5cbiAgICBmb3IgKGkgPSAwO2kgPCBiTGVuOyArK2kpIHtcbiAgICAgICAgaWYgKF9pc1NlcGFyYXRpbmdBeGlzKG91dF9yZXNwb25zZSwgYV9wb3MsIGJfcG9zLCBhX3BvaW50cywgYl9wb2ludHMsIGJfbm9ybWFsc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG52YXIgU0FUID0ge1xuICAgIFJlc3BvbnNlOiBSZXNwb25zZSxcbiAgICBnZXRQb2ludEluQ2lyY2xlOiBnZXRQb2ludEluQ2lyY2xlLFxuICAgIGdldFBvaW50SW5Qb2x5Z29uOiBnZXRQb2ludEluUG9seWdvbixcbiAgICBnZXRDaXJjbGVDaXJjbGU6IGdldENpcmNsZUNpcmNsZSxcbiAgICBnZXRQb2x5Z29uQ2lyY2xlOiBnZXRQb2x5Z29uQ2lyY2xlLFxuICAgIGdldENpcmNsZVBvbHlnb246IGdldENpcmNsZVBvbHlnb24sXG4gICAgZ2V0UG9seWdvblBvbHlnb246IGdldFBvbHlnb25Qb2x5Z29uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNBVDtcbiIsIi8qKlxuICogU3RhYmlsaXR5OiAwIChBbnl0aGluZyBjb3VsZCBoYXBwZW4pXG4gKi9cblxudmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgYWJzID0gTWF0aC5hYnMsXG4gICAgbWluID0gTWF0aC5taW4sXG4gICAgUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlLmpzXCIpLFxuICAgIHggPSAwLFxuICAgIHkgPSAwO1xuXG5mdW5jdGlvbiBmb3VyUG9pbnRzKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgeCA9IHgxIC0geDI7XG4gICAgeSA9IHkxIC0geTI7XG5cbiAgICByZXR1cm4gc3FydCh4ICogeCArIHkgKiB5KTtcbn1cblxuZnVuY3Rpb24gc3FyRm91clBvaW50cyh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHggPSB4MSAtIHgyO1xuICAgIHkgPSB5MSAtIHkyO1xuXG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG5cbmZ1bmN0aW9uIGxpbmUyX3ZlYzIobGluZTIsIHZlYzIpIHtcbiAgICB2YXIgX194MSA9IGxpbmUyWzBdWzBdLFxuICAgICAgICBfX3kxID0gbGluZTJbMF1bMV0sXG4gICAgICAgIF9feDIgPSBsaW5lMlswXVswXSArIGxpbmUyWzFdLFxuICAgICAgICBfX3kyID0gbGluZTJbMF1bMV0gKyBsaW5lMlsxXSxcbiAgICAgICAgX19weCA9IHZlYzJbMF0sXG4gICAgICAgIF9fcHkgPSB2ZWMyWzFdLFxuICAgICAgICByX251bWVyYXRvciA9IChfX3gxIC0gX194MikgKiAoX19weCAtIF9feDIpICsgKF9feTEgLSBfX3kyKSAqIChfX3B5IC0gX195MiksXG4gICAgICAgIHJfZGVub21lbmF0b3IgPSAoX19weCAtIF9feDIpICogKF9fcHggLSBfX3gyKSArIChfX3B5IC0gX195MikgKiAoX19weSAtIF9feTIpLFxuICAgICAgICByID0gcl9kZW5vbWVuYXRvciA9PT0gMCA/IDAgOiAocl9udW1lcmF0b3IgLyByX2Rlbm9tZW5hdG9yKSxcbiAgICAgICAgZGlzdGFuY2VMaW5lLFxuICAgICAgICBweCxcbiAgICAgICAgcHksXG4gICAgICAgIHM7XG5cblxuICAgIGlmICgociA+PSAwKSAmJiAociA8PSAxKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvL1xuICAgIHB4ID0gX194MiArIHIgKiAoX19weCAtIF9feDIpO1xuICAgIHB5ID0gX195MiArIHIgKiAoX19weSAtIF9feTIpO1xuICAgIC8vXG4gICAgcyA9ICgoX195MiAtIF9feTEpICogKF9fcHggLSBfX3gyKSAtIChfX3gyIC0gX194MSkgKiAoX19weSAtIF9feTIpKSAvIHJfZGVub21lbmF0b3I7XG4gICAgZGlzdGFuY2VMaW5lID0gYWJzKHMpICogc3FydChyX2Rlbm9tZW5hdG9yKTtcblxuICAgIHJldHVybiBkaXN0YW5jZUxpbmU7XG59XG5cbmZ1bmN0aW9uIHNlZ21lbnQyX3ZlYzIoc2VnMiwgdmVjMikge1xuICAgIHZhciBBID0gdmVjMlswXSAtIHNlZzJbMF0sXG4gICAgICAgIEIgPSB2ZWMyWzFdIC0gc2VnMlsxXSxcbiAgICAgICAgQyA9IHNlZzJbMl0gLSBzZWcyWzBdLFxuICAgICAgICBEID0gc2VnMlszXSAtIHNlZzJbMV0sXG4gICAgICAgIGRvdCA9IEEgKiBDICsgQiAqIEQsXG4gICAgICAgIGxlbl9zcSA9IEMgKiBDICsgRCAqIEQsXG4gICAgICAgIHBhcmFtID0gZG90IC8gbGVuX3NxLFxuICAgICAgICB4eCxcbiAgICAgICAgeXk7XG5cbiAgICBpZiAocGFyYW0gPCAwKSB7XG4gICAgICAgIHh4ID0gc2VnMlswXTtcbiAgICAgICAgeXkgPSBzZWcyWzFdO1xuICAgIH0gZWxzZSBpZiAocGFyYW0gPiAxKSB7XG4gICAgICAgIHh4ID0gc2VnMlsyXTtcbiAgICAgICAgeXkgPSBzZWcyWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHh4ID0gc2VnMlswXSArIHBhcmFtICogQztcbiAgICAgICAgeXkgPSBzZWcyWzFdICsgcGFyYW0gKiBEO1xuICAgIH1cblxuICAgIHJldHVybiBmb3VyUG9pbnRzKHZlYzJbMF0sIHZlYzJbMV0sIHh4LCB5eSk7XG59XG5cbmZ1bmN0aW9uIHJlY3RhbmdsZV92ZWMyKHJlY3QsIHZlYzIpIHtcbiAgICBSZWN0YW5nbGUubm9ybWFsaXplKHJlY3QsIHJlY3QpO1xuXG4gICAgLypcbiAgICBAVE9ETzogT3B0aW1pemUsIGkgY2FudCBmaW5kIHRoZSByaWdodCBjb21iaW5hdGlvblxuICAgIHZhciBoY2F0ID0gdmVjMi54IDwgcmVjdC52MS54ID8gMCA6ICggdmVjMi54ID4gcmVjdC52Mi54ID8gMiA6IDEgKTtcbiAgICB2YXIgdmNhdCA9IHZlYzIueSA+IHJlY3QudjEueSA/IDAgOiAoIHZlYzIueSA8IHJlY3QudjIueSA/IDIgOiAxICk7XG5cbiAgICBpZihoY2F0ID09IDAgJiYgdmNhdCA9PSAwKSByZXR1cm4gZGlzdGFuY2VfdmVjMl92c192ZWMyKHJlY3QudjEsIHZlYzIpO1xuICAgIGlmKGhjYXQgPT0gMiAmJiB2Y2F0ID09IDIpIHJldHVybiBkaXN0YW5jZV92ZWMyX3ZzX3ZlYzIocmVjdC52MiwgdmVjMik7XG5cbiAgICBpZihoY2F0ID09IDAgJiYgdmNhdCA9PSAyKSByZXR1cm4gZGlzdGFuY2VfdmVjMl92c192ZWMyKG5ldyBWZWMyKHJlY3QudjIueCwgcmVjdC52MS55KSwgdmVjMik7XG4gICAgaWYoaGNhdCA9PSAyICYmIHZjYXQgPT0gMCkgcmV0dXJuIGRpc3RhbmNlX3ZlYzJfdnNfdmVjMihuZXcgVmVjMihyZWN0LnYxLngsIHJlY3QudjIueSksIHZlYzIpO1xuXG4gICAgaWYoaGNhdCA9PSAwICYmIHZjYXQgPT0gMSkgcmV0dXJuIGRpc3RhbmNlX3NlZ21lbnQyX3ZzX3ZlYzIobmV3IFZlYzIocmVjdC52MS54LCByZWN0LnYxLnkpLCBuZXcgVmVjMihyZWN0LnYxLngsIHJlY3QudjIueSkpO1xuICAgIGlmKGhjYXQgPT0gMSAmJiB2Y2F0ID09IDApIHJldHVybiBkaXN0YW5jZV9zZWdtZW50Ml92c192ZWMyKG5ldyBWZWMyKHJlY3QudjEueCwgcmVjdC52MS55KSwgbmV3IFZlYzIocmVjdC52Mi54LCByZWN0LnYxLnkpKTtcblxuICAgIGlmKGhjYXQgPT0gMiAmJiB2Y2F0ID09IDEpIHJldHVybiBkaXN0YW5jZV9zZWdtZW50Ml92c192ZWMyKG5ldyBWZWMyKHJlY3QudjIueCwgcmVjdC52MS55KSwgbmV3IFZlYzIocmVjdC52Mi54LCByZWN0LnYyLnkpKTtcbiAgICBpZihoY2F0ID09IDEgJiYgdmNhdCA9PSAyKSByZXR1cm4gZGlzdGFuY2Vfc2VnbWVudDJfdnNfdmVjMihuZXcgVmVjMihyZWN0LnYxLngsIHJlY3QudjIueSksIG5ldyBWZWMyKHJlY3QudjIueCwgcmVjdC52Mi55KSk7XG4gICAgKi9cblxuICAgIHZhciBzMSA9IFtyZWN0WzBdWzBdLCByZWN0WzBdWzFdLCByZWN0WzBdWzBdLCByZWN0WzFdWzFdXSxcbiAgICAgICAgczIgPSBbcmVjdFswXVswXSwgcmVjdFswXVsxXSwgcmVjdFsxXVswXSwgcmVjdFswXVsxXV0sXG5cbiAgICAgICAgczMgPSBbcmVjdFswXVswXSwgcmVjdFsxXVsxXSwgcmVjdFsxXVswXSwgcmVjdFsxXVsxXV0sXG4gICAgICAgIHM0ID0gW3JlY3RbMV1bMF0sIHJlY3RbMF1bMV0sIHJlY3RbMV1bMF0sIHJlY3RbMV1bMV1dO1xuXG4gICAgcmV0dXJuIG1pbihcbiAgICAgICAgc2VnbWVudDJfdmVjMihzMSwgdmVjMiksXG4gICAgICAgIHNlZ21lbnQyX3ZlYzIoczIsIHZlYzIpLFxuICAgICAgICBzZWdtZW50Ml92ZWMyKHMzLCB2ZWMyKSxcbiAgICAgICAgc2VnbWVudDJfdmVjMihzNCwgdmVjMilcbiAgICApO1xufVxuLypcbiAqIEZpZ3VyZSAyNi4xXG4gKiBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vXG4gKiBAdG9kb1xuICovXG5cbmZ1bmN0aW9uIGJlaXplcl92ZWMyKCkge1xuXG59XG5cbi8qKlxuICogQGNsYXNzIERpc3RhbmNlXG4gKi9cbnZhciBEaXN0YW5jZSA9IHtcbiAgICBmb3VyUG9pbnRzOiBmb3VyUG9pbnRzLFxuICAgIHNxckZvdXJQb2ludHM6IHNxckZvdXJQb2ludHMsXG4gICAgbGluZTJfdmVjMjogbGluZTJfdmVjMixcbiAgICBzZWdtZW50Ml92ZWMyOiBzZWdtZW50Ml92ZWMyLFxuICAgIHJlY3RhbmdsZV92ZWMyOiByZWN0YW5nbGVfdmVjMixcblxuICAgIC8vYWxpYXNcbiAgICBmb3VyUG9pbnRzU3E6IHNxckZvdXJQb2ludHNcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZTsiLCIvKipcbiAqIFV0aWxpdGllcyBmb3IgcmVuZGVyaW5nIGluIENhbnZhc0VsZW1lbnRcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0MmRcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGUgc3Ryb2tlU3R5bGVcbiAqL1xuZnVuY3Rpb24gcmVjdGFuZ2xlKGNvbnRleHQyZCwgcmVjdCwgc3R5bGUpIHtcbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzBdIHx8IHJlY3RbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMV0gfHwgcmVjdFsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVswXSB8fCByZWN0WzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBSZWN0YW5nbGUgcmVjdFwiKVxufVxuXG5pZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzdHlsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0eWxlIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250ZXh0MmQuc3Ryb2tlU3R5bGUgPSBzdHlsZTtcbiAgICB9XG5cbiAgICBjb250ZXh0MmQuc3Ryb2tlUmVjdChyZWN0WzBdWzBdLCByZWN0WzBdWzFdLCByZWN0WzFdWzBdIC0gcmVjdFswXVswXSwgcmVjdFsxXVsxXSAtIHJlY3RbMF1bMV0pO1xufVxuXG5pZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIHZhciBmaWxsVGV4dCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbFRleHQ7XG4gICAgZnVuY3Rpb24gaW52ZXJ0RmlsbFRleHQoYSwgYiwgYykge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgLy9jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgMCk7XG4gICAgICAgIGZpbGxUZXh0LmNhbGwodGhpcywgYSwgYiwgLWMpO1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgIH07XG4gICAgfSkoKTtcbn1cblxuXG5cbi8qKlxuICogY2FsbGluZyB0aGlzIG92ZXJyaWRlIGZpbGxUZXh0IHNvIHlvdSBkaWRuXCJ0IHNlZSBpbnZlcnRlZCB0ZXh0XG4gKiBZb3UgbXVzdCBub3QgbW9kaWZ5IHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggd2l0aG91dCB0aGUgcHJvcGVyIHNhdmUvcmVzdG9yZS5cbiAqIEBwYXJhbSB7Q2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkXG4gKi9cbmZ1bmN0aW9uIGludmVydEF4aXMoY2FudmFzLCBjb250ZXh0MmQpIHtcbiAgICBjb250ZXh0MmQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjb250ZXh0MmQuZmlsbFRleHQgPSBpbnZlcnRGaWxsVGV4dDtcbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyZFxuICogQHBhcmFtIHtOdW1iZXI9fSBjb29yZHNcbiAqIEBwYXJhbSB7TnVtYmVyPX0gY291bnRcbiAqL1xuZnVuY3Rpb24gY2FydGVzaWFuQXhpcyhjb250ZXh0MmQsIGNvb3JkcywgY291bnQpIHtcbmlmIChjb29yZHMgIT09IHVuZGVmaW5lZCkge1xuaWYgKGNvb3JkcyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNvb3JkcykgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjb29yZHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZHMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxufVxuaWYgKGNvdW50ICE9PSB1bmRlZmluZWQpIHtcbmlmIChjb3VudCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNvdW50KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNvdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY291bnQgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxufVxuICAgIGNvbnRleHQyZC5zYXZlKCk7XG5cbiAgICBjb250ZXh0MmQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsIDAuMjUpXCI7XG4gICAgLy9jb250ZXh0MmQuc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuXG4gICAgY29udGV4dDJkLmZvbnQgPSBcIjZwdCBDb25zb2xhc1wiO1xuXG5cbiAgICBjb29yZHMgPSBjb29yZHMgfHwgMzIwO1xuICAgIGNvdW50ID0gY291bnQgfHwgMTY7XG5cbiAgICBjb250ZXh0MmQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dDJkLm1vdmVUbygtY29vcmRzLCAwKTtcbiAgICBjb250ZXh0MmQubGluZVRvKGNvb3JkcywgMCk7XG4gICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQyZC5tb3ZlVG8oMCwgLWNvb3Jkcyk7XG4gICAgY29udGV4dDJkLmxpbmVUbygwLCBjb29yZHMpO1xuICAgIGNvbnRleHQyZC5zdHJva2UoKTtcblxuXG4gICAgaWYgKGNvbnRleHQyZC5zZXRMaW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0MmQuc2V0TGluZURhc2goWzEsIDJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0MmQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsIDAuMTI1KVwiO1xuICAgIH1cblxuICAgIGNvbnRleHQyZC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0MmQubW92ZVRvKC1jb29yZHMsIGNvb3JkcyAqIDAuNSk7XG4gICAgY29udGV4dDJkLmxpbmVUbyhjb29yZHMsIGNvb3JkcyAqIDAuNSk7XG4gICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQyZC5tb3ZlVG8oLWNvb3JkcywgLWNvb3JkcyAqIDAuNSk7XG4gICAgY29udGV4dDJkLmxpbmVUbyhjb29yZHMsIC1jb29yZHMgKiAwLjUpO1xuICAgIGNvbnRleHQyZC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQyZC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0MmQubW92ZVRvKGNvb3JkcyAqIDAuNSwgLWNvb3Jkcyk7XG4gICAgY29udGV4dDJkLmxpbmVUbyhjb29yZHMgKiAwLjUsIGNvb3Jkcyk7XG4gICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQyZC5tb3ZlVG8oLWNvb3JkcyAqIDAuNSwgLWNvb3Jkcyk7XG4gICAgY29udGV4dDJkLmxpbmVUbygtY29vcmRzICogMC41LCBjb29yZHMpO1xuICAgIGNvbnRleHQyZC5zdHJva2UoKTtcblxuXG4gICAgY29udGV4dDJkLnNldExpbmVEYXNoKFtdKTtcblxuXG4gICAgY29udGV4dDJkLnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLCAwLjI1KVwiO1xuXG4gICAgdmFyIGksXG4gICAgICAgIGluYyA9IGNvb3JkcyAqIDIgLyBjb3VudCxcbiAgICAgICAgbWF4ID0gY291bnQsXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICBjb250ZXh0MmQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICBmb3IgKGkgPSAwOyBpIDw9IG1heDsgKytpKSB7XG4gICAgICAgIHggPSAtY29vcmRzICsgaSAqIGluYztcbiAgICAgICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0MmQubW92ZVRvKHgsIDQpO1xuICAgICAgICBjb250ZXh0MmQubGluZVRvKHgsIC00KTtcbiAgICAgICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgICAgIGlmICh4ICE9PSAwKSB7XG4gICAgICAgICAgICBjb250ZXh0MmQuZmlsbFRleHQoeCwgeCwgLTEyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQyZC5maWxsVGV4dChcIigwLDApXCIsIDAsIC0xMik7XG5cbiAgICBjb250ZXh0MmQudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgZm9yIChpID0gMDsgaSA8PSBtYXg7ICsraSkge1xuICAgICAgICB5ID0gLWNvb3JkcyArIGkgKiBpbmM7XG4gICAgICAgIGNvbnRleHQyZC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dDJkLm1vdmVUbyg0LCB5KTtcbiAgICAgICAgY29udGV4dDJkLmxpbmVUbygtNCwgeSk7XG4gICAgICAgIGNvbnRleHQyZC5zdHJva2UoKTtcblxuICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgY29udGV4dDJkLmZpbGxUZXh0KHksICsxMiwgeSAtIDQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dDJkLnJlc3RvcmUoKTtcbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyZFxuICogQHBhcmFtIHtDaXJjbGV9IGNpcmNsZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlIHN0cm9rZVN0eWxlL2ZpbGxTdHlsZVxuICogQHBhcmFtIHtCb29sZWFuPX0gZmlsbFxuICovXG5mdW5jdGlvbiBjaXJjbGUoY29udGV4dDJkLCBjaXJjbGUsIHN0eWxlLCBmaWxsKSB7XG5pZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzdHlsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0eWxlIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBmaWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmlsbCBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbn1cbiAgICBjb250ZXh0MmQuc2F2ZSgpO1xuXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZmlsbCA/IGNvbnRleHQyZC5maWxsU3R5bGUgPSBzdHlsZSA6IGNvbnRleHQyZC5zdHJva2VTdHlsZSA9IHN0eWxlO1xuICAgIH1cblxuICAgIGNvbnRleHQyZC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0MmQuYXJjKGNpcmNsZVswXVswXSwgY2lyY2xlWzBdWzFdLCBjaXJjbGVbMV0sIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQyZC5hcmMoY2lyY2xlWzBdWzBdLCBjaXJjbGVbMF1bMV0sIDEsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgZmlsbCA/IGNvbnRleHQyZC5maWxsKCkgOiBjb250ZXh0MmQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0MmQucmVzdG9yZSgpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkXG4gKiBAcGFyYW0ge0xpbmUyfSBsaW5lMlxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlIHN0cm9rZVN0eWxlXG4gKiBAcGFyYW0ge051bWJlcj19IGxlbmd0aFxuICovXG5mdW5jdGlvbiBsaW5lMihjb250ZXh0MmQsIGxpbmUyLCBzdHlsZSwgbGVuZ3RoKSB7XG5pZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzdHlsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0eWxlIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuaWYgKGxlbmd0aCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGxlbmd0aCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxufVxuICAgIGNvbnRleHQyZC5zYXZlKCk7XG5cbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250ZXh0MmQuc3Ryb2tlU3R5bGUgPSBzdHlsZTtcbiAgICB9XG5cbiAgICBjb250ZXh0MmQuYmVnaW5QYXRoKCk7XG4gICAgdmFyIG0gPSBsaW5lMlsxXTtcbiAgICBsZW5ndGggPSBsZW5ndGggfHwgMTAwO1xuXG4gICAgY29udGV4dDJkLm1vdmVUbyhsaW5lMlswXVswXSAtIChsZW5ndGggKiBtKSwgbGluZTJbMF1bMV0gLSBsZW5ndGgpO1xuICAgIGNvbnRleHQyZC5saW5lVG8obGluZTJbMF1bMF0gKyAobGVuZ3RoICogbSksIGxpbmUyWzBdWzFdICsgbGVuZ3RoKTtcbiAgICBjb250ZXh0MmQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0MmQucmVzdG9yZSgpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZSBzdHJva2VTdHlsZVxuICogQHBhcmFtIHtOdW1iZXI9fSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gdmVjMihjb250ZXh0MmQsIHZlYzIsIHN0eWxlLCBsZW5ndGgpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG5pZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzdHlsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0eWxlIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuaWYgKGxlbmd0aCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGxlbmd0aCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxufVxuICAgIGNvbnRleHQyZC5zYXZlKCk7XG5cbiAgICBsZW5ndGggPSBsZW5ndGggfHwgMjtcblxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHQyZC5zdHJva2VTdHlsZSA9IHN0eWxlO1xuICAgIH1cblxuICAgIGNvbnRleHQyZC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0MmQubW92ZVRvKHZlYzJbMF0gKyBsZW5ndGgsIHZlYzJbMV0gKyBsZW5ndGgpO1xuICAgIGNvbnRleHQyZC5saW5lVG8odmVjMlswXSAtIGxlbmd0aCwgdmVjMlsxXSAtIGxlbmd0aCk7XG4gICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQyZC5tb3ZlVG8odmVjMlswXSAtIGxlbmd0aCwgdmVjMlsxXSArIGxlbmd0aCk7XG4gICAgY29udGV4dDJkLmxpbmVUbyh2ZWMyWzBdICsgbGVuZ3RoLCB2ZWMyWzFdIC0gbGVuZ3RoKTtcbiAgICBjb250ZXh0MmQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0MmQucmVzdG9yZSgpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkXG4gKiBAcGFyYW0ge1ZlYzJ9IG9yaWdpblxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcGFyYW0ge051bWJlcj19IGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlIHN0cm9rZVN0eWxlXG4gKi9cbmZ1bmN0aW9uIHZlYzJkaXIoY29udGV4dDJkLCBvcmlnaW4sIHZlYzIsIGxlbmd0aCwgc3R5bGUpIHtcbmlmICghQXJyYXkuaXNBcnJheShvcmlnaW4pIHx8IG9yaWdpblswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG9yaWdpblswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvcmlnaW5bMF0gfHwgb3JpZ2luWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3JpZ2luWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG9yaWdpblsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvcmlnaW5cIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbmlmIChsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuaWYgKGxlbmd0aCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGxlbmd0aCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxufVxuaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3R5bGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHlsZSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgY29udGV4dDJkLnNhdmUoKTtcblxuICAgIGxlbmd0aCA9IGxlbmd0aCB8fCAyO1xuXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGV4dDJkLnN0cm9rZVN0eWxlID0gc3R5bGU7XG4gICAgfVxuXG4gICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQyZC5tb3ZlVG8ob3JpZ2luWzBdLCBvcmlnaW5bMV0pO1xuICAgIGNvbnRleHQyZC5saW5lVG8ob3JpZ2luWzBdICsgdmVjMlswXSAqIGxlbmd0aCwgb3JpZ2luWzFdICsgdmVjMlsxXSAqIGxlbmd0aCk7XG4gICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgY29udGV4dDJkLnJlc3RvcmUoKTtcbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyZFxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZSBzdHJva2VTdHlsZVxuICogQHBhcmFtIHtOdW1iZXI9fSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gYW5nbGUoY29udGV4dDJkLCB2ZWMyLCBhbmdsZSwgc3R5bGUsIGxlbmd0aCkge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbmlmIChhbmdsZSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFuZ2xlKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFuZ2xlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYW5nbGUgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3R5bGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHlsZSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAobGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbmlmIChsZW5ndGggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihsZW5ndGgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbn1cbiAgICBjb250ZXh0MmQuc2F2ZSgpO1xuXG4gICAgbGVuZ3RoID0gbGVuZ3RoIHx8IDEwO1xuXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGV4dDJkLnN0cm9rZVN0eWxlID0gc3R5bGU7XG4gICAgfVxuXG4gICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQyZC5tb3ZlVG8odmVjMlswXSArIDIsIHZlYzJbMV0gKyAyKTtcbiAgICBjb250ZXh0MmQubGluZVRvKHZlYzJbMF0gLSAyLCB2ZWMyWzFdIC0gMik7XG4gICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQyZC5tb3ZlVG8odmVjMlswXSwgdmVjMlsxXSk7XG4gICAgY29udGV4dDJkLmxpbmVUbyh2ZWMyWzBdICsgTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLCB2ZWMyWzFdICsgTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoKTtcbiAgICBjb250ZXh0MmQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0MmQucmVzdG9yZSgpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGUgc3Ryb2tlU3R5bGVcbiAqL1xuZnVuY3Rpb24gc2VnbWVudDIoY29udGV4dDJkLCBzZWcyLCBzdHlsZSkge1xuaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3R5bGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHlsZSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgY29udGV4dDJkLnNhdmUoKTtcblxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHQyZC5zdHJva2VTdHlsZSA9IHN0eWxlO1xuICAgIH1cblxuICAgIGNvbnRleHQyZC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0MmQubW92ZVRvKHNlZzJbMF0sIHNlZzJbMV0pO1xuICAgIGNvbnRleHQyZC5saW5lVG8oc2VnMlsyXSwgc2VnMlszXSk7XG4gICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG5cbiAgICBjb250ZXh0MmQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dDJkLmFyYyhzZWcyWzBdLCBzZWcyWzFdLCAxLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgIGNvbnRleHQyZC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQyZC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0MmQuYXJjKHNlZzJbMl0sIHNlZzJbM10sIDEsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgY29udGV4dDJkLnJlc3RvcmUoKTtcblxufVxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkXG4gKiBAcGFyYW0ge1RyaWFuZ2xlfSB0cmlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZSBzdHJva2VTdHlsZS9maWxsU3R5bGVcbiAqIEBwYXJhbSB7Qm9vbGVhbj19IGZpbGxcbiAqL1xuZnVuY3Rpb24gdHJpYW5nbGUoY29udGV4dDJkLCB0cmksIHN0eWxlLCBmaWxsKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodHJpKSB8fCB0cmlbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzBdIHx8IHRyaVswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMF1bMV0gfHwgdHJpWzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVswXSB8fCB0cmlbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzFdWzFdIHx8IHRyaVsyXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMF0gfHwgdHJpWzJdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzJdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsyXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVHJhaW5nbGUgdHJpXCIpXG59XG5cbmlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHN0eWxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3R5bGUgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGZpbGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWxsIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxufVxuICAgIGNvbnRleHQyZC5zYXZlKCk7XG5cbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmaWxsID8gY29udGV4dDJkLmZpbGxTdHlsZSA9IHN0eWxlIDogY29udGV4dDJkLnN0cm9rZVN0eWxlID0gc3R5bGU7XG4gICAgfVxuXG4gICAgY29udGV4dDJkLmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQyZC5saW5lVG8odHJpWzFdWzBdLCB0cmlbMV1bMV0pO1xuICAgIGNvbnRleHQyZC5saW5lVG8odHJpWzJdWzBdLCB0cmlbMl1bMV0pO1xuICAgIGNvbnRleHQyZC5saW5lVG8odHJpWzBdWzBdLCB0cmlbMF1bMV0pO1xuICAgIGNvbnRleHQyZC5saW5lVG8odHJpWzFdWzBdLCB0cmlbMV1bMV0pO1xuICAgIGZpbGwgPyBjb250ZXh0MmQuZmlsbCgpIDogY29udGV4dDJkLnN0cm9rZSgpO1xuXG4gICAgY29udGV4dDJkLnJlc3RvcmUoKTtcbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyZFxuICogQHBhcmFtIHtBQUJCMn0gYWFiYjJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZSBzdHJva2VTdHlsZS9maWxsU3R5bGVcbiAqIEBwYXJhbSB7Qm9vbGVhbj19IGZpbGxcbiAqL1xuZnVuY3Rpb24gYWFiYjIoY29udGV4dDJkLCBhYWJiMiwgc3R5bGUsIGZpbGwpIHtcbmlmICghQXJyYXkuaXNBcnJheShhYWJiMikgfHwgYWFiYjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlswXSB8fCBhYWJiMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzFdIHx8IGFhYmIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMl0gfHwgYWFiYjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJcIilcbn1cblxuaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3R5bGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHlsZSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgZmlsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpbGwgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG59XG4gICAgY29udGV4dDJkLnNhdmUoKTtcblxuXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZmlsbCA/IGNvbnRleHQyZC5maWxsU3R5bGUgPSBzdHlsZSA6IGNvbnRleHQyZC5zdHJva2VTdHlsZSA9IHN0eWxlO1xuICAgIH1cblxuICAgIGNvbnRleHQyZC5zdHJva2VSZWN0KGFhYmIyWzBdLCBhYWJiMlsxXSwgYWFiYjJbMl0gLSBhYWJiMlswXSwgYWFiYjJbM10gLSBhYWJiMlsxXSk7XG5cbiAgICBjb250ZXh0MmQucmVzdG9yZSgpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZSBzdHJva2VTdHlsZS9maWxsU3R5bGVcbiAqIEBwYXJhbSB7Qm9vbGVhbj19IGZpbGxcbiAqL1xuZnVuY3Rpb24gcG9seWdvbihjb250ZXh0MmQsIHBvbHksIHN0eWxlLCBmaWxsKSB7XG5pZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzdHlsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0eWxlIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBmaWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmlsbCBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbn1cbiAgICBjb250ZXh0MmQuc2F2ZSgpO1xuXG4gICAgaWYgKHBvbHkubGVuZ3RoIDwgMykge1xuICAgICAgICBmaWxsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZmlsbCA/IGNvbnRleHQyZC5maWxsU3R5bGUgPSBzdHlsZSA6IGNvbnRleHQyZC5zdHJva2VTdHlsZSA9IHN0eWxlO1xuICAgIH1cblxuICAgIGNvbnRleHQyZC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0MmQubW92ZVRvKHBvbHlbMF1bMF0sIHBvbHlbMF1bMV0pO1xuICAgIHZhciBpLFxuICAgICAgICBtYXg7XG5cbiAgICBmb3IgKGkgPSAxLCBtYXggPSBwb2x5Lmxlbmd0aDsgaSA8IG1heDsgKytpKSB7XG4gICAgICAgIGNvbnRleHQyZC5saW5lVG8ocG9seVtpXVswXSwgcG9seVtpXVsxXSk7XG4gICAgfVxuXG4gICAgY29udGV4dDJkLmxpbmVUbyhwb2x5WzBdWzBdLCBwb2x5WzBdWzFdKTtcbiAgICBmaWxsID8gY29udGV4dDJkLmZpbGwoKSA6IGNvbnRleHQyZC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQyZC5yZXN0b3JlKCk7XG59XG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0MmRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzIgcG9zaXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nPX0gZm9udFxuICovXG5mdW5jdGlvbiB0ZXh0KGNvbnRleHQyZCwgdGV4dCwgdmVjMiwgZm9udCkge1xuaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgdGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInRleHQgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbmlmIChmb250ICE9PSB1bmRlZmluZWQpIHtcbmlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGZvbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb250IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbn1cbiAgICBmb250ID0gZm9udCB8fCBcIjEwcHQgQ29uc29sYXNcIjtcbiAgICBjb250ZXh0MmQuZm9udCA9IGZvbnQ7XG5cbiAgICBjb250ZXh0MmQuZmlsbFRleHQodGV4dCwgdmVjMlswXSwgdmVjMlsxXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0MmRcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZFxuICovXG5mdW5jdGlvbiBhcHBseU1hdHJpeDIzKGNvbnRleHQyZCwgbTJkKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbiAgICBjb250ZXh0MmQuc2V0VHJhbnNmb3JtKG0yZFswXSwgbTJkWzFdLCBtMmRbMl0sIG0yZFszXSwgbTJkWzRdLCBtMmRbNV0pO1xufVxuXG5cbnZhciBEcmF3ID0ge1xuICAgIGludmVydEF4aXM6IGludmVydEF4aXMsXG4gICAgY2FydGVzaWFuQXhpczogY2FydGVzaWFuQXhpcyxcblxuICAgIHZlYzI6IHZlYzIsXG4gICAgdmVjMmRpcjogdmVjMmRpcixcbiAgICByZWN0YW5nbGU6IHJlY3RhbmdsZSxcbiAgICBjaXJjbGU6IGNpcmNsZSxcbiAgICBsaW5lMjogbGluZTIsXG4gICAgdHJpYW5nbGU6IHRyaWFuZ2xlLFxuICAgIGFuZ2xlOiBhbmdsZSxcbiAgICBzZWdtZW50Mjogc2VnbWVudDIsXG4gICAgYWFiYjI6IGFhYmIyLFxuICAgIHBvbHlnb246IHBvbHlnb24sXG5cbiAgICBhcHBseU1hdHJpeDIzOiBhcHBseU1hdHJpeDIzLFxuXG4gICAgdGV4dDogdGV4dFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmF3O1xuIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoXCIuL3JlY3RhbmdsZS5qc1wiKSxcbiAgICBEaXN0YW5jZSA9IHJlcXVpcmUoXCIuL2Rpc3RhbmNlLmpzXCIpLFxuICAgIFNlZ21lbnQyID0gcmVxdWlyZShcIi4vc2VnbWVudDIuanNcIiksXG4gICAgc2VnbWVudDIkaW5zaWRlID0gU2VnbWVudDIuJGluc2lkZSxcbiAgICBBQUJCMiA9IHJlcXVpcmUoXCIuL2FhYmIyLmpzXCIpLFxuICAgIFZlYzIgPSByZXF1aXJlKFwiLi92ZWMyLmpzXCIpLFxuICAgIGFicyA9IE1hdGguYWJzLFxuICAgIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgbWF4ID0gTWF0aC5tYXgsXG4gICAgbWluID0gTWF0aC5taW4sXG4gICAgRVBTID0gTWF0aC5FUFMsXG4gICAgYXV4X3ZlYzIgPSBbMCwgMF0sXG5cbiAgICAvL2NhY2hlXG4gICAgT1VUU0lERSA9IDEsIC8vIG5vIGNvbGxpc2lvblxuICAgIFBBUkFMTEVMID0gMiwgLy8gbm8gY29sbGlzaW9uXG4gICAgSU5TSURFID0gNCwgLy8gbm8gY29sbGlzaW9uXG4gICAgQ09MTElERSA9IDgsIC8vIGNvbGxpc2lvblxuICAgIENPSU5DSURFTlQgPSAxNiwgIC8vIGNvbGxpc2lvblxuICAgIFRBTkdFTlQgPSAzMjsgLy8gY29sbGlzaW9uXG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuICogQHBhcmFtIHtOdW1iZXJ9IG51bTJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG5lYXIobnVtLCBudW0yKSB7XG5pZiAobnVtID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obnVtKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG51bSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm51bSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAobnVtMiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG51bTIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbnVtMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm51bTIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiBudW0gPiBudW0yIC0gRVBTICYmIG51bSA8IG51bTIgKyBFUFM7XG59XG5cbi8vXG4vLyBoZWxwZXJzXG4vL1xuXG4vKipcbiAqIHgxIDwgeDNcbiAqXG4gKiBAVE9ETyBkaXN0YW5jZVxuICogQFRPRE8gc2VnbWVudCBjb2xsaXNpb24sIG1heWJlIHVzaW5nIHNlZ21lbnQtc2VnbWVudCBjb2xsaXNpb24sIHRoaXMgY291bGQgc2xvdyBkb3duIHRoaW5ncyFcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geDFcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gKiBAcGFyYW0ge051bWJlcn0geTJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4M1xuICogQHBhcmFtIHtOdW1iZXJ9IHkzXG4gKiBAcGFyYW0ge051bWJlcn0geDRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5NFxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gJHJlY3RhbmdsZV9yZWN0YW5nbGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBjb2xsaXNpb24sIGRpc3RhbmNlKSB7XG5pZiAoeDEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHgyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeDQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4NCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4NCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIng0IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5NCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHk0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHk0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTQgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGNvbGxpc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxpc2lvbiBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBkaXN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRpc3RhbmNlIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuICAgIHZhciBwb2ludHMsXG4gICAgICAgIHhfaW5zaWRlLFxuICAgICAgICB5X2luc2lkZTtcblxuICAgIGlmICh4MiA8IHgzIHx8IHkxID4geTQgfHwgeTIgPCB5Mykge1xuICAgICAgICByZXR1cm4ge3JlYXNvbiA6IE9VVFNJREV9O1xuICAgIH1cblxuICAgIHhfaW5zaWRlID0geDEgPCB4MyAmJiB4MiA+IHg0O1xuICAgIHlfaW5zaWRlID0geTEgPCB5MyAmJiB5MiA+IHk0O1xuXG4gICAgaWYgKHhfaW5zaWRlICYmIHlfaW5zaWRlKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uIDogSU5TSURFfTtcbiAgICB9XG5cbiAgICBpZiAoY29sbGlzaW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4ge3JlYXNvbjogQ09MTElERX07XG4gICAgfVxuXG4gICAgLy8gY29tcGxleCBjYXNlcywgNCBwb2ludCBjb2xsaXNpb25cbiAgICBpZiAoeTEgPiB5MyAmJiAoeF9pbnNpZGUgfHwgeV9pbnNpZGUpKSB7XG4gICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIFttYXgoeDEsIHgzKSwgbWF4KHkxLCB5MyldLFxuICAgICAgICAgICAgW21pbih4MiwgeDQpLCBtaW4oeTIsIHk0KV0sXG4gICAgICAgICAgICBbbWluKHgyLCB4NCksIG1heCh5MSwgeTMpXSxcbiAgICAgICAgICAgIFttYXgoeDEsIHgzKSwgbWluKHkyLCB5NCldXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy9iYXNlIGNhc2VcbiAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAgW21pbih4MiwgeDQpLCBtYXgoeTEsIHkzKV0sXG4gICAgICAgICAgICBbbWF4KHgxLCB4MyksIG1pbih5MiwgeTQpXVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB7cmVhc29uOiBDT0xMSURFLCBwb2ludHMgOiBwb2ludHN9O1xufVxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0geDFcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gKiBAcGFyYW0ge051bWJlcn0geTJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4M1xuICogQHBhcmFtIHtOdW1iZXJ9IHkzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbGxpc2lvblxuICogQHBhcmFtIHtCb29sZWFufSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiAkcmVjdGFuZ2xlX3ZlYzIoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgY29sbGlzaW9uLCBkaXN0YW5jZSkge1xuaWYgKHgxID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDEpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeDMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MykgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4Mykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGNvbGxpc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxpc2lvbiBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBkaXN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRpc3RhbmNlIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuICAgIGlmICh4MSA+IHgzIHx8IHgyIDwgeDMgfHwgeTEgPiB5MyB8fCB5MiA8IHkzKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uOiBPVVRTSURFfTtcbiAgICAgICAgLy8gVE9ETyBkaXN0YW5jZTogZGlzdGFuY2UgPyBEaXN0YW5jZS5yZWN0YW5nbGVfdmVjMihyZWN0YW5nbGUsIHZlYzIpIDogbnVsbFxuICAgIH1cblxuICAgIC8vaWYgKGJiWzBdIDw9IHZbMF0gJiYgYmJbMl0gPj0gdlswXSAmJiBiYlsxXSA8PSB2WzFdICYmIGJiWzNdID49IHZbMV0pO1xuICAgIGlmICh4MSA8IHgzICYmIHgyID4geDMgJiYgeTEgPCB5MyAmJiB5MiA+IHkzKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uOiBJTlNJREV9O1xuICAgICAgICAvLyBUT0RPIGRpc3RhbmNlOiBkaXN0YW5jZSA/IERpc3RhbmNlLnJlY3RhbmdsZV92ZWMyKHJlY3RhbmdsZSwgdmVjMikgOiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHtyZWFzb246IENPTExJREUsIHBvaW50cyA6IFtbeDMsIHkzXV19O1xufVxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gY3hcbiAqIEBwYXJhbSB7TnVtYmVyfSBjeVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gKiBAcGFyYW0ge051bWJlcn0geDJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gJGNpcmNsZV9zZWdtZW50MihjeCwgY3ksIHIsIHgxLCB5MSwgeDIsIHkyLCBjb2xsaXNpb24sIGRpc3RhbmNlKSB7XG5pZiAoY3ggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjeCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChjeSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGN5KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGN5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3kgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkxID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTEpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeDIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGNvbGxpc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxpc2lvbiBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBkaXN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRpc3RhbmNlIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuXG4gICAgdmFyIGN4MSA9IHgxIC0gY3gsXG4gICAgICAgIGN5MSA9IHkxIC0gY3ksXG4gICAgICAgIGN4MiA9IHgyIC0gY3gsXG4gICAgICAgIGN5MiA9IHkyIC0gY3ksXG5cbiAgICAgICAgZHggPSBjeDIgLSBjeDEsXG4gICAgICAgIGR5ID0gY3kyIC0gY3kxLFxuICAgICAgICBhID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICAgIGIgPSAyICogKChkeCAqIGN4MSkgKyAoZHkgKiBjeTEpKSxcbiAgICAgICAgYyA9IChjeDEgKiBjeDEpICsgKGN5MSAqIGN5MSkgLSAociAqIHIpLFxuICAgICAgICBkZWx0YSA9IGIgKiBiIC0gKDQgKiBhICogYyksXG4gICAgICAgIHUsXG4gICAgICAgIHUxLFxuICAgICAgICB1MixcbiAgICAgICAgZGVsdGFzcXJ0LFxuICAgICAgICBwLFxuICAgICAgICBwb2ludHM7XG5cbiAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgICByZXR1cm4ge3JlYXNvbjogT1VUU0lERX07XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgIC8vIE9uZSBpbnRlcnNlY3Rpb25cbiAgICAgICAgaWYgKGNvbGxpc2lvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7cmVhc29uOiBUQU5HRU5UfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHUgPSAtYiAvICgyICogYSk7XG5cbiAgICAgICAgcCA9IFt4MSArICh1ICogZHgpLCB5MSArICh1ICogZHkpXTtcblxuICAgICAgICBpZiAoc2VnbWVudDIkaW5zaWRlKHgxLCB5MSwgeDIsIHkyLCBwWzBdLCBwWzFdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtyZWFzb246IFRBTkdFTlQsIHBvaW50czogW3BdfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7cmVhc29uOiBPVVRTSURFfTtcblxuXG4gICAgICAgIC8qIFVzZSBMaW5lUDEgaW5zdGVhZCBvZiBMb2NhbFAxIGJlY2F1c2Ugd2Ugd2FudCBvdXIgYW5zd2VyIGluIGdsb2JhbFxuICAgICAgICAgICBzcGFjZSwgbm90IHRoZSBjaXJjbGUncyBsb2NhbCBzcGFjZSAqL1xuICAgIH1cblxuICAgIC8vIE5PVEUgZG8gbm90IHRlc3QgY29sbGlzaW9uID09PSBmYWxzZSwgaGVyZSwgdGhlcmUgaXMgbm8gcGVyZm9ybWFuY2UgZ2FpbiBoZXJlLlxuICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgLy8gVHdvIGludGVyc2VjdGlvbnNcbiAgICAgICAgZGVsdGFzcXJ0ID0gc3FydChkZWx0YSk7XG5cbiAgICAgICAgdTEgPSAoLWIgKyBkZWx0YXNxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgdTIgPSAoLWIgLSBkZWx0YXNxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgICBwb2ludHMgPSBbXTtcblxuICAgICAgICBwID0gW3gxICsgKHUxICogZHgpLCB5MSArICh1MSAqIGR5KV07XG5cbiAgICAgICAgaWYgKHNlZ21lbnQyJGluc2lkZSh4MSwgeTEsIHgyLCB5MiwgcFswXSwgcFsxXSkpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcCA9IFt4MSArICh1MiAqIGR4KSwgeTEgKyAodTIgKiBkeSldO1xuXG4gICAgICAgIGlmIChzZWdtZW50MiRpbnNpZGUoeDEsIHkxLCB4MiwgeTIsIHBbMF0sIHBbMV0pKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge3JlYXNvbjogQ09MTElERSwgcG9pbnRzOiBwb2ludHN9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtyZWFzb246IE9VVFNJREV9O1xuICAgIH1cblxufVxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gY3hcbiAqIEBwYXJhbSB7TnVtYmVyfSBjeVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gKiBAcGFyYW0ge051bWJlcn0geDJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gJGNpcmNsZV9yZWN0YW5nbGUoY3gsIGN5LCByLCB4MSwgeTEsIHgyLCB5MiwgY29sbGlzaW9uLCBkaXN0YW5jZSkge1xuaWYgKGN4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY3gpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgY3gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjeCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoY3kgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihjeSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocikgfHwgJ251bWJlcicgIT09IHR5cGVvZiByKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiciBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeDEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHgyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBjb2xsaXNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsaXNpb24gaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgZGlzdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXN0YW5jZSBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbiAgICB2YXIgcG9pbnRzID0gW10sXG4gICAgICAgIHIyLFxuICAgICAgICBjb2xsaWRlID0gZmFsc2U7XG5cbiAgICAvLyBUT0RPIGluc2lkZSB0ZXN0XG5cbiAgICByMiA9ICRjaXJjbGVfc2VnbWVudDIoY3gsIGN5LCByLCB4MSwgeTEsIHgyLCB5MSwgY29sbGlzaW9uLCBkaXN0YW5jZSk7XG5cbiAgICBpZiAocjIucmVhc29uID49IENPTExJREUpIHtcbiAgICAgICAgY29sbGlkZSA9IHRydWU7XG4gICAgICAgIGlmIChjb2xsaXNpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHIyLnBvaW50c1swXSk7XG4gICAgICAgICAgICBpZiAocjIucG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHIyLnBvaW50c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByMiA9ICRjaXJjbGVfc2VnbWVudDIoY3gsIGN5LCByLCB4MSwgeTEsIHgxLCB5MiwgY29sbGlzaW9uLCBkaXN0YW5jZSk7XG5cbiAgICBpZiAocjIucmVhc29uID49IENPTExJREUpIHtcbiAgICAgICAgY29sbGlkZSA9IHRydWU7XG4gICAgICAgIGlmIChjb2xsaXNpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHIyLnBvaW50c1swXSk7XG4gICAgICAgICAgICBpZiAocjIucG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHIyLnBvaW50c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByMiA9ICRjaXJjbGVfc2VnbWVudDIoY3gsIGN5LCByLCB4MSwgeTIsIHgyLCB5MiwgY29sbGlzaW9uLCBkaXN0YW5jZSk7XG5cbiAgICBpZiAocjIucmVhc29uID49IENPTExJREUpIHtcbiAgICAgICAgY29sbGlkZSA9IHRydWU7XG4gICAgICAgIGlmIChjb2xsaXNpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHIyLnBvaW50c1swXSk7XG4gICAgICAgICAgICBpZiAocjIucG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHIyLnBvaW50c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByMiA9ICRjaXJjbGVfc2VnbWVudDIoY3gsIGN5LCByLCB4MiwgeTEsIHgyLCB5MiwgY29sbGlzaW9uLCBkaXN0YW5jZSk7XG5cbiAgICBpZiAocjIucmVhc29uID49IENPTExJREUpIHtcbiAgICAgICAgY29sbGlkZSA9IHRydWU7XG4gICAgICAgIGlmIChjb2xsaXNpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHIyLnBvaW50c1swXSk7XG4gICAgICAgICAgICBpZiAocjIucG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHIyLnBvaW50c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29sbGlkZSkge1xuICAgICAgICBpZiAocG9pbnRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtyZWFzb246IENPTExJREV9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtyZWFzb246IENPTExJREUsIHBvaW50czogcG9pbnRzfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge3JlYXNvbjogT1VUU0lERX07XG59XG4vKipcbiAqIEBwYXJhbSB7QUFCQjJ9IGJiMl8xXG4gKiBAcGFyYW0ge0FBQkIyfSBiYjJfMlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gYmIyX2JiMihiYjJfMSwgYmIyXzIsIGNvbGxpc2lvbiwgZGlzdGFuY2UpIHtcbmlmICghQXJyYXkuaXNBcnJheShiYjJfMSkgfHwgYmIyXzFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJfMVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJfMVswXSB8fCBiYjJfMVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMl8xWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMl8xWzFdIHx8IGJiMl8xWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyXzFbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyXzFbMl0gfHwgYmIyXzFbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJfMVszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJfMVszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYmIyXzFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGJiMl8yKSB8fCBiYjJfMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMl8yWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMl8yWzBdIHx8IGJiMl8yWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyXzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyXzJbMV0gfHwgYmIyXzJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJfMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJfMlsyXSB8fCBiYjJfMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMl8yWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMl8yWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBiYjJfMlwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgQUFCQjIubm9ybWFsaXplKGJiMl8xLCBiYjJfMSk7XG4gICAgQUFCQjIubm9ybWFsaXplKGJiMl8yLCBiYjJfMik7XG5cbiAgICAvLyB4MSBzaG91bGQgYmUgZnVydGhlciBsZWZ0IVxuICAgIGlmIChiYjJfMlswXSA8IGJiMl8xWzBdKSB7XG4gICAgICAgIHJldHVybiAkcmVjdGFuZ2xlX3JlY3RhbmdsZShcbiAgICAgICAgICAgIGJiMl8yWzBdLCBiYjJfMlsxXSwgYmIyXzJbMl0sIGJiMl8yWzNdLFxuICAgICAgICAgICAgYmIyXzFbMF0sIGJiMl8xWzFdLCBiYjJfMVsyXSwgYmIyXzFbM10sXG4gICAgICAgICAgICBjb2xsaXNpb24gPT09IHRydWUsXG4gICAgICAgICAgICBkaXN0YW5jZSA9PT0gdHJ1ZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAkcmVjdGFuZ2xlX3JlY3RhbmdsZShcbiAgICAgICAgYmIyXzFbMF0sIGJiMl8xWzFdLCBiYjJfMVsyXSwgYmIyXzFbM10sXG4gICAgICAgIGJiMl8yWzBdLCBiYjJfMlsxXSwgYmIyXzJbMl0sIGJiMl8yWzNdLFxuICAgICAgICBjb2xsaXNpb24gPT09IHRydWUsXG4gICAgICAgIGRpc3RhbmNlID09PSB0cnVlXG4gICAgKTtcbn1cbi8qKlxuICogQHBhcmFtIHtBQUJCMn0gYmIyXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGlzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGJiMl92ZWMyKGJiMiwgdmVjMiwgY29sbGlzaW9uLCBkaXN0YW5jZSkge1xuaWYgKCFBcnJheS5pc0FycmF5KGJiMikgfHwgYmIyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlswXSB8fCBiYjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyWzFdIHx8IGJiMlsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbMl0gfHwgYmIyWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYmIyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgcmV0dXJuICRyZWN0YW5nbGVfdmVjMihiYjJbMF0sIGJiMlsxXSwgYmIyWzJdLCBiYjJbM10sIHZlYzJbMF0sIHZlYzJbMV0sIGNvbGxpc2lvbiA9PT0gdHJ1ZSwgZGlzdGFuY2UgPT09IHRydWUpO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7QUFCQjJ9IGJiMlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gdmVjMl9iYjIodmVjMiwgYmIyLCBjb2xsaXNpb24sIGRpc3RhbmNlKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGJiMikgfHwgYmIyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlswXSB8fCBiYjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyWzFdIHx8IGJiMlsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbMl0gfHwgYmIyWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYmIyXCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBjb2xsaXNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsaXNpb24gaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgZGlzdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXN0YW5jZSBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbiAgICByZXR1cm4gJHJlY3RhbmdsZV92ZWMyKGJiMlswXSwgYmIyWzFdLCBiYjJbMl0sIGJiMlszXSwgdmVjMlswXSwgdmVjMlsxXSwgY29sbGlzaW9uID09PSB0cnVlLCBkaXN0YW5jZSA9PT0gdHJ1ZSk7XG59XG5cbi8qKlxuICogQFRPRE8gc2VnbWVudHMgb2YgY29sbGlzaW9uXG4gKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QxXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdDJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGlzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHJlY3RhbmdsZV9yZWN0YW5nbGUocmVjdDEsIHJlY3QyLCBjb2xsaXNpb24sIGRpc3RhbmNlKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkocmVjdDEpIHx8IHJlY3QxWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdDFbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdDFbMF1bMF0gfHwgcmVjdDFbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0MVswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0MVswXVsxXSB8fCByZWN0MVsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3QxWzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3QxWzFdWzBdIHx8IHJlY3QxWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdDFbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdDFbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSByZWN0MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkocmVjdDIpIHx8IHJlY3QyWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdDJbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdDJbMF1bMF0gfHwgcmVjdDJbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0MlswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0MlswXVsxXSB8fCByZWN0MlsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3QyWzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3QyWzFdWzBdIHx8IHJlY3QyWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdDJbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdDJbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSByZWN0MlwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgUmVjdGFuZ2xlLm5vcm1hbGl6ZShyZWN0MSwgcmVjdDEpO1xuICAgIFJlY3RhbmdsZS5ub3JtYWxpemUocmVjdDIsIHJlY3QyKTtcblxuICAgIC8vIHIxIHNob3VsZCBiZSBmdXJ0aGVyIGxlZnQhXG4gICAgaWYgKHJlY3QyWzBdWzBdIDwgcmVjdDFbMF1bMF0pIHtcbiAgICAgICAgcmV0dXJuICRyZWN0YW5nbGVfcmVjdGFuZ2xlKFxuICAgICAgICAgICAgcmVjdDJbMF1bMF0sIHJlY3QyWzBdWzFdLCByZWN0MlsxXVswXSwgcmVjdDJbMV1bMV0sXG4gICAgICAgICAgICByZWN0MVswXVswXSwgcmVjdDFbMF1bMV0sIHJlY3QxWzFdWzBdLCByZWN0MVsxXVsxXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9PT0gdHJ1ZSxcbiAgICAgICAgICAgIGRpc3RhbmNlID09PSB0cnVlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuICRyZWN0YW5nbGVfcmVjdGFuZ2xlKFxuICAgICAgICByZWN0MVswXVswXSwgcmVjdDFbMF1bMV0sIHJlY3QxWzFdWzBdLCByZWN0MVsxXVsxXSxcbiAgICAgICAgcmVjdDJbMF1bMF0sIHJlY3QyWzBdWzFdLCByZWN0MlsxXVswXSwgcmVjdDJbMV1bMV0sXG4gICAgICAgIGNvbGxpc2lvbiA9PT0gdHJ1ZSxcbiAgICAgICAgZGlzdGFuY2UgPT09IHRydWVcbiAgICApO1xuXG59XG5cbi8qKlxuICogQFRPRE8gc2VnbWVudHMgb2YgY29sbGlzaW9uXG4gKlxuICogQHBhcmFtIHtBQUJCMn0gYmIyXG4gKiBAcGFyYW0ge0FBQkIyfSByZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbGxpc2lvblxuICogQHBhcmFtIHtCb29sZWFufSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiBiYjJfcmVjdGFuZ2xlKGJiMiwgcmVjdCwgY29sbGlzaW9uLCBkaXN0YW5jZSkge1xuaWYgKCFBcnJheS5pc0FycmF5KGJiMikgfHwgYmIyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlswXSB8fCBiYjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyWzFdIHx8IGJiMlsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbMl0gfHwgYmIyWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYmIyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdIHx8IHJlY3RbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV0gfHwgcmVjdFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsyXSB8fCByZWN0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiByZWN0XCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBjb2xsaXNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsaXNpb24gaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgZGlzdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXN0YW5jZSBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbiAgICBBQUJCMi5ub3JtYWxpemUoYmIyLCBiYjIpO1xuICAgIFJlY3RhbmdsZS5ub3JtYWxpemUocmVjdCwgcmVjdCk7XG5cbiAgICAvLyByMSBzaG91bGQgYmUgZnVydGhlciBsZWZ0IVxuICAgIGlmIChiYjJbMF0gPCByZWN0WzBdWzBdKSB7XG4gICAgICAgIHJldHVybiAkcmVjdGFuZ2xlX3JlY3RhbmdsZShcbiAgICAgICAgICAgIHJlY3RbMF1bMF0sIHJlY3RbMF1bMV0sIHJlY3RbMV1bMF0sIHJlY3RbMV1bMV0sXG4gICAgICAgICAgICBiYjJbMF0sIGJiMlsxXSwgYmIyWzJdLCBiYjJbM10sXG4gICAgICAgICAgICBjb2xsaXNpb24gPT09IHRydWUsXG4gICAgICAgICAgICBkaXN0YW5jZSA9PT0gdHJ1ZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAkcmVjdGFuZ2xlX3JlY3RhbmdsZShcbiAgICAgICAgYmIyWzBdLCBiYjJbMV0sIGJiMlsyXSwgYmIyWzNdLFxuICAgICAgICByZWN0WzBdWzBdLCByZWN0WzBdWzFdLCByZWN0WzFdWzBdLCByZWN0WzFdWzFdLFxuICAgICAgICBjb2xsaXNpb24gPT09IHRydWUsXG4gICAgICAgIGRpc3RhbmNlID09PSB0cnVlXG4gICAgKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7QUFCQjJ9IHJlY3RcbiAqIEBwYXJhbSB7QUFCQjJ9IGJiMlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gcmVjdGFuZ2xlX2JiMihyZWN0LCBiYjIsIGNvbGxpc2lvbiwgZGlzdGFuY2UpIHtcbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdIHx8IHJlY3RbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV0gfHwgcmVjdFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsyXSB8fCByZWN0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiByZWN0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShiYjIpIHx8IGJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbMF0gfHwgYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlsxXSB8fCBiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyWzJdIHx8IGJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbM10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFBQkIyIGJiMlwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgcmV0dXJuIGJiMl9yZWN0YW5nbGUoYmIyLCByZWN0LCBjb2xsaXNpb24sIGRpc3RhbmNlKTtcbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0FBQkIyfSByZWN0XG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGlzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHJlY3RhbmdsZV92ZWMyKHJlY3QsIHZlYzIsIGNvbGxpc2lvbiwgZGlzdGFuY2UpIHtcbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdIHx8IHJlY3RbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV0gfHwgcmVjdFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsyXSB8fCByZWN0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiByZWN0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgcmV0dXJuICRyZWN0YW5nbGVfdmVjMihyZWN0WzBdWzBdLCByZWN0WzBdWzFdLCByZWN0WzFdWzBdLCByZWN0WzFdWzFdLCB2ZWMyWzBdLCB2ZWMyWzFdLCBjb2xsaXNpb24gPT09IHRydWUsIGRpc3RhbmNlID09PSB0cnVlKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHBhcmFtIHtBQUJCMn0gcmVjdFxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gdmVjMl9yZWN0YW5nbGUodmVjMiwgcmVjdCwgY29sbGlzaW9uLCBkaXN0YW5jZSkge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdIHx8IHJlY3RbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV0gfHwgcmVjdFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsyXSB8fCByZWN0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiByZWN0XCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBjb2xsaXNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsaXNpb24gaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgZGlzdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXN0YW5jZSBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbiAgICByZXR1cm4gJHJlY3RhbmdsZV92ZWMyKHJlY3RbMF1bMF0sIHJlY3RbMF1bMV0sIHJlY3RbMV1bMF0sIHJlY3RbMV1bMV0sIHZlYzJbMF0sIHZlYzJbMV0sIGNvbGxpc2lvbiA9PT0gdHJ1ZSwgZGlzdGFuY2UgPT09IHRydWUpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGlzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGNpcmNsZV92ZWMyKGNpcmNsZSwgdmVjMiwgY29sbGlzaW9uLCBkaXN0YW5jZSkge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBjb2xsaXNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsaXNpb24gaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgZGlzdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXN0YW5jZSBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbiAgICBjb2xsaXNpb24gPSBjb2xsaXNpb24gPT09IHRydWU7XG4gICAgZGlzdGFuY2UgPSBkaXN0YW5jZSA9PT0gdHJ1ZTtcblxuICAgIHZhciBkaXN0YW5jZV90b19jZW50ZXIgPSBWZWMyLmRpc3RhbmNlKGNpcmNsZVswXSwgdmVjMik7XG5cbiAgICBpZiAobmVhcihkaXN0YW5jZV90b19jZW50ZXIsIGNpcmNsZVsxXSkpIHtcbiAgICAgICAgcmV0dXJuIHtyZWFzb246IENPTExJREUsIHBvaW50czogW3ZlYzJdfTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdGFuY2VfdG9fY2VudGVyIDwgY2lyY2xlWzFdKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uOiBJTlNJREUsIGRpc3RhbmNlOiBhYnMoZGlzdGFuY2VfdG9fY2VudGVyIC0gY2lyY2xlWzFdKX07XG4gICAgfVxuICAgIHJldHVybiB7cmVhc29uOiBPVVRTSURFLCBkaXN0YW5jZTogYWJzKGRpc3RhbmNlX3RvX2NlbnRlciAtIGNpcmNsZVsxXSl9O1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbGxpc2lvblxuICogQHBhcmFtIHtCb29sZWFufSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiB2ZWMyX2NpcmNsZSh2ZWMyLCBjaXJjbGUsIGNvbGxpc2lvbiwgZGlzdGFuY2UpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgY2lyY2xlX3ZlYzIoY2lyY2xlLCB2ZWMyLCBjb2xsaXNpb24sIGRpc3RhbmNlKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7Q2lyY2xlfSBhX2NpcmNsZVxuICogQHBhcmFtIHtDaXJjbGV9IGJfY2lyY2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbGxpc2lvblxuICogQHBhcmFtIHtCb29sZWFufSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiBjaXJjbGVfY2lyY2xlKGFfY2lyY2xlLCBiX2NpcmNsZSwgY29sbGlzaW9uLCBkaXN0YW5jZSkge1xuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGNvbGxpc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxpc2lvbiBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBkaXN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRpc3RhbmNlIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuICAgIGNvbGxpc2lvbiA9IGNvbGxpc2lvbiA9PT0gdHJ1ZTtcbiAgICBkaXN0YW5jZSA9IGRpc3RhbmNlID09PSB0cnVlO1xuXG4gICAgdmFyIGMxID0gYV9jaXJjbGVbMF0sXG4gICAgICAgIGMyID0gYl9jaXJjbGVbMF0sXG4gICAgICAgIHIxID0gYV9jaXJjbGVbMV0sXG4gICAgICAgIHIyID0gYl9jaXJjbGVbMV0sXG4gICAgICAgIHIxc3EgPSByMSAqIHIxLFxuICAgICAgICByMnNxID0gcjIgKiByMixcbiAgICAgICAgLy8gRGV0ZXJtaW5lIG1pbmltdW0gYW5kIG1heGltdW0gcmFkaXVzIHdoZXJlIGNpcmNsZXMgY2FuIGludGVyc2VjdFxuICAgICAgICByX21heCA9IHIxICsgcjIsXG4gICAgICAgIHJfbWluLFxuICAgICAgICAvLyBEZXRlcm1pbmUgYWN0dWFsIGRpc3RhbmNlIGJldHdlZW4gY2lyY2xlIGNpcmNsZXNcbiAgICAgICAgY19kaXN0X3NxID0gVmVjMi5kaXN0YW5jZVNxKGMxLCBjMiksXG4gICAgICAgIGNfZGlzdCxcbiAgICAgICAgYSxcbiAgICAgICAgaCxcbiAgICAgICAgYixcbiAgICAgICAgcG9pbnRzLFxuICAgICAgICB6O1xuXG4gICAgaWYgKGNfZGlzdF9zcSA+IHJfbWF4ICogcl9tYXgpIHtcbiAgICAgICAgcmV0dXJuIHtyZWFzb246IE9VVFNJREV9O1xuICAgIH1cblxuICAgIHJfbWluID0gcjEgLSByMjtcblxuICAgIGlmIChjX2Rpc3Rfc3EgPCByX21pbiAqIHJfbWluKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uOiBJTlNJREV9O1xuICAgIH1cblxuICAgIGlmIChjb2xsaXNpb24gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uOiBDT0xMSURFfTtcbiAgICB9XG5cbiAgICBwb2ludHMgPSBbXTtcblxuICAgIGNfZGlzdCA9IHNxcnQoY19kaXN0X3NxKTtcblxuICAgIGEgPSAocjFzcSAtIHIyc3EgKyBjX2Rpc3Rfc3EpIC8gKDIgKiBjX2Rpc3QpO1xuICAgIHogPSByMXNxIC0gYSAqIGE7XG4gICAgaCA9IHNxcnQoeiA+IDAgPyB6IDogLXopO1xuXG4gICAgVmVjMi5sZXJwKGF1eF92ZWMyLCBjMSwgYzIsIGEgLyBjX2Rpc3QpO1xuXG4gICAgYiA9IGggLyBjX2Rpc3Q7XG5cbiAgICBwb2ludHMucHVzaChbYXV4X3ZlYzJbMF0gLSBiICogKGMyWzFdIC0gYzFbMV0pLCBhdXhfdmVjMlsxXSArIGIgKiAoYzJbMF0gLSBjMVswXSldKTtcbiAgICBwb2ludHMucHVzaChbYXV4X3ZlYzJbMF0gKyBiICogKGMyWzFdIC0gYzFbMV0pLCBhdXhfdmVjMlsxXSAtIGIgKiAoYzJbMF0gLSBjMVswXSldKTtcblxuICAgIHJldHVybiB7cmVhc29uOiBDT0xMSURFLCBwb2ludHM6IHBvaW50c307XG59XG4vKipcbiAqXG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlXG4gKiBAcGFyYW0ge0FBQkIyfSBiYjJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGlzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGNpcmNsZV9iYjIoY2lyY2xlLCBiYjIsIGNvbGxpc2lvbiwgZGlzdGFuY2UpIHtcbmlmICghQXJyYXkuaXNBcnJheShiYjIpIHx8IGJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbMF0gfHwgYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlsxXSB8fCBiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyWzJdIHx8IGJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbM10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFBQkIyIGJiMlwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgcmV0dXJuICRjaXJjbGVfcmVjdGFuZ2xlKGNpcmNsZVswXVswXSwgY2lyY2xlWzBdWzFdLCBjaXJjbGVbMV0sXG4gICAgICAgIGJiMlswXSwgYmIyWzFdLCBiYjJbMl0sIGJiMlszXSxcbiAgICAgICAgY29sbGlzaW9uID09PSB0cnVlLCBkaXN0YW5jZSA9PT0gdHJ1ZSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0ge0FBQkIyfSBiYjJcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGlzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGJiMl9jaXJjbGUoYmIyLCBjaXJjbGUsIGNvbGxpc2lvbiwgZGlzdGFuY2UpIHtcbmlmICghQXJyYXkuaXNBcnJheShiYjIpIHx8IGJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbMF0gfHwgYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGJiMlsxXSB8fCBiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYmIyWzJdIHx8IGJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBiYjJbM10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFBQkIyIGJiMlwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgcmV0dXJuICRjaXJjbGVfcmVjdGFuZ2xlKGNpcmNsZVswXVswXSwgY2lyY2xlWzBdWzFdLCBjaXJjbGVbMV0sXG4gICAgICAgIGJiMlswXSwgYmIyWzFdLCBiYjJbMl0sIGJiMlszXSxcbiAgICAgICAgY29sbGlzaW9uID09PSB0cnVlLCBkaXN0YW5jZSA9PT0gdHJ1ZSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdFxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gY2lyY2xlX3JlY3RhbmdsZShjaXJjbGUsIHJlY3QsIGNvbGxpc2lvbiwgZGlzdGFuY2UpIHtcbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzBdIHx8IHJlY3RbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMV0gfHwgcmVjdFsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVswXSB8fCByZWN0WzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBSZWN0YW5nbGUgcmVjdFwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgcmV0dXJuICRjaXJjbGVfcmVjdGFuZ2xlKGNpcmNsZVswXVswXSwgY2lyY2xlWzBdWzFdLCBjaXJjbGVbMV0sXG4gICAgICAgIHJlY3RbMF1bMF0sIHJlY3RbMF1bMV0sIHJlY3RbMV1bMF0sIHJlY3RbMV1bMV0sXG4gICAgICAgIGNvbGxpc2lvbiA9PT0gdHJ1ZSwgZGlzdGFuY2UgPT09IHRydWUpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGlzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHJlY3RhbmdsZV9jaXJjbGUocmVjdCwgY2lyY2xlLCBjb2xsaXNpb24sIGRpc3RhbmNlKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkocmVjdCkgfHwgcmVjdFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVswXSB8fCByZWN0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzFdIHx8IHJlY3RbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMF0gfHwgcmVjdFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgUmVjdGFuZ2xlIHJlY3RcIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGNvbGxpc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxpc2lvbiBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBkaXN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRpc3RhbmNlIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuICAgIHJldHVybiAkY2lyY2xlX3JlY3RhbmdsZShjaXJjbGVbMF1bMF0sIGNpcmNsZVswXVsxXSwgY2lyY2xlWzFdLFxuICAgICAgICByZWN0WzBdWzBdLCByZWN0WzBdWzFdLCByZWN0WzFdWzBdLCByZWN0WzFdWzFdLFxuICAgICAgICBjb2xsaXNpb24gPT09IHRydWUsIGRpc3RhbmNlID09PSB0cnVlKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGlzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGNpcmNsZV9zZWdtZW50MihjaXJjbGUsIHNlZzIsIGNvbGxpc2lvbiwgZGlzdGFuY2UpIHtcbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBjb2xsaXNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsaXNpb24gaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgZGlzdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXN0YW5jZSBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbiAgICByZXR1cm4gJGNpcmNsZV9zZWdtZW50MihcbiAgICAgICAgY2lyY2xlWzBdWzBdLCBjaXJjbGVbMF1bMV0sIGNpcmNsZVsxXSxcbiAgICAgICAgc2VnMlswXSwgc2VnMlsxXSwgc2VnMlsyXSwgc2VnMlszXSxcbiAgICAgICAgY29sbGlzaW9uID09PSB0cnVlLFxuICAgICAgICBkaXN0YW5jZSA9PT0gdHJ1ZVxuICAgICk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcGFyYW0ge0NpcmNsZX0gY2lyY2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbGxpc2lvblxuICogQHBhcmFtIHtCb29sZWFufSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiBzZWdtZW50Ml9jaXJjbGUoc2VnMiwgY2lyY2xlLCBjb2xsaXNpb24sIGRpc3RhbmNlKSB7XG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgY29sbGlzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGRpc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzdGFuY2UgaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG4gICAgcmV0dXJuICRjaXJjbGVfc2VnbWVudDIoXG4gICAgICAgIGNpcmNsZVswXVswXSwgY2lyY2xlWzBdWzFdLCBjaXJjbGVbMV0sXG4gICAgICAgIHNlZzJbMF0sIHNlZzJbMV0sIHNlZzJbMl0sIHNlZzJbM10sXG4gICAgICAgIGNvbGxpc2lvbiA9PT0gdHJ1ZSxcbiAgICAgICAgZGlzdGFuY2UgPT09IHRydWVcbiAgICApO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtMaW5lMn0gbGluZTJfMlxuICogQHBhcmFtIHtMaW5lMn0gbGluZTJfMVxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gbGluZTJfbGluZTIobGluZTJfMSwgbGluZTJfMiwgY29sbGlzaW9uLCBkaXN0YW5jZSkge1xuaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIGNvbGxpc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxpc2lvbiBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBkaXN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRpc3RhbmNlIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxuICAgIGNvbGxpc2lvbiA9IGNvbGxpc2lvbiA9PT0gdHJ1ZTtcbiAgICBkaXN0YW5jZSA9IGRpc3RhbmNlID09PSB0cnVlO1xuXG4gICAgdmFyIGExID0gW2xpbmUyXzFbMF1bMF0sIGxpbmUyXzFbMF1bMV1dLFxuICAgICAgICBhMiA9IFswLCAwXSwgLy8gWFhYIGNoZWNrISBtLDEgPz9cbiAgICAgICAgYjEgPSBbbGluZTJfMlswXVswXSwgbGluZTJfMlswXVsxXV0sXG4gICAgICAgIGIyID0gWzAsIDBdLFxuICAgICAgICB1YV90LFxuICAgICAgICB1Yl90LFxuICAgICAgICB1X2IsXG4gICAgICAgIHVhLFxuICAgICAgICB1YjtcblxuICAgIFZlYzIuYWRkKGEyLCBhMSwgW2xpbmUyXzFbMV0sIDFdKTtcbiAgICBWZWMyLmFkZChiMiwgYjEsIFtsaW5lMl8yWzFdLCAxXSk7XG5cbiAgICB1YV90ID0gKGIyWzBdIC0gYjFbMF0pICogKGExWzFdIC0gYjFbMV0pIC0gKGIyWzFdIC0gYjFbMV0pICogKGExWzBdIC0gYjFbMF0pO1xuICAgIHViX3QgPSAoYTJbMF0gLSBhMVswXSkgKiAoYTFbMV0gLSBiMVsxXSkgLSAoYTJbMV0gLSBhMVsxXSkgKiAoYTFbMF0gLSBiMVswXSk7XG4gICAgdV9iICA9IChiMlsxXSAtIGIxWzFdKSAqIChhMlswXSAtIGExWzBdKSAtIChiMlswXSAtIGIxWzBdKSAqIChhMlsxXSAtIGExWzFdKTtcblxuICAgIGlmICh1X2IgIT09IDApIHtcbiAgICAgICAgdWEgPSB1YV90IC8gdV9iO1xuICAgICAgICB1YiA9IHViX3QgLyB1X2I7XG5cbiAgICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHtcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtyZWFzb246IENPTExJREV9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtyZWFzb246IENPTExJREUsIHBvaW50czogW1thMVswXSArIHVhICogKGEyWzBdIC0gYTFbMF0pLCBhMVsxXSArIHVhICogKGEyWzFdIC0gYTFbMV0pXV19O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7cmVhc29uOiBPVVRTSURFfTtcbiAgICB9XG4gICAgaWYgKHVhX3QgPT09IDAgfHwgdWJfdCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge3JlYXNvbjogQ09JTkNJREVOVH07XG4gICAgfVxuICAgIHJldHVybiB7cmVhc29uOiBQQVJBTExFTH07XG59XG4vKipcbiAqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXzJcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJfMVxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gc2VnbWVudDJfc2VnbWVudDIoc2VnMl8xLCBzZWcyXzIsIGNvbGxpc2lvbiwgZGlzdGFuY2UpIHtcbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBjb2xsaXNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsaXNpb24gaXMgbm90IGEgYm9vbGVhblwiKVxufVxuXG5pZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2YgZGlzdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXN0YW5jZSBpcyBub3QgYSBib29sZWFuXCIpXG59XG5cbiAgICBjb2xsaXNpb24gPSBjb2xsaXNpb24gPT09IHRydWU7XG4gICAgZGlzdGFuY2UgPSBkaXN0YW5jZSA9PT0gdHJ1ZTtcblxuICAgIHZhciBtdWEsXG4gICAgICAgIG11YixcbiAgICAgICAgZGVub20sXG4gICAgICAgIG51bWVyYSxcbiAgICAgICAgbnVtZXJiLFxuICAgICAgICBwb2ludHMsXG4gICAgICAgIGksXG4gICAgICAgIG1heCxcbiAgICAgICAgbWlucCxcbiAgICAgICAgbWF4cCxcbiAgICAgICAgZGlzdDtcblxuICAgIGRlbm9tICA9IChzZWcyXzJbM10gLSBzZWcyXzJbMV0pICogKHNlZzJfMVsyXSAtIHNlZzJfMVswXSkgLSAoc2VnMl8yWzJdIC0gc2VnMl8yWzBdKSAqIChzZWcyXzFbM10gLSBzZWcyXzFbMV0pO1xuICAgIG51bWVyYSA9IChzZWcyXzJbMl0gLSBzZWcyXzJbMF0pICogKHNlZzJfMVsxXSAtIHNlZzJfMlsxXSkgLSAoc2VnMl8yWzNdIC0gc2VnMl8yWzFdKSAqIChzZWcyXzFbMF0gLSBzZWcyXzJbMF0pO1xuICAgIG51bWVyYiA9IChzZWcyXzFbMl0gLSBzZWcyXzFbMF0pICogKHNlZzJfMVsxXSAtIHNlZzJfMlsxXSkgLSAoc2VnMl8xWzNdIC0gc2VnMl8xWzFdKSAqIChzZWcyXzFbMF0gLSBzZWcyXzJbMF0pO1xuXG4gICAgLyogQXJlIHRoZSBsaW5lIGNvaW5jaWRlbnQ/ICovXG4gICAgaWYgKE1hdGguYWJzKG51bWVyYSkgPCBNYXRoLkVQUyAmJiBNYXRoLmFicyhudW1lcmIpIDwgTWF0aC5FUFMgJiYgTWF0aC5hYnMoZGVub20pIDwgTWF0aC5FUFMpIHtcblxuICAgICAgICBpZiAoY29sbGlzaW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZWFzb24gOiBDT0xMSURFXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGludGVyc2VjdGlvbnMgaXMgYSBsaW5lIVxuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgcG9pbnRzLnB1c2goc2VnbWVudDJfdmVjMihzZWcyXzIsIFtzZWcyXzFbMF0sIHNlZzJfMVsxXV0pKTtcbiAgICAgICAgcG9pbnRzLnB1c2goc2VnbWVudDJfdmVjMihzZWcyXzIsIFtzZWcyXzFbMl0sIHNlZzJfMVszXV0pKTtcbiAgICAgICAgcG9pbnRzLnB1c2goc2VnbWVudDJfdmVjMihzZWcyXzEsIFtzZWcyXzJbMF0sIHNlZzJfMlsxXV0pKTtcbiAgICAgICAgcG9pbnRzLnB1c2goc2VnbWVudDJfdmVjMihzZWcyXzEsIFtzZWcyXzJbMl0sIHNlZzJfMlszXV0pKTtcbiAgICAgICAgLy8gbm93IGNoZWNrIHRob3NlIGludGVyc2VjdGlvbnMsIHJlbW92ZSBubyBpbnRlcnNlY3Rpb25zIVxuICAgICAgICBtYXggPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBtaW5wID0geyBkaXN0YW5jZTogZmFsc2UsIHBvaW50OiBudWxsfTtcbiAgICAgICAgbWF4cCA9IHsgZGlzdGFuY2U6IGZhbHNlLCBwb2ludDogbnVsbH07XG5cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWF4OyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwb2ludHNbaV0ucmVhc29uIDw9IENPTExJREUpIHsgLy8gbm8gY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgcG9pbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgbWF4ID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBkaXN0ID0gVmVjMi5sZW5ndGhTcShwb2ludHNbaV0ucG9pbnRzWzBdKTtcblxuICAgICAgICAgICAgICAgIGlmIChtaW5wLmRpc3RhbmNlID09PSBmYWxzZSB8fCBtaW5wLmRpc3RhbmNlID4gZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5wLmRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgbWlucC5wb2ludCA9IHBvaW50c1tpXS5wb2ludHNbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1heHAuZGlzdGFuY2UgPT09IGZhbHNlIHx8IG1pbnAuZGlzdGFuY2UgPCBkaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heHAuZGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBtYXhwLnBvaW50ID0gcG9pbnRzW2ldLnBvaW50c1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vbGluZSBpbnRlcnNlY3Rpb24hXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA6IENPTExJREUsXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICBzZWdtZW50czogW1ttaW5wLnBvaW50WzBdLCBtaW5wLnBvaW50WzFdLCBtYXhwLnBvaW50WzBdLCBtYXhwLnBvaW50WzFdXV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhc29uIDogQ09JTkNJREVOVFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qIEFyZSB0aGUgbGluZSBwYXJhbGxlbCAqL1xuICAgIGlmIChNYXRoLmFicyhkZW5vbSkgPCBNYXRoLkVQUykge1xuICAgICAgICByZXR1cm4ge3JlYXNvbjogUEFSQUxMRUx9O1xuICAgIH1cblxuICAgIC8qIElzIHRoZSBpbnRlcnNlY3Rpb24gYWxvbmcgdGhlIHRoZSBzZWdtZW50cyAqL1xuICAgIG11YSA9IG51bWVyYSAvIGRlbm9tO1xuICAgIG11YiA9IG51bWVyYiAvIGRlbm9tO1xuICAgIGlmIChtdWEgPCAwIHx8IG11YSA+IDEgfHwgbXViIDwgMCB8fCBtdWIgPiAxKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uOiBPVVRTSURFfTtcbiAgICB9XG5cbiAgICBpZiAoY29sbGlzaW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4ge3JlYXNvbjogQ09MTElERX07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtyZWFzb246IENPTExJREUsIHBvaW50czogW1tzZWcyXzFbMF0gKyBtdWEgKiAoc2VnMl8xWzJdIC0gc2VnMl8xWzBdKSwgc2VnMl8xWzFdICsgbXVhICogKHNlZzJfMVszXSAtIHNlZzJfMVsxXSldXX07XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gc2VnbWVudDJfdmVjMihzZWcyLCB2ZWMyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIHZhciBkaXMgPSBEaXN0YW5jZS5zZWdtZW50Ml92ZWMyKHNlZzIsIHZlYzIpO1xuXG4gICAgaWYgKGRpcyA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhc29uIDogQ09MTElERSxcbiAgICAgICAgICAgIHBvaW50czogW3ZlYzJdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVhc29uIDogT1VUU0lERSxcbiAgICAgICAgZGlzdGFuY2U6IGRpc1xuICAgIH07XG59XG4vKipcbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGlzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHZlYzJfc2VnbWVudDIodmVjMiwgc2VnMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICByZXR1cm4gc2VnbWVudDJfdmVjMihzZWcyLCB2ZWMyKTtcbn1cbi8qKlxuICogQFRPRE8gdGhpcyBpcyBqdXN0IGEgZmFzdC1jb2RlLXZlcnNpb24sIG5vIG9wdGltaXphdGlvbiBubyBmb3IgcmVhbC10aW1lXG4gKlxuICogQHBhcmFtIHtQb2x5Z29ufSBhX3BvbHlcbiAqIEBwYXJhbSB7UG9seWdvbn0gYl9wb2x5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbGxpc2lvblxuICogQHBhcmFtIHtCb29sZWFufSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiBwb2x5Z29uX3BvbHlnb24oYV9wb2x5LCBiX3BvbHkpIHtcbiAgICB2YXIgYWxlbiA9IGFfcG9seS5sZW5ndGgsXG4gICAgICAgIGJsZW4gPSBiX3BvbHkubGVuZ3RoLFxuICAgICAgICBhLFxuICAgICAgICBhMixcbiAgICAgICAgYixcbiAgICAgICAgYjIsXG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgIGZvciAoYSA9IDA7IGEgPCBhbGVuOyArK2EpIHtcbiAgICAgICAgYTIgPSBhICsgMTtcbiAgICAgICAgYTIgPSBhMiA9PSBhbGVuID8gMCA6IGEyO1xuICAgICAgICBmb3IgKGIgPSAwOyBiIDwgYmxlbjsgKytiKSB7XG4gICAgICAgICAgICBiMiA9IGIgKyAxO1xuICAgICAgICAgICAgYjIgPSBiMiA9PSBibGVuID8gMCA6IGIyO1xuXG4gICAgICAgICAgICByID0gc2VnbWVudDJfc2VnbWVudDIoXG4gICAgICAgICAgICAgICAgW2FfcG9seVthXVswXSwgYV9wb2x5W2FdWzFdLCBhX3BvbHlbYTJdWzBdLCBhX3BvbHlbYTJdWzFdXSxcbiAgICAgICAgICAgICAgICBbYl9wb2x5W2JdWzBdLCBiX3BvbHlbYl1bMV0sIGJfcG9seVtiMl1bMF0sIGJfcG9seVtiMl1bMV1dLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyLnBvaW50cykge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHIucG9pbnRzWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYXNvbiA6IENPTExJREUsXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWFzb24gOiBPVVRTSURFXG4gICAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBJbnRlcnNlY3Rpb25cbiAqL1xudmFyIEludGVyc2VjdGlvbiA9IHtcbiAgICBPVVRTSURFOiBPVVRTSURFLFxuICAgIFBBUkFMTEVMOiBQQVJBTExFTCxcbiAgICBDT0xMSURFOiBDT0xMSURFLFxuICAgIElOU0lERTogSU5TSURFLFxuICAgIENPSU5DSURFTlQ6IENPSU5DSURFTlQsXG4gICAgVEFOR0VOVDogVEFOR0VOVCxcblxuICAgIGJiMl9iYjI6IGJiMl9iYjIsXG4gICAgYmIyX3ZlYzI6IGJiMl92ZWMyLFxuICAgIHZlYzJfYmIyOiB2ZWMyX2JiMixcbiAgICByZWN0YW5nbGVfcmVjdGFuZ2xlOiByZWN0YW5nbGVfcmVjdGFuZ2xlLFxuICAgIGJiMl9yZWN0YW5nbGU6IGJiMl9yZWN0YW5nbGUsXG4gICAgcmVjdGFuZ2xlX2JiMjogcmVjdGFuZ2xlX2JiMixcbiAgICByZWN0YW5nbGVfdmVjMjogcmVjdGFuZ2xlX3ZlYzIsXG4gICAgdmVjMl9yZWN0YW5nbGU6IHZlYzJfcmVjdGFuZ2xlLFxuICAgIGNpcmNsZV92ZWMyOiBjaXJjbGVfdmVjMixcbiAgICB2ZWMyX2NpcmNsZTogdmVjMl9jaXJjbGUsXG4gICAgY2lyY2xlX2NpcmNsZTogY2lyY2xlX2NpcmNsZSxcbiAgICBjaXJjbGVfYmIyOiBjaXJjbGVfYmIyLFxuICAgIGJiMl9jaXJjbGU6IGJiMl9jaXJjbGUsXG4gICAgY2lyY2xlX3JlY3RhbmdsZTogY2lyY2xlX3JlY3RhbmdsZSxcbiAgICByZWN0YW5nbGVfY2lyY2xlOiByZWN0YW5nbGVfY2lyY2xlLFxuICAgIGNpcmNsZV9zZWdtZW50MjogY2lyY2xlX3NlZ21lbnQyLFxuICAgIHNlZ21lbnQyX2NpcmNsZTogc2VnbWVudDJfY2lyY2xlLFxuICAgIGxpbmUyX2xpbmUyOiBsaW5lMl9saW5lMixcbiAgICBzZWdtZW50Ml9zZWdtZW50Mjogc2VnbWVudDJfc2VnbWVudDIsXG4gICAgc2VnbWVudDJfdmVjMjogc2VnbWVudDJfdmVjMixcbiAgICB2ZWMyX3NlZ21lbnQyOiB2ZWMyX3NlZ21lbnQyLFxuXG4gICAgcG9seWdvbl9wb2x5Z29uOiBwb2x5Z29uX3BvbHlnb24sXG5cbiAgICAkcmVjdGFuZ2xlX3JlY3RhbmdsZTogJHJlY3RhbmdsZV9yZWN0YW5nbGUsXG4gICAgJHJlY3RhbmdsZV92ZWMyOiAkcmVjdGFuZ2xlX3ZlYzIsXG4gICAgJGNpcmNsZV9zZWdtZW50MjogJGNpcmNsZV9zZWdtZW50MixcbiAgICAkY2lyY2xlX3JlY3RhbmdsZTogJGNpcmNsZV9yZWN0YW5nbGVcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcnNlY3Rpb247IiwiLypcbiAqIFN0YWJpbGl0eTogMSAoT25seSBhZGRpdGlvbnMgJiBmaXhlcylcbiAqXG4gKiBQb2ludC1TbG9wZSBFcXVhdGlvbiBvZiBhIExpbmU6IHkgLSB5MSA9IG0oeCAtIHgxKVxuICovXG52YXIgZHgsXG4gICAgZHksXG4gICAgcixcbiAgICBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIHRhbiA9IE1hdGgudGFuLFxuICAgIGF0YW4gPSBNYXRoLmF0YW4sXG4gICAgc2luID0gTWF0aC5zaW4sXG4gICAgY29zID0gTWF0aC5jb3MsXG4gICAgbmVhciA9IE1hdGgubmVhcjtcblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtXG4gKiBAcmV0dXJuIHtMaW5lMn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHgsIHksIG0pIHtcbmlmICh4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKG0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gW1t4LCB5XSwgbV07XG59XG4vKipcbiAqIEByZXR1cm4ge0xpbmUyfVxuICovXG5mdW5jdGlvbiB6ZXJvKCkge1xuICAgIHJldHVybiBbWzAsIDBdLCAwXTtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2MlxuICogQHJldHVybiB7TGluZTJ9XG4gKi9cbmZ1bmN0aW9uIGZyb21WZWMyKHYxLCB2Mikge1xuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuICAgIHJldHVybiBbW3YxWzBdLCB2MVsxXV0sICh2MVswXSAtIHYyWzBdKSAvICh2MVswXSAtIHYyWzFdKV07XG59XG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gKiBAcGFyYW0ge051bWJlcn0geDJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICogQHJldHVybiB7TGluZTJ9XG4gKi9cbmZ1bmN0aW9uIGZyb20yUG9pbnRzKHgxLCB5MSwgeDIsIHkyKSB7XG5pZiAoeDEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHgyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gW1t4MSwgeTFdLCAoeDEgLSB4MikgLyAoeTEgLSB5MildO1xufVxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcmV0dXJuIHtMaW5lMn1cbiAqL1xuZnVuY3Rpb24gZnJvbVNlZ21lbnQyKHNlZzIpIHtcbiAgICByZXR1cm4gW1tzZWcyWzBdLCBzZWcyWzFdXSwgKHNlZzJbMF0gLSBzZWcyWzJdKSAvIChzZWcyWzFdIC0gc2VnMlszXSldO1xufVxuLyoqXG4gKiBAcGFyYW0ge0xpbmUyfSBvdXRcbiAqIEBwYXJhbSB7TGluZTJ9IGxpbmUyXG4gKiBAcmV0dXJuIHtMaW5lMn1cbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGxpbmUyKSB7XG4gICAgb3V0WzBdWzBdID0gbGluZTJbMF1bMF07XG4gICAgb3V0WzBdWzFdID0gbGluZTJbMF1bMV07XG4gICAgb3V0WzFdID0gbGluZTJbMV07XG5cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAcGFyYW0ge0xpbmUyfSBsaW5lMlxuICogQHJldHVybiB7TGluZTJ9XG4gKi9cbmZ1bmN0aW9uIGNsb25lKGxpbmUyKSB7XG4gICAgcmV0dXJuIFtbbGluZTJbMF1bMF0sIGxpbmUyWzBdWzFdXSwgbGluZTJbMV1dO1xufVxuLyoqXG4gKiBAcGFyYW0ge0xpbmUyfSBvdXRcbiAqIEBwYXJhbSB7TGluZTJ9IGxpbmUyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcmV0dXJuIHtMaW5lMn1cbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgbGluZTIsIHYxKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG4gICAgb3V0WzBdWzBdID0gbGluZTJbMF1bMF0gKyB2MVswXTtcbiAgICBvdXRbMF1bMV0gPSBsaW5lMlswXVsxXSArIHYxWzFdO1xuICAgIG91dFsxXSA9IGxpbmUyWzFdO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQHBhcmFtIHtMaW5lMn0gb3V0XG4gKiBAcGFyYW0ge0xpbmUyfSBsaW5lMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHJldHVybiB7TGluZTJ9XG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgbGluZTIsIHYxKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG4gICAgb3V0WzBdWzBdID0gbGluZTJbMF1bMF0gLSB2MVswXTtcbiAgICBvdXRbMF1bMV0gPSBsaW5lMlswXVsxXSAtIHYxWzFdO1xuICAgIG91dFsxXSA9IGxpbmUyWzFdO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmUyfSBvdXRcbiAqIEBwYXJhbSB7TGluZTJ9IGxpbmUyXG4gKiBAcGFyYW0ge1ZlYzJ9IG9mZnNldFxuICogQHJldHVybiB7TGluZTJ9XG4gKi9cbmZ1bmN0aW9uIG9mZnNldChvdXQsIGxpbmUyLCBvZmZzZXQpIHtcbmlmICghQXJyYXkuaXNBcnJheShvZmZzZXQpIHx8IG9mZnNldFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG9mZnNldFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvZmZzZXRbMF0gfHwgb2Zmc2V0WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob2Zmc2V0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG9mZnNldFsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvZmZzZXRcIilcbn1cblxuICAgIG91dFswXVswXSA9IGxpbmUyWzBdWzBdICsgb2Zmc2V0O1xuICAgIG91dFswXVsxXSA9IGxpbmUyWzBdWzFdO1xuICAgIG91dFsxXSA9IGxpbmUyWzFdO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmUyfSBvdXRcbiAqIEBwYXJhbSB7TGluZTJ9IGxpbmUyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaWFuc1xuICogQHJldHVybiB7TGluZTJ9XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGxpbmUyLCByYWRpYW5zKSB7XG5pZiAocmFkaWFucyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJhZGlhbnMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmFkaWFucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJhZGlhbnMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIG91dFswXVswXSA9IGxpbmUyWzBdWzBdO1xuICAgIG91dFswXVsxXSA9IGxpbmUyWzBdWzFdO1xuXG4gICAgb3V0WzFdID0gdGFuKGF0YW4obGluZTJbMV0pICsgcmFkaWFucyk7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEB0b2RvXG4gKiBAc291cmNlIGh0dHA6Ly9tYXRoY2VudHJhbC51cmVnaW5hLmNhL1FRL2RhdGFiYXNlL1FRLjA5LjA0L2Nhcmx5MS5odG1sXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge0xpbmUyfSBsaW5lMlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBjbG9zZXRQb2ludChvdXRfdmVjMiwgbGluZTIsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgdmFyIG0gPSBsaW5lMlsxXTtcbiAgICAgICAgbXAgPSAxIC8gbTsgLy8gb3B0aW1pemF0aW9uOiBkbyBub3QgbmVnYXRlXG5cbiAgICAvLyB5ID0gbSp4ICsgeTFcbiAgICAvLyAoeSAtIHkyKSA9IG0nICh4IC0geDIpXG5cbiAgICAvLyBtKnggPSAgbScgKiB4IC0gbScgKiB4MiArIHkyIC0geTFcbiAgICAvLyAobSAtIG0nKSAqIHggPSAgbScgKiB4MiArIHkyIC0geTFcbiAgICAvLyB4ID0gIChtJyAqIHgyICsgeTIgLSB5MSkgLyAobSAtIG0nKVxuXG5cbiAgICBvdXRfdmVjMlsxXSA9IChtcCAqIHZlYzJbMF0gKyB2ZWMyWzFdIC0gbGluZTJbMF1bMV0pIC8gKG0gKyBtcCk7XG4gICAgb3V0X3ZlYzJbMF0gPSBtICogb3V0X3ZlYzJbMV0gKyBsaW5lMlswXVsxXTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogT3ZlciB0aGUgbGluZSwgaGFzIG5lYXIgY2hlY2sgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLlxuICogQHBhcmFtIHtMaW5lMn0gbGluZTJcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWZWMySW5zaWRlKGxpbmUyLCB2ZWMyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIHZhciBwID0gbGluZTJbMF07XG4gICAgcmV0dXJuIG5lYXIobGluZTJbMV0sICh2ZWMyWzFdIC0gcFsxXSkgLyAodmVjMlswXSAtIHBbMF0pKTtcbn1cblxuXG4vKipcbiAqIEBjbGFzcyBMaW5lMlxuICovXG52YXIgTGluZTIgPSB7XG4gICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgemVybzogemVybyxcbiAgICBmcm9tVmVjMjogZnJvbVZlYzIsXG4gICAgZnJvbTJQb2ludHM6IGZyb20yUG9pbnRzLFxuICAgIGZyb21TZWdtZW50MjogZnJvbVNlZ21lbnQyLFxuICAgIGNvcHk6IGNvcHksXG4gICAgY2xvbmU6IGNsb25lLFxuICAgIGFkZDogYWRkLFxuICAgIHN1YnRyYWN0OiBzdWJ0cmFjdCxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICBjbG9zZXRQb2ludDogY2xvc2V0UG9pbnQsXG4gICAgaXNWZWMySW5zaWRlOiBpc1ZlYzJJbnNpZGUsXG5cbiAgICAvLyBhbGlhc1xuICAgIHRyYW5zbGF0ZTogYWRkLFxuICAgIHN1Yjogc3VidHJhY3Rcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lMjsiLCJ2YXIgY2xhbXAsXG4gICAgc3FydCA9IE1hdGguc3FydCxcbiAgICByYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICBjZWlsID0gTWF0aC5jZWlsLFxuICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICBsb2cgPSBNYXRoLmxvZyxcbiAgICBQSSxcbiAgICBRVUFURVJfUEksXG4gICAgSEFMRl9QSSxcbiAgICBIQUxGX05QSSxcbiAgICBUV09fUEksXG4gICAgVFdPX0hBTEZfUEksXG4gICAgTlBJLFxuICAgIE5RVUFURVJfUEksXG4gICAgTkhBTEZfUEksXG4gICAgTlRXT19QSSxcbiAgICBOVFdPX0hBTEZfUEksXG4gICAgRVBTID0gMTBlLTMsXG4gICAgTE9HMjtcblxuUEkgPSBNYXRoLlBJO1xuUVVBVEVSX1BJID0gTWF0aC5RVUFURVJfUEkgPSAwLjI1ICogTWF0aC5QSTtcbkhBTEZfUEkgPSBNYXRoLkhBTEZfUEkgPSAwLjUgKiBNYXRoLlBJO1xuSEFMRl9OUEkgPSBNYXRoLkhBTEZfTlBJID0gLTAuNSAqIE1hdGguUEk7XG5UV09fUEkgPSBNYXRoLlRXT19QSSA9IDIgKiBNYXRoLlBJO1xuVFdPX0hBTEZfUEkgPSBNYXRoLlRXT19IQUxGX1BJID0gKDIgKiBNYXRoLlBJKSArIE1hdGguSEFMRl9QSTtcbk5QSSA9IE1hdGguTlBJID0gLU1hdGguUEk7XG5OUVVBVEVSX1BJID0gTWF0aC5OUVVBVEVSX1BJID0gMC4yNSAqIE1hdGguTlBJO1xuTkhBTEZfUEkgPSBNYXRoLk5IQUxGX1BJID0gMC41ICogTWF0aC5OUEk7XG5OVFdPX1BJID0gTWF0aC5OVFdPX1BJID0gMiAqIE1hdGguTlBJO1xuTlRXT19IQUxGX1BJID0gTWF0aC5OVFdPX0hBTEZfUEkgPSAoMiAqIE1hdGguTlBJKSArIE1hdGguSEFMRl9QSTtcbkxPRzIgPSBNYXRoLkxPRzIgPSBsb2coMik7XG5cbk1hdGguSU5WX1BJID0gMSAvIE1hdGguUEk7XG5cbk1hdGguUkFEX1RPX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5NYXRoLkRFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG4vLyB0aGlzIGNvdWxkIGJlIHVzZWZ1bCB0byB0d2VhayBpbiB5b3VyIGFwcCwgZGVwZW5kcyBvbiB5b3VyIHdvcmxkIHJlc29sdXRpb25cbk1hdGguRVBTID0gRVBTO1xuXG4vKipcbiAqIENsYW1wIEBjIGYgdG8gYmUgYmV0d2VlbiBAYyBtaW4gYW5kIEBjIG1heC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge051bWJlcn0gYlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBuZWFyKGEsIGIpIHtcbmlmIChhID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoYiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiBhID4gYiAtIEVQUyAmJiBhIDwgYiArIEVQUztcbn1cblxuLyoqXG4gKiBDbGFtcCBAYyBmIHRvIGJlIGJldHdlZW4gQGMgbWluIGFuZCBAYyBtYXguXG4gKiBAcGFyYW0ge051bWJlcn0gZlxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbnZcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXh2XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNsYW1wKGYsIG1pbnYsIG1heHYpIHtcbmlmIChmID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oZikgfHwgJ251bWJlcicgIT09IHR5cGVvZiBmKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAobWludiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1pbnYpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWludikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1pbnYgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKG1heHYgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXh2KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1heHYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXh2IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gZiA8IG1pbnYgPyBtaW52IDogKGYgPiBtYXh2ID8gbWF4diA6IGYpO1xufTtcblxuLyoqXG4gKiBDbGFtcCBAYyBmIHRvIGJlIGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNsYW1wMDEoZikge1xuaWYgKGYgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihmKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gZiA8IDAgPyAwIDogKGYgPiAxID8gMSA6IGYpO1xufVxuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlIChvciBleHRyYXBvbGF0ZSkgYmV0d2VlbiBAYyBmMSBhbmQgQGMgZjIgYnkgQGMgdCBwZXJjZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IGYxXG4gKiBAcGFyYW0ge051bWJlcn0gZjJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGxlcnAoZjEsIGYyLCB0KSB7XG5pZiAoZjEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihmMSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBmMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImYxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChmMiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGYyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGYyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZjIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gZjEgKiAoMSAtIHQpICsgZjIgKiB0O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYVxuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwZXJjZW50XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGxlcnAyKGEsIGIsIHBlcmNlbnQpIHtcbmlmIChhID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoYiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHBlcmNlbnQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihwZXJjZW50KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHBlcmNlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwZXJjZW50IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gYSArIChiIC0gYSkgKiBwZXJjZW50O1xufVxuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlIGZyb20gQGMgZjEgdG8gQGMgZjIgYnkgbm8gbW9yZSB0aGFuIEBjIGQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGYxXG4gKiBAcGFyYW0ge051bWJlcn0gZjJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGxlcnBjb25zdChmMSwgZjIsIGQpIHtcbmlmIChmMSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGYxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGYxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZjEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGYyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oZjIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgZjIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmMiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoZCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGQpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImQgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiBmMSArIGNsYW1wKGYyIC0gZjEsIC1kLCBkKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gcmFuZEluUmFuZ2UobWluLCBtYXgpIHtcbmlmIChtaW4gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtaW4pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWluKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWluIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChtYXggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWF4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gbGVycChtaW4sIG1heCwgcmFuZG9tKCkpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiByYW5kUmFuZ2UobWF4LCBtaW4pIHtcbmlmIChtYXggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWF4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChtaW4gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtaW4pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWluKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWluIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRvbSgpO1xuICAgIH1cbiAgICBtaW4gPSBtaW4gfHwgMDtcblxuICAgIHJldHVybiByYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiByYW5kSW50KG1heCwgbWluKSB7XG5pZiAobWF4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obWF4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1heCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAobWluID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obWluKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1pbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1pbiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgbWluID0gbWluIHx8IDA7XG5cbiAgICByZXR1cm4gZmxvb3IocmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBzbmFwX3NpemVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gc25hcCh2YWx1ZSwgc25hcF9zaXplKSB7XG5pZiAodmFsdWUgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2YWx1ZSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInZhbHVlIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChzbmFwX3NpemUgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihzbmFwX3NpemUpIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygc25hcF9zaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic25hcF9zaXplIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gZmxvb3IodmFsdWUgLyBzbmFwX3NpemUpICogc25hcF9zaXplO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBzbmFwX3NpemVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gc25hcFJvdW5kKHZhbHVlLCBzbmFwX3NpemUpIHtcbmlmICh2YWx1ZSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZhbHVlKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHNuYXBfc2l6ZSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHNuYXBfc2l6ZSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBzbmFwX3NpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzbmFwX3NpemUgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHZhciBzdGVwcyA9IHZhbHVlIC8gc25hcF9zaXplIHwgMCxcbiAgICAgICAgcmVtYWluID0gdmFsdWUgLSAoc3RlcHMgKiBzbmFwX3NpemUpLFxuICAgICAgICByb3VuZGVyID0gcmVtYWluID4gKHNuYXBfc2l6ZSAvIDIpID8gY2VpbCA6IGZsb29yO1xuXG4gICAgcmV0dXJuIHJvdW5kZXIodmFsdWUgLyBzbmFwX3NpemUpICogc25hcF9zaXplO1xufVxuXG4vKipcbiAqIGdldCB0aGUgYW5nbGUgaW5zaWRlIFstUEksICtQSV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVSb3RhdGlvbihhbmdsZSkge1xuaWYgKGFuZ2xlID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYW5nbGUpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYW5nbGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbmdsZSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgaWYgKGFuZ2xlID4gTlBJICYmIGFuZ2xlIDwgUEkpIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgIH1cblxuICAgIGFuZ2xlID0gYW5nbGUgJSAoVFdPX1BJKTtcblxuICAgIGlmIChhbmdsZSA8IE5QSSkge1xuICAgICAgICBhbmdsZSArPSBUV09fUEk7XG4gICAgfSBlbHNlIGlmIChhbmdsZSA+IFBJKSB7XG4gICAgICAgIGFuZ2xlIC09IFRXT19QSTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5nbGU7XG59XG5cbi8qKlxuICogcm90YXRlIHRoZSBhbmdsZSBhbmQgcmV0dXJuIHRoZSBub3JtYWxpemVkXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gKiBAcGFyYW0ge051bWJlcn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlbHRhUm90YXRpb24oYW5nbGUsIHRhcmdldCkge1xuaWYgKGFuZ2xlID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYW5nbGUpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYW5nbGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbmdsZSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAodGFyZ2V0ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odGFyZ2V0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInRhcmdldCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVJvdGF0aW9uKGFuZ2xlIC0gdGFyZ2V0KTtcbn1cblxuXG4vKipcbiAqIE1hdGhlbWF0aWNhbCBhcHJvYWNoIHJhdGhlciB0aGFuIGNvbXB1dGFpb25hbC9wZXJmb3JtYW5jZSBiZWNhdXNlIEpTIE51bWJlciByZXByZXNlbnRhdGlvbiBpcyBlbHVzaXZlXG4gKlxuICogQHRvZG8gc3R1ZHkgYml0d2lzZSBvcGVyYXRpb25zIGNhbiBiZSB1c2VkIGluIGFsbCBjYXNlcyA/XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gcG93ZXJPZlR3byh4KSB7XG5pZiAoeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIG5leHQgPSBwb3coMiwgY2VpbChsb2coeCkvTE9HMikpO1xufVxuLyoqXG4gKiBAY3JlZGl0cyBUaHJlZS5qc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byh2YWx1ZSkge1xuaWYgKHZhbHVlID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmFsdWUpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICByZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcbn1cblxuTWF0aC5jbGFtcCA9IGNsYW1wO1xuTWF0aC5uZWFyID0gbmVhcjtcbk1hdGguY2xhbXAwMSA9IGNsYW1wMDE7XG5NYXRoLmxlcnAgPSBsZXJwO1xuTWF0aC5sZXJwY29uc3QgPSBsZXJwY29uc3Q7XG5NYXRoLnJhbmRSYW5nZSA9IHJhbmRSYW5nZTtcbk1hdGgucmFuZEludCA9IHJhbmRJbnQ7XG5NYXRoLnNuYXAgPSBzbmFwO1xuTWF0aC5zbmFwUm91bmQgPSBzbmFwUm91bmQ7XG5NYXRoLmRlbHRhUm90YXRpb24gPSBkZWx0YVJvdGF0aW9uO1xuTWF0aC5ub3JtYWxpemVSYWRpYW5zID0gbm9ybWFsaXplUm90YXRpb247XG5NYXRoLnBvd2VyT2ZUd28gPSBwb3dlck9mVHdvO1xuTWF0aC5pc1Bvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd287XG4iLCIvKipcbiAqIFN0YWJpbGl0eTogMCAoQW55dGhpbmcgY291bGQgaGFwcGVuKVxuICpcbiAqIDJ4MiBtYXRyaXggdXNlZCBmb3Igcm90YXRpb25zIDJEIHJlcHJlc2VudGVkIGFzIGEgNSBjb29yZGluYXRlcyBhcnJheVxuICogW20xMTpOdW1iZXIsIG0xMjpOdW1iZXIsIG0yMTpOdW1iZXIsIG0yMjpOdW1iZXIsIGFuZ2xlOk51bWJlcl1cbiAqIENhbiBiZSB1c2VkIHRvIHNvbHZlIDJ4MiBtYXRyaWNlcyBwcm9ibGVtcy5cbiAqXG4gKiBAdG9kbyB0aGlzIG5lZWQgbW9yZSB3b3JrIGFuZCB0ZXN0aW5nLi4uXG4gKi9cblxudmFyIGNvcyA9IE1hdGguY29zLFxuICAgIHNpbiA9IE1hdGguc2luLFxuICAgIGFjb3MgPSBNYXRoLmFjb3M7XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gKiBAcmV0dXJuIHtNYXRyaXgyMn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlKGFuZ2xlKSB7XG5pZiAoYW5nbGUgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhbmdsZSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhbmdsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFuZ2xlIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gWzEsIDAsIDAsIDEsIDBdO1xufVxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAqIEByZXR1cm4ge01hdHJpeDIyfVxuICovXG5mdW5jdGlvbiBmcm9tQW5nbGUoYW5nbGUpIHtcbmlmIChhbmdsZSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFuZ2xlKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFuZ2xlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYW5nbGUgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIGFuZ2xlID0gYW5nbGUgfHwgMDtcbiAgICB2YXIgYyA9IGNvcyhhbmdsZSksXG4gICAgICAgIHMgPSBzaW4oYW5nbGUpO1xuXG4gICAgcmV0dXJuIFtjLCAtcywgcywgYywgYW5nbGVdO1xufVxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gbTExXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyXG4gKiBAcmV0dXJuIHtNYXRyaXgyMn1cbiAqL1xuZnVuY3Rpb24gZnJvbU51bWJlcnMobTExLCBtMTIsIG0yMSwgbTIyKSB7XG5pZiAobTExID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTExKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0xMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm0xMSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAobTEyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTEyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0xMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm0xMiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAobTIxID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTIxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm0yMSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAobTIyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTIyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm0yMiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuIFttMTEsIG0xMiwgbTIxLCBtMjIsIGFjb3MobTExKV07XG59XG4vKipcbiAqIEByZXR1cm4ge01hdHJpeDIyfVxuICovXG5mdW5jdGlvbiB6ZXJvKCkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgMCwgMF07XG59XG4vKipcbiAqIEByZXR1cm4ge01hdHJpeDIyfVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSgpIHtcbiAgICByZXR1cm4gWzEsIDAsIDAsIDEsIDBdO1xufVxuLyoqXG4gKiBAcGFyYW0ge01hdHJpeDIyfSBvdXRcbiAqIEBwYXJhbSB7TWF0cml4MjJ9IG1hdDIyXG4gKiBAcmV0dXJuIHtNYXRyaXgyMn1cbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIG1hdDIyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMiBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KG1hdDIyKSB8fCBtYXQyMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hdDIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hdDIyWzBdIHx8IG1hdDIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obWF0MjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWF0MjJbMV0gfHwgbWF0MjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXQyMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXQyMlsyXSB8fCBtYXQyMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hdDIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hdDIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMiBtYXQyMlwiKVxufVxuXG4gICAgb3V0WzBdID0gbWF0MjJbMF07XG4gICAgb3V0WzFdID0gbWF0MjJbMV07XG4gICAgb3V0WzJdID0gbWF0MjJbMl07XG4gICAgb3V0WzNdID0gbWF0MjJbM107XG5cbiAgICBvdXRbNF0gPSBtYXQyMls0XTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU29sdmUgQSAqIHggPSBiXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge01hdHJpeDIyfSBtYXQyMlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBzb2x2ZShvdXRfdmVjMiwgbWF0MjIsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtYXQyMikgfHwgbWF0MjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXQyMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXQyMlswXSB8fCBtYXQyMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hdDIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hdDIyWzFdIHx8IG1hdDIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obWF0MjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWF0MjJbMl0gfHwgbWF0MjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXQyMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXQyMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjIgbWF0MjJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICB2YXIgeCA9IHZlYzJbMF0sXG4gICAgICAgIHkgPSB2ZWMyWzFdO1xuXG4gICAgdmFyIGExMSA9IG1hdDIyWzBdLFxuICAgICAgICBhMTIgPSBtYXQyMlsyXSxcbiAgICAgICAgYTIxID0gbWF0MjJbMV0sXG4gICAgICAgIGEyMiA9IG1hdDIyWzNdLFxuICAgICAgICBkZXQgPSAxIC8gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG5cbiAgICBvdXRfdmVjMlswXSA9IGRldCAqIChhMjIgKiB4IC0gYTEyICogeSk7XG4gICAgb3V0X3ZlYzJbMV0gPSBkZXQgKiAoYTExICogeSAtIGEyMSAqIHgpO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge01hdHJpeDIyfSBtYXQyMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmFudChtYXQyMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG1hdDIyKSB8fCBtYXQyMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hdDIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hdDIyWzBdIHx8IG1hdDIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obWF0MjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWF0MjJbMV0gfHwgbWF0MjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXQyMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXQyMlsyXSB8fCBtYXQyMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hdDIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hdDIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMiBtYXQyMlwiKVxufVxuXG4gICAgcmV0dXJuIG1hdDIyWzBdICogbWF0MjJbM10gLSBtYXQyMlsxXSAqIG1hdDIyWzJdO1xufVxuLyoqXG4gKiBAcGFyYW0ge01hdHJpeDIyfSBvdXRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zXG4gKiBAcmV0dXJuIHtNYXRyaXgyMn1cbiAqL1xuZnVuY3Rpb24gc2V0Um90YXRpb24ob3V0LCByYWRpYW5zKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMiBvdXRcIilcbn1cblxuaWYgKHJhZGlhbnMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyYWRpYW5zKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGlhbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpYW5zIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICB2YXIgYyA9IGNvcyhyYWRpYW5zKSxcbiAgICAgICAgcyA9IHNpbihyYWRpYW5zKTtcblxuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gLXM7XG4gICAgb3V0WzJdID0gcztcbiAgICBvdXRbM10gPSBjO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtNYXRyaXgyMn0gbWF0MjJcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dF92ZWMyLCBtYXQyMiwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KG1hdDIyKSB8fCBtYXQyMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hdDIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hdDIyWzBdIHx8IG1hdDIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obWF0MjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWF0MjJbMV0gfHwgbWF0MjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXQyMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXQyMlsyXSB8fCBtYXQyMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hdDIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hdDIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMiBtYXQyMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gdmVjMlswXSAqIG1hdDIyWzBdIC0gdmVjMlsxXSAqIG1hdDIyWzNdO1xuICAgIG91dF92ZWMyWzFdID0gdmVjMlswXSAqIG1hdDIyWzNdICsgdmVjMlsxXSAqIG1hdDIyWzBdO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge01hdHJpeDIyfSBtYXQyMlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiB1bnJvdGF0ZShvdXRfdmVjMiwgbWF0MjIsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtYXQyMikgfHwgbWF0MjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXQyMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXQyMlswXSB8fCBtYXQyMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hdDIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hdDIyWzFdIHx8IG1hdDIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obWF0MjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWF0MjJbMl0gfHwgbWF0MjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXQyMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXQyMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjIgbWF0MjJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IHZlYzJbMF0gKiBtYXQyMlswXSArIHZlYzJbMV0gKiBtYXQyMlszXTtcbiAgICBvdXRfdmVjMlsxXSA9IC12ZWMyWzBdICogbWF0MjJbM10gKyB2ZWMyWzFdICogbWF0MjJbMF07XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIEBwYXJhbSB7TWF0cml4MjJ9IG91dFxuICogQHBhcmFtIHtNYXRyaXgyMn0gbWF0MjJcbiAqIEByZXR1cm4ge01hdHJpeDIyfVxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBtYXQyMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjIgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtYXQyMikgfHwgbWF0MjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXQyMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXQyMlswXSB8fCBtYXQyMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hdDIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1hdDIyWzFdIHx8IG1hdDIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obWF0MjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWF0MjJbMl0gfHwgbWF0MjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXQyMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXQyMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjIgbWF0MjJcIilcbn1cblxuICAgIHZhciBhID0gbWF0MjJbMF0sXG4gICAgICAgIGIgPSBtYXQyMlsyXSxcbiAgICAgICAgYyA9IG1hdDIyWzFdLFxuICAgICAgICBkID0gbWF0MjJbM10sXG5cbiAgICAgICAgZGV0ID0gMSAvIChhICogZCAtIGIgKiBjKTtcblxuICAgIG91dFswXSA9IGRldCAqIGQ7XG4gICAgb3V0WzJdID0gLWRldCAqIGI7XG4gICAgb3V0WzFdID0gLWRldCAqIGM7XG4gICAgb3V0WzNdID0gZGV0ICogYTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbnZhciBNYXRyaXgyMiA9IHtcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICBmcm9tQW5nbGU6IGZyb21BbmdsZSxcbiAgICBmcm9tTnVtYmVyczogZnJvbU51bWJlcnMsXG4gICAgemVybzogemVybyxcbiAgICBpZGVudGl0eTogaWRlbnRpdHksXG4gICAgY29weTogY29weSxcbiAgICBzb2x2ZTogc29sdmUsXG4gICAgZGV0ZXJtaW5hbnQ6IGRldGVybWluYW50LFxuICAgIHNldFJvdGF0aW9uOiBzZXRSb3RhdGlvbixcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICB1bnJvdGF0ZTogdW5yb3RhdGUsXG4gICAgaW52ZXJ0OiBpbnZlcnRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4MjI7IiwiLyoqXG4gKiBTdGFiaWxpdHk6IDEgKE9ubHkgYWRkaXRpb25zICYgZml4ZXMpXG4gKlxuICogMngzIFRyYW5zZm9ybWF0aW9uIG1hdHJpeCB1c2VkIGluIDJEIChjb2x1bW4tbWFqb3IpIHJlcHJlc2VudGVkIGFzIGEgOCBjb29yZGluYXRlcyBhcnJheVxuICogW20xMTpOdW1iZXIsIG0xMjpOdW1iZXIsIG0xMzpOdW1iZXIsIG0yMTpOdW1iZXIsIG0yMjpOdW1iZXIsIG0yMzpOdW1iZXIsICoqY2FjaGUqKjpBcnJheSg1KSwgZGlydHk6Qm9vbGVhbl1cbiAqIGNhY2hlID0gW3hTY2FsZTpOdW1iZXIsIHlTY2FsZTpOdW1iZXIsIHhTa2V3Ok51bWJlciwgeVNjYWxlOk51bWJlciwgcm90YXRpb246TnVtYmVyXVxuICogKiB3aHkgY2FjaGU/IFNwZWVkIGltcHJvdmVtZW50cyBpbiBleGNoYW5nZSBvZiBtZW1vcnkgdG8gYXZvaWQgdGFuL2F0YW4yL3NxcnQuXG4gKiAqIHdoeSBkaXJ0eT8gTWF0cml4LnRyYW5zZm9ybSBjb3VsZCBiZSBleHBlbnNpdmUgd2l0aCBsYXJnZSBwb2x5Z29ucywga2VlcCB0cmFjayBvZiB0aGlzIHZhcmlhYmxlIHRvIHRyYW5zZm9ybSBvbmx5IHdoZW4gbmVjZXNzYXJ5LlxuICogQFRPRE8gZFNldFNrZXdYIC8gZFNldFNrZXdZXG4gKi9cblxuLy8gY2FjaGUgdmFyaWFibGVzXG52YXIgREVHX1RPX1JBRCA9IE1hdGguREVHX1RPX1JBRCxcbiAgICBQSSA9IE1hdGguUEksXG4gICAgY29zID0gTWF0aC5jb3MsXG4gICAgc2luID0gTWF0aC5zaW4sXG4gICAgdGFuID0gTWF0aC50YW4sXG4gICAgYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgIF9feCxcbiAgICBfX3ksXG4gICAgYXV4X3ZlYyA9IFswLCAwXSxcbiAgICBjID0gMCxcbiAgICBzID0gMCxcbiAgICBhbmdsZSA9IDAsXG4gICAgbTExID0gMCxcbiAgICBtMTIgPSAwLFxuICAgIG0yMSA9IDAsXG4gICAgbTIyID0gMCxcbiAgICBkeCA9IDAsXG4gICAgZHkgPSAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgMngzIG1hdHJpeFxuICogQHJldHVybiB7TWF0cml4MjN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDAsIFsxLCAxLCAwLCAwLCAwXSwgZmFsc2VdO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0cml4IGdpdmVuIDQgcG9pbnRzKGEgUmVjdGFuZ2xlKVxuICpcbiAqIEB0b2RvXG4gKiBAc2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZEZySFMvMS9cbiAqIEByZXR1cm4ge01hdHJpeDIzfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGZyb21Qb2ludHMoKSB7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXRyaXggZ2l2ZW4gNCBwb2ludHMoYSBSZWN0YW5nbGUpXG4gKlxuICogQHRvZG9cbiAqIEBzZWUgaHR0cDovL2pzZmlkZGxlLm5ldC9kRnJIUy8xL1xuICogQHJldHVybiB7TWF0cml4MjN9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gZnJvbUFuZ2xlKCkge1xuICAgIHJldHVybiBbMSwgMCwgMCwgMSwgMCwgMCwgWzEsIDEsIDAsIDAsIDBdLCBmYWxzZV07XG59XG5cbi8qKlxuICogQ29weSBtMmQgaW50byBvdXRcbiAqXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBvdXQgZGVzdGlueSBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIG0yZCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSB8fCBvdXRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzRdIHx8IG91dFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbiAgICBvdXRbMF0gPSBtMmRbMF07XG4gICAgb3V0WzFdID0gbTJkWzFdO1xuICAgIG91dFsyXSA9IG0yZFsyXTtcbiAgICBvdXRbM10gPSBtMmRbM107XG4gICAgb3V0WzRdID0gbTJkWzRdO1xuICAgIG91dFs1XSA9IG0yZFs1XTtcblxuICAgIG91dFs2XVswXSA9IG0yZFs2XVswXTtcbiAgICBvdXRbNl1bMV0gPSBtMmRbNl1bMV07XG4gICAgb3V0WzZdWzJdID0gbTJkWzZdWzJdO1xuICAgIG91dFs2XVszXSA9IG0yZFs2XVszXTtcbiAgICBvdXRbNl1bNF0gPSBtMmRbNl1bNF07XG5cbiAgICBvdXRbN10gPSBtMmRbN107XG5cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IG0yZCBpbnRvIG91dFxuICpcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG91dCBkZXN0aW55IG1hdHJpeFxuICogQHJldHVybiB7TWF0cml4MjN9IG91dCAyeDMgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSB8fCBvdXRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzRdIHx8IG91dFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG91dFwiKVxufVxuXG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl1bMF0gPSAxO1xuICAgIG91dFs2XVsxXSA9IDE7XG4gICAgb3V0WzZdWzJdID0gMDtcbiAgICBvdXRbNl1bM10gPSAwO1xuICAgIG91dFs2XVs0XSA9IDA7XG5cbiAgICBvdXRbN10gPSBmYWxzZTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIE1hdHJpeDIzIGJ5IHRoZSBnaXZlbiBhbmdsZSBpbiBkZWdyZWVzKGluY3JlbWVudCByb3RhdGlvbilcbiAqIEBub3RlIGluY3JlbWVudCByb3RhdGlvblxuICpcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG91dCBkZXN0aW55IG1hdHJpeFxuICogQHBhcmFtIHtNYXRyaXgyM30gbTJkIHNvdXJjZSBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWVzIERlZ3JlZXNcbiAqIEByZXR1cm4ge01hdHJpeDIzfSBvdXQgMngzIG1hdHJpeFxuICovXG5mdW5jdGlvbiBkUm90YXRlKG91dCwgbTJkLCBkZWdyZWVzKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxuaWYgKGRlZ3JlZXMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihkZWdyZWVzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGRlZ3JlZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWdyZWVzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gcm90YXRlKG91dCwgbTJkLCBkZWdyZWVzICogREVHX1RPX1JBRCk7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBNYXRyaXgyMyBieSB0aGUgZ2l2ZW4gYW5nbGUgaW4gcmFkaWFucyhpbmNyZW1lbnQgcm90YXRpb24pXG4gKiBAbm90ZSBpbmNyZW1lbnQgcm90YXRpb25cbiAqXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBvdXQgZGVzdGlueSBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBSYWRpYW5zXG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dCwgbTJkLCByYWRpYW5zKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxuaWYgKHJhZGlhbnMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyYWRpYW5zKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGlhbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpYW5zIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBjID0gY29zKHJhZGlhbnMpO1xuICAgIHMgPSBzaW4ocmFkaWFucyk7XG4gICAgbTExID0gbTJkWzBdICogYyArICBtMmRbMl0gKiBzO1xuICAgIG0xMiA9IG0yZFsxXSAqIGMgKyAgbTJkWzNdICogcztcbiAgICBtMjEgPSBtMmRbMF0gKiAtcyArIG0yZFsyXSAqIGM7XG4gICAgbTIyID0gbTJkWzFdICogLXMgKyBtMmRbM10gKiBjO1xuXG4gICAgb3V0WzBdID0gbTExO1xuICAgIG91dFsxXSA9IG0xMjtcbiAgICBvdXRbMl0gPSBtMjE7XG4gICAgb3V0WzNdID0gbTIyO1xuXG4gICAgLy8gY29weVxuICAgIG91dFs0XSA9IG0yZFs0XTtcbiAgICBvdXRbNV0gPSBtMmRbNV07XG4gICAgb3V0WzZdWzBdID0gbTJkWzZdWzBdO1xuICAgIG91dFs2XVsxXSA9IG0yZFs2XVsxXTtcbiAgICBvdXRbNl1bMl0gPSBtMmRbNl1bMl07XG4gICAgb3V0WzZdWzNdID0gbTJkWzZdWzNdO1xuICAgIG91dFs2XVs0XSA9IG0yZFs2XVs0XSArIHJhZGlhbnM7XG5cbiAgICBvdXRbN10gPSB0cnVlO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgcm90YXRpb24gb2YgYSBNYXRyaXgyMyBieSB0aGUgZ2l2ZW4gYW5nbGUgaW4gZGVncmVlcyhzZXQgcm90YXRpb24pXG4gKiBAbm90ZSBzZXQgcm90YXRpb25cbiAqXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBvdXQgZGVzdGlueSBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyBEZWdyZWVzXG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gZFJvdGF0aW9uKG91dCwgbTJkLCBkZWdyZWVzKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxuaWYgKGRlZ3JlZXMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihkZWdyZWVzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGRlZ3JlZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWdyZWVzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gcm90YXRpb24ob3V0LCBtMmQsIGRlZ3JlZXMgKiBERUdfVE9fUkFEKTtcbn1cblxuLyoqXG4gKiBTZXQgcm90YXRpb24gb2YgYSBNYXRyaXgyMyBieSB0aGUgZ2l2ZW4gYW5nbGUgaW4gcmFkaWFucyhzZXQgcm90YXRpb24pXG4gKiBAbm90ZSBzZXQgcm90YXRpb25cbiAqXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBvdXQgZGVzdGlueSBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBSYWRpYW5zXG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gcm90YXRpb24ob3V0LCBtMmQsIHJhZGlhbnMpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF0gfHwgb3V0WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsxXSB8fCBvdXRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzJdIHx8IG91dFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbM10gfHwgb3V0WzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs0XSB8fCBvdXRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KG0yZCkgfHwgbTJkWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFswXSB8fCBtMmRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzFdIHx8IG0yZFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMl0gfHwgbTJkWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFszXSB8fCBtMmRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzRdIHx8IG0yZFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG0yZFwiKVxufVxuXG5pZiAocmFkaWFucyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJhZGlhbnMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmFkaWFucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJhZGlhbnMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIGMgPSByYWRpYW5zIC0gb3V0WzZdWzRdO1xuXG4gICAgcm90YXRlKG91dCwgbTJkLCBjKTtcblxuICAgIG91dFs2XVs0XSA9IHJhZGlhbnM7XG4gICAgb3V0WzddID0gdHJ1ZTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlcyBnaXZlbiBNYXRyaXgyMyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICogQG5vdGUgVGhpcyB0cmFuc2xhdGlvbiBpcyBhZmZlY3RlZCBieSByb3RhdGlvbi9za2V3XG4gKiBAbm90ZSBpbmNyZW1lbnQgcG9zaXRpb25cbiAqIEBzZWUgZ1RyYW5zbGF0ZVxuICogQHBhcmFtIHtNYXRyaXgyM30gb3V0IGRlc3RpbnkgbWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIG1hdHJpeFxuICogQHBhcmFtIHtWZWMyfSB2ZWMyIGFtb3VudCB0byBiZSB0cmFuc2xhdGVkXG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgbTJkLCB2ZWMyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICBvdXRbMF0gPSBtMmRbMF07XG4gICAgb3V0WzFdID0gbTJkWzFdO1xuICAgIG91dFsyXSA9IG0yZFsyXTtcbiAgICBvdXRbM10gPSBtMmRbM107XG4gICAgb3V0WzRdID0gbTJkWzRdICsgbTJkWzBdICogdmVjMlswXSArIG0yZFsyXSAqIHZlYzJbMV07XG4gICAgb3V0WzVdID0gbTJkWzVdICsgbTJkWzFdICogdmVjMlswXSArIG0yZFszXSAqIHZlYzJbMV07XG5cbiAgICBvdXRbNl1bMF0gPSBtMmRbNl1bMF07XG4gICAgb3V0WzZdWzFdID0gbTJkWzZdWzFdO1xuICAgIG91dFs2XVsyXSA9IG0yZFs2XVsyXTtcbiAgICBvdXRbNl1bM10gPSBtMmRbNl1bM107XG4gICAgb3V0WzZdWzRdID0gbTJkWzZdWzRdO1xuXG4gICAgb3V0WzddID0gdHJ1ZTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlcyBnaXZlbiBNYXRyaXgyMyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICogQG5vdGUgVGhpcyB0cmFuc2xhdGlvbiBpcyBOT1QgYWZmZWN0ZWQgYnkgcm90YXRpb24vc2tld1xuICogQG5vdGUgaW5jcmVtZW50IHBvc2l0aW9uXG4gKiBAc2VlIHRyYW5zbGF0ZVxuICogQHBhcmFtIHtNYXRyaXgyM30gb3V0IGRlc3RpbnkgbWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIG1hdHJpeFxuICogQHBhcmFtIHtWZWMyfSB2ZWMyIGFtb3VudCB0byBiZSB0cmFuc2xhdGVkXG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gZ1RyYW5zbGF0ZShvdXQsIG0yZCwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSB8fCBvdXRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzRdIHx8IG91dFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgb3V0WzBdID0gbTJkWzBdO1xuICAgIG91dFsxXSA9IG0yZFsxXTtcbiAgICBvdXRbMl0gPSBtMmRbMl07XG4gICAgb3V0WzNdID0gbTJkWzNdO1xuICAgIG91dFs0XSA9IG0yZFs0XSArIHZlYzJbMF07XG4gICAgb3V0WzVdID0gbTJkWzVdICsgdmVjMlsxXTtcblxuICAgIG91dFs2XVswXSA9IG0yZFs2XVswXTtcbiAgICBvdXRbNl1bMV0gPSBtMmRbNl1bMV07XG4gICAgb3V0WzZdWzJdID0gbTJkWzZdWzJdO1xuICAgIG91dFs2XVszXSA9IG0yZFs2XVszXTtcbiAgICBvdXRbNl1bNF0gPSBtMmRbNl1bNF07XG5cbiAgICBvdXRbN10gPSB0cnVlO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgTWF0cml4MjMgcG9zaXRpb25cbiAqIEBub3RlIFRoaXMgdHJhbnNsYXRpb24gaXMgTk9UIGFmZmVjdGVkIGJ5IHJvdGF0aW9uL3NrZXdcbiAqIEBub3RlIHNldCBwb3NpdGlvblxuICogQHNlZSBnVHJhbnNsYXRlXG4gKiBAc2VlIHRyYW5zbGF0ZVxuICogQHBhcmFtIHtNYXRyaXgyM30gb3V0IGRlc3RpbnkgbWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIG1hdHJpeFxuICogQHBhcmFtIHtWZWMyfSB2ZWMyIGRlc3RpbnkgcG9zaXRpb25cbiAqIEByZXR1cm4ge01hdHJpeDIzfSBvdXQgMngzIG1hdHJpeFxuICovXG5mdW5jdGlvbiBwb3NpdGlvbihvdXQsIG0yZCwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSB8fCBvdXRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzRdIHx8IG91dFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgb3V0WzBdID0gbTJkWzBdO1xuICAgIG91dFsxXSA9IG0yZFsxXTtcbiAgICBvdXRbMl0gPSBtMmRbMl07XG4gICAgb3V0WzNdID0gbTJkWzNdO1xuICAgIG91dFs0XSA9IHZlYzJbMF07XG4gICAgb3V0WzVdID0gdmVjMlsxXTtcblxuICAgIG91dFs2XVswXSA9IG0yZFs2XVswXTtcbiAgICBvdXRbNl1bMV0gPSBtMmRbNl1bMV07XG4gICAgb3V0WzZdWzJdID0gbTJkWzZdWzJdO1xuICAgIG91dFs2XVszXSA9IG0yZFs2XVszXTtcbiAgICBvdXRbNl1bNF0gPSBtMmRbNl1bNF07XG5cbiAgICBvdXRbN10gPSB0cnVlO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIE1hdHJpeDIzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG5cbiAqIEBub3RlIGluY3JlbWVudGFsIHNjYWxlXG4gKiBAbm90ZSBkbyBub3QgYWZmZWN0IHBvc2l0aW9uXG4gKiBAc2VlIHNjYWxhdGlvblxuICogQHBhcmFtIHtNYXRyaXgyM30gb3V0IGRlc3RpbnkgbWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIG1hdHJpeFxuICogQHBhcmFtIHtWZWMyfSB2ZWMyIGRlc3RpbnkgcG9zaXRpb25cbiAqIEByZXR1cm4ge01hdHJpeDIzfSBvdXQgMngzIG1hdHJpeFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIG0yZCwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSB8fCBvdXRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzRdIHx8IG91dFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgX194ID0gdmVjMlswXTtcbiAgICBfX3kgPSB2ZWMyWzFdO1xuXG4gICAgb3V0WzBdID0gbTJkWzBdICogX194O1xuICAgIG91dFsxXSA9IG0yZFsxXSAqIF9feDtcbiAgICBvdXRbMl0gPSBtMmRbMl0gKiBfX3k7XG4gICAgb3V0WzNdID0gbTJkWzNdICogX195O1xuICAgIG91dFs0XSA9IG0yZFs0XTtcbiAgICBvdXRbNV0gPSBtMmRbNV07XG5cbiAgICBvdXRbNl1bMF0gPSBtMmRbNl1bMF0gKiBfX3g7XG4gICAgb3V0WzZdWzFdID0gbTJkWzZdWzFdICogX195O1xuICAgIG91dFs2XVsyXSA9IG0yZFs2XVsyXTtcbiAgICBvdXRbNl1bM10gPSBtMmRbNl1bM107XG4gICAgb3V0WzZdWzRdID0gbTJkWzZdWzRdO1xuXG4gICAgb3V0WzddID0gdHJ1ZTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBNYXRyaXgyMyBzY2FsZSBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuXG4gKiBAbm90ZSBzZXQgc2NhbGVcbiAqIEBub3RlIGRvIG5vdCBhZmZlY3QgcG9zaXRpb25cbiAqIEBzZWUgc2NhbGVcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG91dCBkZXN0aW55IG1hdHJpeFxuICogQHBhcmFtIHtNYXRyaXgyM30gbTJkIHNvdXJjZSBtYXRyaXhcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMiBkZXN0aW55IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gc2NhbGF0aW9uKG91dCwgbTJkLCB2ZWMyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICByZXR1cm4gc2NhbGUob3V0LCBtMmQsIFt2ZWMyWzBdIC8gbTJkWzZdWzBdLCB2ZWMyWzFdIC8gbTJkWzZdWzFdXSk7XG59XG5cbi8qKlxuICogSW5jcmVtZW50IHRoZSBNYXRyaXgyMyB4LXNrZXcgYnkgZ2l2ZW4gZGVncmVlc1xuICpcbiAqIEBub3RlIGluY3JlbWVudCBza2V3WFxuICogQHNlZSBza2V3WFxuICogQHBhcmFtIHtNYXRyaXgyM30gb3V0IGRlc3RpbnkgbWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlZ3JlZXMgRGVncmVlcyB0byBza2V3XG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gZFNrZXdYKG91dCwgbTJkLCBkZWdyZWVzKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxuaWYgKGRlZ3JlZXMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihkZWdyZWVzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGRlZ3JlZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWdyZWVzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gc2tld1gob3V0LCBtMmQsIGRlZ3JlZXMgKiBERUdfVE9fUkFEKTtcbn1cbi8qKlxuICogSW5jcmVtZW50IHRoZSBNYXRyaXgyMyB4LXNrZXcgYnkgZ2l2ZW4gcmFkaWFuc1xuICpcbiAqIEBub3RlIGluY3JlbWVudCBza2V3WFxuICogQHBhcmFtIHtNYXRyaXgyM30gb3V0IGRlc3RpbnkgbWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgUmFkaWFucyB0byBza2V3XG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gc2tld1gob3V0LCBtMmQsIHJhZGlhbnMpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF0gfHwgb3V0WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsxXSB8fCBvdXRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzJdIHx8IG91dFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbM10gfHwgb3V0WzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs0XSB8fCBvdXRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KG0yZCkgfHwgbTJkWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFswXSB8fCBtMmRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzFdIHx8IG0yZFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMl0gfHwgbTJkWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFszXSB8fCBtMmRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzRdIHx8IG0yZFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG0yZFwiKVxufVxuXG5pZiAocmFkaWFucyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJhZGlhbnMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmFkaWFucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJhZGlhbnMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIGFuZ2xlID0gdGFuKHJhZGlhbnMpO1xuXG4gICAgb3V0WzBdID0gbTJkWzBdO1xuICAgIG91dFsxXSA9IG0yZFsxXTtcbiAgICBvdXRbMl0gPSBtMmRbMl0gKyBtMmRbMF0gKiBhbmdsZTtcbiAgICBvdXRbM10gPSBtMmRbM10gKyBtMmRbMV0gKiBhbmdsZTtcbiAgICBvdXRbNF0gPSBtMmRbNF07XG4gICAgb3V0WzVdID0gbTJkWzVdO1xuXG4gICAgb3V0WzZdWzBdID0gbTJkWzZdWzBdO1xuICAgIG91dFs2XVsxXSA9IG0yZFs2XVsxXTtcbiAgICBvdXRbNl1bMl0gPSBtMmRbNl1bMl0gKyByYWRpYW5zO1xuICAgIG91dFs2XVszXSA9IG0yZFs2XVszXTtcbiAgICBvdXRbNl1bNF0gPSBtMmRbNl1bNF07XG5cbiAgICBvdXRbN10gPSB0cnVlO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbmNyZW1lbnQgdGhlIE1hdHJpeDIzIHktc2tldyBieSBnaXZlbiBkZWdyZWVzXG4gKlxuICogQG5vdGUgaW5jcmVtZW50IHNrZXdZXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBvdXQgZGVzdGlueSBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyBEZWdyZWVzIHRvIHNrZXdcbiAqIEByZXR1cm4ge01hdHJpeDIzfSBvdXQgMngzIG1hdHJpeFxuICovXG5mdW5jdGlvbiBkU2tld1kob3V0LCBtMmQsIGRlZ3JlZXMpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF0gfHwgb3V0WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsxXSB8fCBvdXRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzJdIHx8IG91dFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbM10gfHwgb3V0WzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs0XSB8fCBvdXRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KG0yZCkgfHwgbTJkWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFswXSB8fCBtMmRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzFdIHx8IG0yZFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMl0gfHwgbTJkWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFszXSB8fCBtMmRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzRdIHx8IG0yZFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG0yZFwiKVxufVxuXG5pZiAoZGVncmVlcyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGRlZ3JlZXMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgZGVncmVlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRlZ3JlZXMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiBza2V3WShvdXQsIG0yZCwgZGVncmVlcyAqIERFR19UT19SQUQpO1xufVxuLyoqXG4gKiBJbmNyZW1lbnQgdGhlIE1hdHJpeDIzIHktc2tldyBieSBnaXZlbiByYWRpYW5zXG4gKlxuICogQG5vdGUgaW5jcmVtZW50IHNrZXdZXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBvdXQgZGVzdGlueSBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBSYWRpYW5zIHRvIHNrZXdcbiAqIEByZXR1cm4ge01hdHJpeDIzfSBvdXQgMngzIG1hdHJpeFxuICovXG5mdW5jdGlvbiBza2V3WShvdXQsIG0yZCwgcmFkaWFucykge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSB8fCBvdXRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzRdIHx8IG91dFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbmlmIChyYWRpYW5zID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmFkaWFucykgfHwgJ251bWJlcicgIT09IHR5cGVvZiByYWRpYW5zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmFkaWFucyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgYW5nbGUgPSB0YW4ocmFkaWFucyk7XG5cbiAgICBvdXRbMF0gPSBtMmRbMF0gKyBtMmRbMl0gKiBhbmdsZTtcbiAgICBvdXRbMV0gPSBtMmRbMV0gKyBtMmRbM10gKiBhbmdsZTtcbiAgICBvdXRbMl0gPSBtMmRbMl07XG4gICAgb3V0WzNdID0gbTJkWzNdO1xuICAgIG91dFs0XSA9IG0yZFs0XTtcbiAgICBvdXRbNV0gPSBtMmRbNV07XG5cbiAgICBvdXRbNl1bMF0gPSBtMmRbNl1bMF07XG4gICAgb3V0WzZdWzFdID0gbTJkWzZdWzFdO1xuICAgIG91dFs2XVsyXSA9IG0yZFs2XVsyXTtcbiAgICBvdXRbNl1bM10gPSBtMmRbNl1bM10gKyBhbmdsZTtcbiAgICBvdXRbNl1bNF0gPSBtMmRbNl1bNF07XG5cbiAgICBvdXRbN10gPSB0cnVlO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbmNyZW1lbnQgdGhlIE1hdHJpeDIzIHNrZXcgeSBieSBnaXZlbiBkZWdyZWVzIGluIHZlYzJfZGVncmVlc1xuICpcbiAqIEBub3RlIGluY3JlbWVudCBza2V3XG4gKiBAc2VlIGRTZXRTa2V3XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBvdXQgZGVzdGlueSBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgbWF0cml4XG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJfZGVncmVlcyBEZWdyZWVzIHRvIHNrZXdcbiAqIEByZXR1cm4ge01hdHJpeDIzfSBvdXQgMngzIG1hdHJpeFxuICovXG5mdW5jdGlvbiBkU2tldyhvdXQsIG0yZCwgdmVjMl9kZWdyZWVzKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzJfZGVncmVlcykgfHwgdmVjMl9kZWdyZWVzWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMl9kZWdyZWVzWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJfZGVncmVlc1swXSB8fCB2ZWMyX2RlZ3JlZXNbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyX2RlZ3JlZXNbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMl9kZWdyZWVzWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJfZGVncmVlc1wiKVxufVxuXG4gICAgYXV4X3ZlY1swXSA9IHZlYzJfZGVncmVlc1swXSAqIERFR19UT19SQUQ7XG4gICAgYXV4X3ZlY1sxXSA9IHZlYzJfZGVncmVlc1sxXSAqIERFR19UT19SQUQ7XG5cbiAgICByZXR1cm4gc2tldyhvdXQsIG0yZCwgYXV4X3ZlYyk7XG59XG5cbi8qKlxuICogSW5jcmVtZW50IHRoZSBNYXRyaXgyMyBza2V3IHkgYnkgZ2l2ZW4gcmFkaWFucyBpbiB2ZWMyXG4gKlxuICogQG5vdGUgaW5jcmVtZW50IHNrZXdcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG91dCBkZXN0aW55IG1hdHJpeFxuICogQHBhcmFtIHtNYXRyaXgyM30gbTJkIHNvdXJjZSBtYXRyaXhcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMl9yYWRpYW5zIFJhZGlhbnMgdG8gc2tld1xuICogQHJldHVybiB7TWF0cml4MjN9IG91dCAyeDMgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIHNrZXcob3V0LCBtMmQsIHZlYzJfcmFkaWFucykge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSB8fCBvdXRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzRdIHx8IG91dFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyX3JhZGlhbnMpIHx8IHZlYzJfcmFkaWFuc1swXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJfcmFkaWFuc1swXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyX3JhZGlhbnNbMF0gfHwgdmVjMl9yYWRpYW5zWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMl9yYWRpYW5zWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJfcmFkaWFuc1sxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyX3JhZGlhbnNcIilcbn1cblxuICAgIGMgPSB0YW4odmVjMl9yYWRpYW5zWzBdKTtcbiAgICBzID0gdGFuKHZlYzJfcmFkaWFuc1sxXSk7XG5cbiAgICBvdXRbMF0gPSBtMmRbMF0gKyBtMmRbMl0gKiBzO1xuICAgIG91dFsxXSA9IG0yZFsxXSArIG0yZFszXSAqIHM7XG4gICAgb3V0WzJdID0gbTJkWzJdICsgbTJkWzBdICogYztcbiAgICBvdXRbM10gPSBtMmRbM10gKyBtMmRbMV0gKiBjO1xuICAgIG91dFs0XSA9IG0yZFs0XTtcbiAgICBvdXRbNV0gPSBtMmRbNV07XG5cbiAgICBvdXRbNl1bMF0gPSBtMmRbNl1bMF07XG4gICAgb3V0WzZdWzFdID0gbTJkWzZdWzFdO1xuICAgIG91dFs2XVsyXSA9IG0yZFs2XVsyXSArIHZlYzJfcmFkaWFuc1swXTtcbiAgICBvdXRbNl1bM10gPSBtMmRbNl1bM10gKyB2ZWMyX3JhZGlhbnNbMV07XG4gICAgb3V0WzZdWzRdID0gbTJkWzZdWzRdO1xuXG4gICAgb3V0WzddID0gdHJ1ZTtcblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgTWF0cml4MjMgc2tldyB5IGJ5IGdpdmVuIGRlZ3JlZXMgaW4gdmVjMl9kZWdyZWVzXG4gKlxuICogQG5vdGUgc2V0IHNrZXdcbiAqIEBzZWUgc2V0U2tld1xuICogQHBhcmFtIHtNYXRyaXgyM30gb3V0IGRlc3RpbnkgbWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIG1hdHJpeFxuICogQHBhcmFtIHtWZWMyfSB2ZWMyX2RlZ3JlZXMgRGVncmVlcyB0byBza2V3XG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gZFNldFNrZXcob3V0LCBtMmQsIHZlYzJfZGVncmVlcykge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSB8fCBvdXRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzRdIHx8IG91dFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyX2RlZ3JlZXMpIHx8IHZlYzJfZGVncmVlc1swXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJfZGVncmVlc1swXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyX2RlZ3JlZXNbMF0gfHwgdmVjMl9kZWdyZWVzWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMl9kZWdyZWVzWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJfZGVncmVlc1sxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyX2RlZ3JlZXNcIilcbn1cblxuICAgIGF1eF92ZWNbMF0gPSB2ZWMyX2RlZ3JlZXNbMF0gKiBERUdfVE9fUkFEO1xuICAgIGF1eF92ZWNbMV0gPSB2ZWMyX2RlZ3JlZXNbMV0gKiBERUdfVE9fUkFEO1xuXG4gICAgcmV0dXJuIHNldFNrZXcob3V0LCBtMmQsIGF1eF92ZWMpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgTWF0cml4MjMgc2tldyB5IGJ5IGdpdmVuIHJhZGlhbnMgaW4gdmVjMlxuICpcbiAqIEBub3RlIHNldCBza2V3XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBvdXQgZGVzdGlueSBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgbWF0cml4XG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJfcmFkaWFucyBSYWRpYW5zIHRvIHNrZXdcbiAqIEByZXR1cm4ge01hdHJpeDIzfSBvdXQgMngzIG1hdHJpeFxuICovXG5mdW5jdGlvbiBzZXRTa2V3KG91dCwgbTJkLCB2ZWMyX3JhZGlhbnMpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF0gfHwgb3V0WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsxXSB8fCBvdXRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzJdIHx8IG91dFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbM10gfHwgb3V0WzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs0XSB8fCBvdXRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KG0yZCkgfHwgbTJkWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFswXSB8fCBtMmRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzFdIHx8IG0yZFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMl0gfHwgbTJkWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFszXSB8fCBtMmRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzRdIHx8IG0yZFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG0yZFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMl9yYWRpYW5zKSB8fCB2ZWMyX3JhZGlhbnNbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyX3JhZGlhbnNbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMl9yYWRpYW5zWzBdIHx8IHZlYzJfcmFkaWFuc1sxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJfcmFkaWFuc1sxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyX3JhZGlhbnNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMl9yYWRpYW5zXCIpXG59XG5cbiAgICBjID0gdGFuKHZlYzJfcmFkaWFuc1swXSAtIG0yZFs2XVsyXSk7XG4gICAgcyA9IHRhbih2ZWMyX3JhZGlhbnNbMV0gLSBtMmRbNl1bM10pO1xuXG4gICAgb3V0WzBdID0gbTJkWzBdICsgbTJkWzJdICogcztcbiAgICBvdXRbMV0gPSBtMmRbMV0gKyBtMmRbM10gKiBzO1xuICAgIG91dFsyXSA9IG0yZFsyXSArIG0yZFswXSAqIGM7XG4gICAgb3V0WzNdID0gbTJkWzNdICsgbTJkWzFdICogYztcbiAgICBvdXRbNF0gPSBtMmRbNF07XG4gICAgb3V0WzVdID0gbTJkWzVdO1xuXG4gICAgb3V0WzZdWzBdID0gbTJkWzZdWzBdO1xuICAgIG91dFs2XVsxXSA9IG0yZFs2XVsxXTtcbiAgICBvdXRbNl1bMl0gPSB2ZWMyX3JhZGlhbnNbMF07XG4gICAgb3V0WzZdWzNdID0gdmVjMl9yYWRpYW5zWzFdO1xuICAgIG91dFs2XVs0XSA9IG0yZFs2XVs0XTtcblxuICAgIG91dFs3XSA9IHRydWU7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gTWF0cml4MjMnc1xuICpcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG91dCBkZXN0aW55IG1hdHJpeChBKkIpXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgQSBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZF8yIEIgbWF0cml4XG4gKiBAcmV0dXJuIHtNYXRyaXgyM30gb3V0IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBtMmQsIG0yZF8yKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KG0yZF8yKSB8fCBtMmRfMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZF8yWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZF8yWzBdIHx8IG0yZF8yWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkXzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkXzJbMV0gfHwgbTJkXzJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRfMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRfMlsyXSB8fCBtMmRfMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZF8yWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZF8yWzNdIHx8IG0yZF8yWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkXzJbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkXzJbNF0gfHwgbTJkXzJbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRfMls1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRfMls1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXzJcIilcbn1cblxuICAgIG0xMSA9IG0yZFswXSAqIG0yZF8yWzBdICsgbTJkWzJdICogbTJkXzJbMV07XG4gICAgbTEyID0gbTJkWzFdICogbTJkXzJbMF0gKyBtMmRbM10gKiBtMmRfMlsxXTtcblxuICAgIG0yMSA9IG0yZFswXSAqIG0yZF8yWzJdICsgbTJkWzJdICogbTJkXzJbM107XG4gICAgbTIyID0gbTJkWzFdICogbTJkXzJbMl0gKyBtMmRbM10gKiBtMmRfMlszXTtcblxuICAgIGR4ID0gbTJkWzBdICogbTJkXzJbNF0gKyBtMmRbMl0gKiBtMmRfMls1XSArIG0yZFs0XTtcbiAgICBkeSA9IG0yZFsxXSAqIG0yZF8yWzRdICsgbTJkWzNdICogbTJkXzJbNV0gKyBtMmRbNV07XG5cbiAgICBvdXRbMF0gPSBtMTE7XG4gICAgb3V0WzFdID0gbTEyO1xuICAgIG91dFsyXSA9IG0yMTtcbiAgICBvdXRbM10gPSBtMjI7XG4gICAgb3V0WzRdID0gZHg7XG4gICAgb3V0WzVdID0gZHk7XG5cblxuICAgIG91dFs2XVswXSA9IG0yZFs2XVswXTtcbiAgICBvdXRbNl1bMV0gPSBtMmRbNl1bMV07XG4gICAgb3V0WzZdWzJdID0gbTJkWzZdWzJdO1xuICAgIG91dFs2XVszXSA9IG0yZFs2XVszXTtcbiAgICBvdXRbNl1bNF0gPSBtMmRbNl1bNF07XG5cbiAgICBvdXRbN10gPSB0cnVlO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIGEgTWF0cml4MjMgYW5kIGEgVmVjMlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzIgZGVzdGlueSBWZWMyXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIE1hdHJpeDIzXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEByZXR1cm4ge1ZlYzJ9IG91dF92ZWMyLCByZXN1bHQgVmVjMlxuICovXG5mdW5jdGlvbiBtdWx0aXBseVZlYzIob3V0X3ZlYzIsIG0yZCwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KG0yZCkgfHwgbTJkWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFswXSB8fCBtMmRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzFdIHx8IG0yZFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMl0gfHwgbTJkWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFszXSB8fCBtMmRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzRdIHx8IG0yZFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG0yZFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gdmVjMlswXSAqIG0yZFswXSArIHZlYzJbMF0gKiBtMmRbMl0gKyB2ZWMyWzBdICogbTJkWzRdO1xuICAgIG91dF92ZWMyWzFdID0gdmVjMlsxXSAqIG0yZFsxXSArIHZlYzJbMV0gKiBtMmRbM10gKyB2ZWMyWzFdICogbTJkWzVdO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuXG4vKipcbiAqIFJldHJpZXZlIGN1cnJlbnQgcG9zaXRpb24gYXMgVmVjMlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzIgZGVzdGlueSBWZWMyXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIE1hdHJpeDIzXG4gKiBAcmV0dXJuIHtWZWMyfSBvdXRfdmVjMiwgcmVzdWx0IFZlYzJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9zaXRpb24ob3V0X3ZlYzIsIG0yZCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KG0yZCkgfHwgbTJkWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFswXSB8fCBtMmRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzFdIHx8IG0yZFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMl0gfHwgbTJkWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFszXSB8fCBtMmRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzRdIHx8IG0yZFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG0yZFwiKVxufVxuXG4gICAgb3V0X3ZlYzJbMF0gPSBtMmRbNF07XG4gICAgb3V0X3ZlYzJbMV0gPSBtMmRbNV07XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG5cbi8qKlxuICogUmV0cmlldmUgY3VycmVudCBzY2FsZSBhcyBWZWMyXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMiBkZXN0aW55IFZlYzJcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgTWF0cml4MjNcbiAqIEByZXR1cm4ge1ZlYzJ9IG91dF92ZWMyLCByZXN1bHQgVmVjMlxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShvdXRfdmVjMiwgbTJkKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IG0yZFs2XVswXTtcbiAgICBvdXRfdmVjMlsxXSA9IG0yZFs2XVsxXTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBjdXJyZW50IHNrZXcgYXMgVmVjMlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzIgZGVzdGlueSBWZWMyXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmQgc291cmNlIE1hdHJpeDIzXG4gKiBAcmV0dXJuIHtWZWMyfSBvdXRfdmVjMiwgcmVzdWx0IFZlYzJcbiAqL1xuZnVuY3Rpb24gZ2V0U2tldyhvdXRfdmVjMiwgbTJkKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IG0yZFs2XVsyXTtcbiAgICBvdXRfdmVjMlsxXSA9IG0yZFs2XVszXTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cblxuLyoqXG4gKiBBbGlhcyBvZiByb3RhdGUgMTgwwrooUEkpXG4gKlxuICogQHBhcmFtIHtNYXRyaXgyM30gb3V0IGRlc3RpbnkgTWF0cml4MjNcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgTWF0cml4MjNcbiAqIEByZXR1cm4ge01hdHJpeDIzfSBvdXQgMngzIG1hdHJpeFxuICovXG5mdW5jdGlvbiByZWZsZWN0KG91dCwgbTJkKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxuICAgIHJldHVybiByb3RhdGUob3V0LCBtMmQsIFBJKTtcbn1cblxuLyoqXG4gKiBAVE9ETyBuZWVkZWQgP1xuICogQHBhcmFtIHtNYXRyaXgyM30gb3V0IGRlc3RpbnkgTWF0cml4MjNcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgTWF0cml4MjNcbiAqL1xuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgbTJkKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0KSB8fCBvdXRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdIHx8IG91dFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV0gfHwgb3V0WzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXSB8fCBvdXRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzNdIHx8IG91dFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNF0gfHwgb3V0WzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgb3V0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmQpIHx8IG0yZFswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMF0gfHwgbTJkWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsxXSB8fCBtMmRbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzJdIHx8IG0yZFszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbM10gfHwgbTJkWzRdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs0XSB8fCBtMmRbNV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNYXRyaXgyMyBtMmRcIilcbn1cblxufVxuXG4vKipcbiAqIEBUT0RPIHJldmlldyAmIHRlc3RcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBzb3VyY2UgTWF0cml4MjNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5hbnQobTJkKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbiAgICB2YXIgZkNvZmFjdG9yMDAgPSBtMmRbMV1bMV0gKiBtMmRbMl1bMl0gLSBtMmRbMV1bMl0gKiBtMmRbMl1bMV0sXG4gICAgICAgIGZDb2ZhY3RvcjEwID0gbTJkWzFdWzJdICogbTJkWzJdWzBdIC0gbTJkWzFdWzBdICogbTJkWzJdWzJdLFxuICAgICAgICBmQ29mYWN0b3IyMCA9IG0yZFsxXVswXSAqIG0yZFsyXVsxXSAtIG0yZFsxXVsxXSAqIG0yZFsyXVswXTtcblxuICAgIHJldHVybiBtMmRbMF1bMF0gKiBmQ29mYWN0b3IwMCArXG4gICAgICAgIG0yZFswXVsxXSAqIGZDb2ZhY3RvcjEwICtcbiAgICAgICAgbTJkWzBdWzJdICogZkNvZmFjdG9yMjA7XG5cbn1cblxuXG4vKipcbiAqIFJldHVybnMgYSAzeDIgMkQgY29sdW1uLW1ham9yIHRyYW5zbGF0aW9uIG1hdHJpeCBmb3IgeCBhbmQgeS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge01hdHJpeDIzfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0aW9uTWF0cml4KHgsIHkpIHtcbmlmICh4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiBbIDEsIDAsIDAsIDEsIHgsIHkgXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgM3gyIDJEIGNvbHVtbi1tYWpvciB5LXNrZXcgbWF0cml4IGZvciB0aGUgZ2l2ZW4gZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVncmVlc1xuICogQHJldHVybiB7TWF0cml4MjN9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gZFNrZXdYTWF0cml4KGRlZ3JlZXMpIHtcbmlmIChkZWdyZWVzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oZGVncmVlcykgfHwgJ251bWJlcicgIT09IHR5cGVvZiBkZWdyZWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVncmVlcyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuIFsgMSwgMCwgdGFuKGRlZ3JlZXMgKiAwLjAxNzQ1MzI5MjUxOTk0MzI5NTc2OTIzNjkwNzY4NDg4NiksIDEsIDAsIDAgXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgM3gyIDJEIGNvbHVtbi1tYWpvciB5LXNrZXcgbWF0cml4IGZvciB0aGUgZ2l2ZW4gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaWFuc1xuICogQHJldHVybiB7TWF0cml4MjN9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gc2tld1hNYXRyaXgocmFkaWFucykge1xuaWYgKHJhZGlhbnMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyYWRpYW5zKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGlhbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpYW5zIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gWyAxLCAwLCB0YW4ocmFkaWFucyksIDEsIDAsIDAgXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgM3gyIDJEIGNvbHVtbi1tYWpvciB5LXNrZXcgbWF0cml4IGZvciB0aGUgZ2l2ZW4gZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVncmVlc1xuICogQHJldHVybiB7TWF0cml4MjN9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gZFNrZXdZTWF0cml4KGRlZ3JlZXMpIHtcbmlmIChkZWdyZWVzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oZGVncmVlcykgfHwgJ251bWJlcicgIT09IHR5cGVvZiBkZWdyZWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVncmVlcyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuIFsgMSwgdGFuKGRlZ3JlZXMgKiAwLjAxNzQ1MzI5MjUxOTk0MzI5NTc2OTIzNjkwNzY4NDg4NiksIDAsIDEsIDAsIDAgXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgM3gyIDJEIGNvbHVtbi1tYWpvciB5LXNrZXcgbWF0cml4IGZvciB0aGUgZ2l2ZW4gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaWFuc1xuICogQHJldHVybiB7TWF0cml4MjN9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gc2tld1lNYXRyaXgocmFkaWFucykge1xuaWYgKHJhZGlhbnMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyYWRpYW5zKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGlhbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpYW5zIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gWyAxLCB0YW4ocmFkaWFucyksIDAsIDEsIDAsIDAgXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgM3gyIDJEIGNvbHVtbi1tYWpvciB5LXNrZXcgbWF0cml4IGZvciB0aGUgZ2l2ZW4gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaWFuc1xuICogQHJldHVybiB7TWF0cml4MjN9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gcm90YXRpb25NYXRyaXgocmFkaWFucykge1xuaWYgKHJhZGlhbnMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyYWRpYW5zKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGlhbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpYW5zIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICB2YXIgYyA9IGNvcyhyYWRpYW5zKSxcbiAgICAgICAgcyA9IHNpbihyYWRpYW5zKTtcblxuICAgIHJldHVybiBbYywgLXMsIHMsIGMsIDAsIDAgXTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgYSAzeDIgMkQgY29sdW1uLW1ham9yIHNjYWxpbmcgbWF0cml4IGZvciB4IGFuZCB5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICovXG5mdW5jdGlvbiBzY2FsaW5nTWF0cml4KHgsIHkpIHtcbmlmICh4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiBbIHgsIDAsIDAsIHksIDAsIDAgXTtcbn1cblxuXG4vKipcbiAqIEludGVycG9sYXRlIHR3byBtYXRyaXhlcyBieSBnaXZlbiBmYWN0b3IuXG4gKiBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGggVHJhbnNpdGlvbnMgYW5kIHlvdSB3aWxsIGhhdmUgbmljZSB0cmFuc2Zvcm1hdGlvbnMgOilcbiAqXG4gKiBAcGFyYW0ge01hdHJpeDIzfSBvdXRcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZCBmaXJzdCBtYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4MjN9IG0yZF8yIHNlY29uZCBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAqIEByZXR1cm4ge01hdHJpeDIzfVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShvdXQsIG0yZCwgbTJkXzIsIGZhY3Rvcikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXSB8fCBvdXRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdIHx8IG91dFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMl0gfHwgb3V0WzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFszXSB8fCBvdXRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzRdIHx8IG91dFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShtMmRfMikgfHwgbTJkXzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRfMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRfMlswXSB8fCBtMmRfMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZF8yWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZF8yWzFdIHx8IG0yZF8yWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkXzJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkXzJbMl0gfHwgbTJkXzJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRfMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRfMlszXSB8fCBtMmRfMls0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZF8yWzRdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZF8yWzRdIHx8IG0yZF8yWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkXzJbNV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkXzJbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG0yZF8yXCIpXG59XG5cbmlmIChmYWN0b3IgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihmYWN0b3IpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgZmFjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmFjdG9yIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBvdXRbMF0gPSBtMmRbMF0gKyAoKG0yZF8yWzBdIC0gbTJkWzBdKSAqIGZhY3Rvcik7XG4gICAgb3V0WzFdID0gbTJkWzFdICsgKChtMmRfMlsxXSAtIG0yZFsxXSkgKiBmYWN0b3IpO1xuICAgIG91dFsyXSA9IG0yZFsyXSArICgobTJkXzJbMl0gLSBtMmRbMl0pICogZmFjdG9yKTtcbiAgICBvdXRbM10gPSBtMmRbM10gKyAoKG0yZF8yWzNdIC0gbTJkWzNdKSAqIGZhY3Rvcik7XG4gICAgb3V0WzRdID0gbTJkWzRdICsgKChtMmRfMls0XSAtIG0yZFs0XSkgKiBmYWN0b3IpO1xuICAgIG91dFs1XSA9IG0yZFs1XSArICgobTJkXzJbNV0gLSBtMmRbNV0pICogZmFjdG9yKTtcblxuICAgIHZhciBvID0gb3V0WzZdLFxuICAgICAgICBpMSA9IG0yZFs2XSxcbiAgICAgICAgaTIgPSBtMmRfMls2XTtcblxuICAgIG9bMF0gPSBpMVswXSArICgoaTJbMF0gLSBpMVswXSkgKiBmYWN0b3IpO1xuICAgIG9bMV0gPSBpMVsxXSArICgoaTJbMV0gLSBpMVsxXSkgKiBmYWN0b3IpO1xuICAgIG9bMl0gPSBpMVsyXSArICgoaTJbMl0gLSBpMVsyXSkgKiBmYWN0b3IpO1xuICAgIG9bM10gPSBpMVszXSArICgoaTJbM10gLSBpMVszXSkgKiBmYWN0b3IpO1xuICAgIG9bNF0gPSBpMVs0XSArICgoaTJbNF0gLSBpMVs0XSkgKiBmYWN0b3IpO1xuXG4gICAgb3V0WzddID0gbTJkWzddO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBGb3IgY29tcGxldGVuZXNzIGJlY2F1c2UgaXQncyBub3QgbmVlZCBpbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBqdXN0IGdldDogbTJkWzZdWzRdXG4gKlxuICogQHBhcmFtIHtNYXRyaXgyM30gbTJkXG4gKi9cbmZ1bmN0aW9uIHRvQW5nbGUobTJkKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbiAgICByZXR1cm4gYXRhbjIobTJkWzFdLCBtMmRbMF0pO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYSB2ZWN0b3IgYnkgZ2l2ZW4gbWF0cml4XG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtNYXRyaXgyM30gbTJkXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShvdXRfdmVjMiwgbTJkLCB2ZWMyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkobTJkKSB8fCBtMmRbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzBdIHx8IG0yZFsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMV0gfHwgbTJkWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzJdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFsyXSB8fCBtMmRbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbM10pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzNdIHx8IG0yZFs0XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs0XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNF0gfHwgbTJkWzVdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzVdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFs1XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTWF0cml4MjMgbTJkXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgdmFyIHggPSB2ZWMyWzBdICogbTJkWzBdICsgdmVjMlsxXSAqIG0yZFsyXSArIG0yZFs0XSxcbiAgICAgICAgeSA9IHZlYzJbMF0gKiBtMmRbMV0gKyB2ZWMyWzFdICogbTJkWzNdICsgbTJkWzVdO1xuXG4gICAgb3V0X3ZlYzJbMF0gPSB4O1xuICAgIG91dF92ZWMyWzFdID0geTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cblxuXG52YXIgTWF0cml4MjMgPSAge1xuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGZyb21Qb2ludHM6IGZyb21Qb2ludHMsXG4gICAgY29weTogY29weSxcbiAgICBpZGVudGl0eTogaWRlbnRpdHksXG4gICAgZFJvdGF0ZTogZFJvdGF0ZSxcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICBkUm90YXRpb246IGRSb3RhdGlvbixcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXG4gICAgZ1RyYW5zbGF0ZTogZ1RyYW5zbGF0ZSxcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHNjYWxhdGlvbjogc2NhbGF0aW9uLFxuICAgIGRTa2V3WDogZFNrZXdYLFxuICAgIHNrZXdYOiBza2V3WCxcbiAgICBkU2tld1k6IGRTa2V3WSxcbiAgICBza2V3WTogc2tld1ksXG4gICAgZFNrZXc6IGRTa2V3LFxuICAgIHNrZXc6IHNrZXcsXG4gICAgZFNldFNrZXc6IGRTZXRTa2V3LFxuICAgIHNldFNrZXc6IHNldFNrZXcsXG4gICAgbXVsdGlwbHk6IG11bHRpcGx5LFxuICAgIG11bHRpcGx5VmVjMjogbXVsdGlwbHlWZWMyLFxuICAgIGdldFBvc2l0aW9uOiBnZXRQb3NpdGlvbixcbiAgICBnZXRTY2FsZTogZ2V0U2NhbGUsXG4gICAgZ2V0U2tldzogZ2V0U2tldyxcbiAgICByZWZsZWN0OiByZWZsZWN0LFxuICAgIHRyYW5zcG9zZTogdHJhbnNwb3NlLFxuICAgIGRldGVybWluYW50OiBkZXRlcm1pbmFudCxcbiAgICB0cmFuc2xhdGlvbk1hdHJpeDogdHJhbnNsYXRpb25NYXRyaXgsXG4gICAgZFNrZXdYTWF0cml4OiBkU2tld1hNYXRyaXgsXG4gICAgc2tld1hNYXRyaXg6IHNrZXdYTWF0cml4LFxuICAgIGRTa2V3WU1hdHJpeDogZFNrZXdZTWF0cml4LFxuICAgIHNrZXdZTWF0cml4OiBza2V3WU1hdHJpeCxcbiAgICBzY2FsaW5nTWF0cml4OiBzY2FsaW5nTWF0cml4LFxuICAgIHJvdGF0aW9uTWF0cml4OiByb3RhdGlvbk1hdHJpeCxcblxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcblxuICAgIHRvQW5nbGU6IHRvQW5nbGUsXG5cbiAgICAvLyBhbGlhc1xuICAgIGRTZXRSb3RhdGlvbjogZFJvdGF0aW9uLFxuICAgIHNldFJvdGF0aW9uOiByb3RhdGlvbixcbiAgICBzZXRQb3NpdGlvbjogcG9zaXRpb24sXG4gICAgc2V0U2NhbGU6IHNjYWxhdGlvbixcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4MjM7XG4iLCIvKipcbiAqIFN0YWJpbGl0eTogMiAoZml4ZXMgLyBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMpXG4gKiB+UXVhZHRyZWUgaW1wbGVtZW50YXRpb24gdGhhdCBhbGxvdyB0byBvdmVycmlkZSB0aGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9uIGZvciB0aGUgZmlyc3QgbGV2ZWxcbiAqIFRoaXMgaXMgc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmVjdGFuZ3VsYXIgd29ybGRzXG4gKlxuICogQHJlZmVyZW5jZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1YWR0cmVlXG4gKi9cblxudmFyIEFBQkIyID0gcmVxdWlyZShcIi4vYWFiYjIuanNcIiksXG4gICAgQUFCQjJfZnJvbUFBQkIyRGl2aXNpb24gPSBBQUJCMi5mcm9tQUFCQjJEaXZpc2lvbixcbiAgICBBQUJCMl9jb250YWlucyA9IEFBQkIyLmNvbnRhaW5zO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FBQkIyfSBhYWJiMlxuICogQHBhcmFtIHtOdW1iZXI9fSBtYXhPYmplY3RzXG4gKiBAcGFyYW0ge051bWJlcj19IG1heExldmVsc1xuICogQHBhcmFtIHtWZWMyPX0gc3ViZGl2aXNpb25zXG4gKi9cbmZ1bmN0aW9uIE5NdHJlZShhYWJiMiwgbWF4T2JqZWN0cywgbWF4TGV2ZWxzLCBzdWJkaXZpc2lvbnMpIHtcbmlmICghQXJyYXkuaXNBcnJheShhYWJiMikgfHwgYWFiYjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlswXSB8fCBhYWJiMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzFdIHx8IGFhYmIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMl0gfHwgYWFiYjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJcIilcbn1cblxuaWYgKG1heE9iamVjdHMgIT09IHVuZGVmaW5lZCkge1xuaWYgKG1heE9iamVjdHMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtYXhPYmplY3RzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG1heE9iamVjdHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhPYmplY3RzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbn1cbmlmIChtYXhMZXZlbHMgIT09IHVuZGVmaW5lZCkge1xuaWYgKG1heExldmVscyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1heExldmVscykgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtYXhMZXZlbHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhMZXZlbHMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxufVxuaWYgKHN1YmRpdmlzaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkoc3ViZGl2aXNpb25zKSB8fCBzdWJkaXZpc2lvbnNbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihzdWJkaXZpc2lvbnNbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygc3ViZGl2aXNpb25zWzBdIHx8IHN1YmRpdmlzaW9uc1sxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHN1YmRpdmlzaW9uc1sxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBzdWJkaXZpc2lvbnNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgc3ViZGl2aXNpb25zXCIpXG59XG5cbn1cbiAgICB0aGlzLm9iamVjdHMgPSBbXTtcbiAgICB0aGlzLmJvdW5kcyA9IGFhYmIyO1xuICAgIHRoaXMubWF4T2JqZWN0cyA9IG1heE9iamVjdHMgfHwgMTA7XG4gICAgdGhpcy5tYXhMZXZlbHMgPSBtYXhMZXZlbHMgfHwgNDtcbiAgICB0aGlzLnN1YmRpdmlzaW9ucyA9IHN1YmRpdmlzaW9ucyB8fCBbMiwgMl07XG59XG5cbk5NdHJlZS5wcm90b3R5cGUubGV2ZWwgPSAwO1xuTk10cmVlLnByb3RvdHlwZS5tYXhMZXZlbHMgPSA0O1xuTk10cmVlLnByb3RvdHlwZS5tYXhPYmplY3RzID0gMTA7XG5OTXRyZWUucHJvdG90eXBlLnN1YnRyZWVzID0gbnVsbDtcbk5NdHJlZS5wcm90b3R5cGUuYm91bmRzID0gbnVsbDtcbk5NdHJlZS5wcm90b3R5cGUub2JqZWN0cyA9IFtdO1xuTk10cmVlLnByb3RvdHlwZS5zdWJkaXZpc2lvbnMgPSBbMiwgMl07XG5cbk5NdHJlZS5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmpzID0gdGhpcy5vYmplY3RzLFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICBtYXgsXG4gICAgICAgIGJvdW5kcyA9IEFBQkIyX2Zyb21BQUJCMkRpdmlzaW9uKHRoaXMuYm91bmRzLCB0aGlzLnN1YmRpdmlzaW9uc1swXSwgdGhpcy5zdWJkaXZpc2lvbnNbMV0pLFxuICAgICAgICBxdDtcblxuICAgIHRoaXMuc3VidHJlZXMgPSBbXTtcbiAgICB0aGlzLm9iamVjdHMgPSBbXTtcblxuICAgIGZvciAoaiA9IDAsIG1heCA9IGJvdW5kcy5sZW5ndGg7IGogPCBtYXg7IGorKykge1xuICAgICAgICBxdCA9IG5ldyBOTXRyZWUoYm91bmRzW2pdKSwvLyB0aGlzLm1heE9iamVjdHMsIHRoaXMubWF4TGV2ZWxzKTtcblxuICAgICAgICBxdC5sZXZlbCA9IHRoaXMubGV2ZWwgKyAxOyAvLyBtYW51YWxseSBzZXRcbiAgICAgICAgdGhpcy5zdWJ0cmVlcy5wdXNoKHF0KTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgbWF4ID0gb2Jqcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuc3ViaW5zZXJ0KG9ianNbaV0pKSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChvYmpzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKi9cbk5NdHJlZS5wcm90b3R5cGUuc3ViaW5zZXJ0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghdGhpcy5zdWJ0cmVlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGogPSAwLFxuICAgICAgICBtYXggPSB0aGlzLnN1YnRyZWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaiA8IG1heCAmJiAhdGhpcy5zdWJ0cmVlc1tqXS5pbnNlcnQob2JqLmJvdW5kcywgb2JqLnVzZXJkYXRhKSkge1xuICAgICAgICArK2o7XG4gICAgfVxuXG4gICAgcmV0dXJuIGogIT09IG1heDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBQUJCMn0gYWFiYjJcbiAqIEBwYXJhbSB7TWl4ZWR9IHVzZXJkYXRhXG4gKi9cbk5NdHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGFhYmIyLCB1c2VyZGF0YSkge1xuICAgIGlmIChBQUJCMl9jb250YWlucyh0aGlzLmJvdW5kcywgYWFiYjIpKSB7XG4gICAgICAgIHZhciBvYmogPSB7Ym91bmRzOiBhYWJiMiwgdXNlcmRhdGE6IHVzZXJkYXRhfTtcblxuICAgICAgICBpZiAoIXRoaXMuc3ViaW5zZXJ0KG9iaikpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdWJ0cmVlcyAmJiB0aGlzLm9iamVjdHMubGVuZ3RoID09PSB0aGlzLm1heE9iamVjdHMgJiYgdGhpcy5sZXZlbCA8IHRoaXMubWF4TGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXZpZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJpbnNlcnQob2JqKSkgeyAvL3JldHJ5XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNaXhlZH0gdXNlcmRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG91dFxuICovXG5OTXRyZWUucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24gKHVzZXJkYXRhLCBvdXQpIHtcbiAgICBvdXQgPSBvdXQgfHwgW107XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbWF4LFxuICAgICAgICBvYmpzID0gdGhpcy5vYmplY3RzLFxuICAgICAgICBmb3VuZDtcblxuICAgIGlmIChvYmpzICYmIG9ianMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG1heCA9IG9ianMubGVuZ3RoOyBpIDwgbWF4ICYmICFmb3VuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob2Jqc1tpXS51c2VyZGF0YSA9PT0gdXNlcmRhdGEpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRlKGZ1bmN0aW9uIChxdCkge1xuICAgICAgICAgICAgaWYgKHF0Lm9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgbWF4O1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIG1heCA9IHF0Lm9iamVjdHMubGVuZ3RoOyBpIDwgbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2gocXQub2JqZWN0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdWJ0cmVlcykge1xuICAgICAgICBmb3IgKGkgPSAwLCBtYXggPSB0aGlzLnN1YnRyZWVzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnRyZWVzW2ldLnJldHJpZXZlKHVzZXJkYXRhLCBvdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuTk10cmVlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG1heDtcblxuICAgIGNhbGxiYWNrKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuc3VidHJlZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbWF4ID0gdGhpcy5zdWJ0cmVlcy5sZW5ndGg7IGkgPCBtYXg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5zdWJ0cmVlc1tpXS5pdGVyYXRlKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtNaXhlZH0gdXNlcmRhdGFcbiAqL1xuTk10cmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodXNlcmRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbWF4LFxuICAgICAgICBvYmpzID0gdGhpcy5vYmplY3RzLFxuICAgICAgICBmb3VuZDtcblxuICAgIGlmIChvYmpzICYmIG9ianMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG1heCA9IG9ianMubGVuZ3RoOyBpIDwgbWF4ICYmICFmb3VuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob2Jqc1tpXS51c2VyZGF0YSA9PT0gdXNlcmRhdGEpIHtcbiAgICAgICAgICAgICAgICBvYmpzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN1YnRyZWVzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG1heCA9IHRoaXMuc3VidHJlZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YnRyZWVzW2ldLnJlbW92ZSh1c2VyZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5NdHJlZTsiLCJ2YXIgb2JqZWN0ID0gcmVxdWlyZShcIm9iamVjdC1lbmhhbmNlbWVudHNcIiksXG4gICAgWG9yc2hpZnQgPSByZXF1aXJlKFwiLi94b3JzaGlmdC5qc1wiKSxcbiAgICBHUkFEMyA9IFtcbiAgICAgICAgWzEsIDEsIDBdLCBbLTEsIDEsIDBdLCBbMSwgLTEsIDBdLCBbLTEsIC0xLCAwXSxcbiAgICAgICAgWzEsIDAsIDFdLCBbLTEsIDAsIDFdLCBbMSwgMCwgLTFdLCBbLTEsIDAsIC0xXSxcbiAgICAgICAgWzAsIDEsIDFdLCBbMCwgLTEsIDFdLCBbMCwgMSwgLTFdLCBbMCwgLTEsIC0xXVxuICAgIF0sXG5cbiAgICBHUkFENCA9IFtcbiAgICAgICAgWzAsIDEsIDEsIDFdLCAgWzAsIDEsIDEsIC0xXSwgIFswLCAxLCAtMSwgMV0sICBbMCwgMSwgLTEsIC0xXSxcbiAgICAgICAgWzAsIC0xLCAxLCAxXSwgWzAsIC0xLCAxLCAtMV0sIFswLCAtMSwgLTEsIDFdLCBbMCwgLTEsIC0xLCAtMV0sXG4gICAgICAgIFsxLCAwLCAxLCAxXSwgIFsxLCAwLCAxLCAtMV0sICBbMSwgMCwgLTEsIDFdLCAgWzEsIDAsIC0xLCAtMV0sXG4gICAgICAgIFstMSwgMCwgMSwgMV0sIFstMSwgMCwgMSwgLTFdLCBbLTEsIDAsIC0xLCAxXSwgWy0xLCAwLCAtMSwgLTFdLFxuICAgICAgICBbMSwgMSwgMCwgMV0sICBbMSwgMSwgMCwgLTFdLCAgWzEsIC0xLCAwLCAxXSwgIFsxLCAtMSwgMCwgLTFdLFxuICAgICAgICBbLTEsIDEsIDAsIDFdLCBbLTEsIDEsIDAsIC0xXSwgWy0xLCAtMSwgMCwgMV0sIFstMSwgLTEsIDAsIC0xXSxcbiAgICAgICAgWzEsIDEsIDEsIDBdLCAgWzEsIDEsIC0xLCAwXSwgIFsxLCAtMSwgMSwgMF0sICBbMSwgLTEsIC0xLCAwXSxcbiAgICAgICAgWy0xLCAxLCAxLCAwXSwgWy0xLCAxLCAtMSwgMF0sIFstMSwgLTEsIDEsIDBdLCBbLTEsIC0xLCAtMSwgMF1cbiAgICBdLFxuXG4gICAgU0lNUExFWCA9IFtcbiAgICAgICAgWzAsIDEsIDIsIDNdLCBbMCwgMSwgMywgMl0sIFswLCAwLCAwLCAwXSwgWzAsIDIsIDMsIDFdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMSwgMiwgMywgMF0sXG4gICAgICAgIFswLCAyLCAxLCAzXSwgWzAsIDAsIDAsIDBdLCBbMCwgMywgMSwgMl0sIFswLCAzLCAyLCAxXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzEsIDMsIDIsIDBdLFxuICAgICAgICBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSxcbiAgICAgICAgWzEsIDIsIDAsIDNdLCBbMCwgMCwgMCwgMF0sIFsxLCAzLCAwLCAyXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzIsIDMsIDAsIDFdLCBbMiwgMywgMSwgMF0sXG4gICAgICAgIFsxLCAwLCAyLCAzXSwgWzEsIDAsIDMsIDJdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMiwgMCwgMywgMV0sIFswLCAwLCAwLCAwXSwgWzIsIDEsIDMsIDBdLFxuICAgICAgICBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSxcbiAgICAgICAgWzIsIDAsIDEsIDNdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMywgMCwgMSwgMl0sIFszLCAwLCAyLCAxXSwgWzAsIDAsIDAsIDBdLCBbMywgMSwgMiwgMF0sXG4gICAgICAgIFsyLCAxLCAwLCAzXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzMsIDEsIDAsIDJdLCBbMCwgMCwgMCwgMF0sIFszLCAyLCAwLCAxXSwgWzMsIDIsIDEsIDBdXG4gICAgXSxcbiAgICBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICByYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICBzcXJ0X29mXzMgPSBzcXJ0KDMpLFxuXG4gICAgTm9pc2UgPSB7fTtcblxuLy8gZnJvbTogaHR0cDovL2pzZG8uaXQvYWttMi9maE1DL2pzXG4vLyBkb24ndCBrbm93IHRoZSBhdXRob3IsIGlmIHlvdSBhcmUgY29udGFjdCBtZS5cbi8vIEkganVzdCBsaW50IHRoZSBjb2RlIChhIGxpdHRsZSkuLi4gYW5kIGFkYXB0IGl0IHRvIHRoZSBsaWIgcGhpbG9zb3BoeSAodGhhdCBtZWFucyByZW1vdmUgM2Qgbm9pc2VzKVxuXG4vL0BUT0RPIG9wdGltaXplLCB0aGVyZSBpcyBwZXJmb3JtYW5jZSBnYWluIGV2ZXJ5d2hlcmUhXG5cblxuLy8gQ29tbW9uIGhlbHBlcnNcblxuZnVuY3Rpb24gX2RvdDJkKGcsIHgsIHkpIHtcbiAgICByZXR1cm4gZ1swXSAqIHggKyBnWzFdICogeTtcbn1cblxuZnVuY3Rpb24gX2RvdDNkKGcsIHgsIHksIHopIHtcbiAgICByZXR1cm4gZ1swXSAqIHggKyBnWzFdICogeSArIGdbMl0gKiB6O1xufVxuXG4vLyBTaW1wbGV4IGhlbHBlclxuXG5mdW5jdGlvbiBfZG90NGQoZywgeCwgeSwgeiwgdykge1xuICAgIHJldHVybiBnWzBdICogeCArIGdbMV0gKiB5ICsgZ1syXSAqIHogKyBnWzNdICogdztcbn1cblxuLy8gQ2xhc3NpYyBoZWxwZXJzXG5cbmZ1bmN0aW9uIF9taXgoYSwgYiwgdCkge1xuICAgIHJldHVybiAoMSAtIHQpICogYSArIHQgKiBiO1xufVxuXG5mdW5jdGlvbiBfZmFkZSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2IC0gMTUpICsgMTApO1xufVxuXG5cblxuLypcbiAqIEByZWZlcmVuY2UgaHR0cDovL3N0YWZmd3d3Lml0bi5saXUuc2UvfnN0ZWd1L3NpbXBsZXhub2lzZS9zaW1wbGV4bm9pc2UucGRmXG4gKlxuICogVGlsaW5nIEV4YW1wbGUgKGhlYXZ5Li4uKVxuICpcbiAqIHZhciBwZXJsaW5Ob2lzZSA9IG5ldyBQZXJsaW5Ob2lzZSgpO1xuICpcbiAqIGZ1bmN0aW9uIHRpbGluZ05vaXNlMmQoeCwgeSwgdywgaCkge1xuICogICAgIHJldHVybiAocGVybGluTm9pc2Uubm9pc2UoeCwgeSkgKiAodyAtIHgpICogKGggLSB5KSArXG4gKiAgICAgICAgIHBlcmxpbk5vaXNlLm5vaXNlKHggLSB3LCB5KSAqIHggKiAoaCAtIHkpICtcbiAqICAgICAgICAgcGVybGluTm9pc2Uubm9pc2UoeCAtIHcsIHkgLSBoKSAqIHggKiB5ICtcbiAqICAgICAgICAgcGVybGluTm9pc2Uubm9pc2UoeCwgeSAtIGgpICogKHcgLSB4KSAqIHkpIC8gKHcgKiBoKTtcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzIENsYXNzaWNOb2lzZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNlZWRcbiAqL1xuZnVuY3Rpb24gQ2xhc3NpY05vaXNlKHNlZWQpIHtcbmlmIChzZWVkID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oc2VlZCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBzZWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic2VlZCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgdGhpcy5zZWVkKHNlZWQpO1xufVxuXG5DbGFzc2ljTm9pc2UucHJvdG90eXBlID0ge1xuICAgIF9vY3RhdmVzOiA0LFxuICAgIF9mYWxsb3V0OiAwLjUsXG5cbiAgICBzZWVkOiBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICB2YXIgcmFuZG9tID0gWG9yc2hpZnQuY3JlYXRlKHNlZWQgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCkpLnJhbmRvbSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwID0gW10sXG4gICAgICAgICAgICBwZXJtID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBwW2ldID0gZmxvb3IocmFuZG9tKCkgKiAyNTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDUxMjsgaSsrKSB7XG4gICAgICAgICAgICBwZXJtW2ldID0gcFtpICYgMjU1XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Blcm0gPSBwZXJtO1xuICAgIH0sXG5cbiAgICBvY3RhdmVzOiBmdW5jdGlvbiAob2N0YXZlcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vY3RhdmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vY3RhdmVzID0gb2N0YXZlcztcbiAgICB9LFxuXG4gICAgZmFsbG91dDogZnVuY3Rpb24gKGZhbGxvdXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFsbG91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmFsbG91dCA9IGZhbGxvdXQ7XG4gICAgfSxcblxuICAgIG5vaXNlOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICAgIG5vaXNlLFxuICAgICAgICAgICAgZiA9IDEsXG4gICAgICAgICAgICBvY3QgPSB0aGlzLl9vY3RhdmVzLFxuICAgICAgICAgICAgYW1wID0gMC41LFxuICAgICAgICAgICAgZmFsbG91dCA9IHRoaXMuX2ZhbGxvdXQsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvY3Q7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgxICsgdGhpcy5ub2lzZTJkKHggKiBmLCB5ICogZikpICogYW1wICogMC41O1xuICAgICAgICAgICAgYW1wICo9IGZhbGxvdXQ7XG4gICAgICAgICAgICBmICo9IDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBub2lzZTJkOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgWCA9IGZsb29yKHgpLFxuICAgICAgICAgICAgWSA9IGZsb29yKHkpLFxuICAgICAgICAgICAgcGVybSA9IHRoaXMuX3Blcm07XG5cbiAgICAgICAgeCA9IHggLSBYO1xuICAgICAgICB5ID0geSAtIFk7XG5cbiAgICAgICAgWCA9IFggJiAyNTU7XG4gICAgICAgIFkgPSBZICYgMjU1O1xuXG5cbiAgICAgICAgdmFyIGdpMDAgPSBwZXJtW1ggKyBwZXJtW1ldXSAlIDEyLFxuICAgICAgICAgICAgZ2kwMSA9IHBlcm1bWCArIHBlcm1bWSArIDFdXSAlIDEyLFxuICAgICAgICAgICAgZ2kxMCA9IHBlcm1bWCArIDEgKyBwZXJtW1ldXSAlIDEyLFxuICAgICAgICAgICAgZ2kxMSA9IHBlcm1bWCArIDEgKyBwZXJtW1kgKyAxXV0gJSAxMixcblxuICAgICAgICAgICAgbjAwID0gX2RvdDJkKEdSQUQzW2dpMDBdLCB4LCB5KSxcbiAgICAgICAgICAgIG4xMCA9IF9kb3QyZChHUkFEM1tnaTEwXSwgeCAtIDEsIHkpLFxuICAgICAgICAgICAgbjAxID0gX2RvdDJkKEdSQUQzW2dpMDFdLCB4LCB5IC0gMSksXG4gICAgICAgICAgICBuMTEgPSBfZG90MmQoR1JBRDNbZ2kxMV0sIHggLSAxLCB5IC0gMSksXG5cbiAgICAgICAgICAgIHUgPSBfZmFkZSh4KSxcbiAgICAgICAgICAgIHYgPSBfZmFkZSh5KSxcblxuICAgICAgICAgICAgbngwID0gX21peChuMDAsIG4xMCwgdSksXG4gICAgICAgICAgICBueDEgPSBfbWl4KG4wMSwgbjExLCB1KSxcblxuICAgICAgICAgICAgbnh5ID0gX21peChueDAsIG54MSwgdik7XG5cbiAgICAgICAgcmV0dXJuIG54eTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogU2ltcGxleE5vaXNlXG4gKlxuICogQHN1cGVyIENsYXNzaWNOb2lzZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNlZWRcbiAqL1xuZnVuY3Rpb24gU2ltcGxleE5vaXNlKHNlZWQpIHtcbmlmIChzZWVkID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oc2VlZCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBzZWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic2VlZCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgdGhpcy5zZWVkKHNlZWQpO1xufVxuXG5TaW1wbGV4Tm9pc2UucHJvdG90eXBlID0gb2JqZWN0LmV4dGVuZCh7fSwgQ2xhc3NpY05vaXNlLnByb3RvdHlwZSwge1xuICAgIG5vaXNlOiBmdW5jdGlvbiAoeCwgeSwgeiwgdykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICAgIG5vaXNlLFxuICAgICAgICAgICAgZiA9IDEsXG4gICAgICAgICAgICBvY3QgPSB0aGlzLl9vY3RhdmVzLFxuICAgICAgICAgICAgYW1wID0gMC41LFxuICAgICAgICAgICAgZmFsbG91dCA9IHRoaXMuX2ZhbGxvdXQsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvY3Q7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgxICsgdGhpcy5ub2lzZTJkKHggKiBmLCB5ICogZikpICogYW1wICogMC41O1xuICAgICAgICAgICAgYW1wICo9IGZhbGxvdXQ7XG4gICAgICAgICAgICBmICo9IDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBub2lzZTJkOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgbjAsXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuXG4gICAgICAgICAgICBGMiA9IDAuNSAqIChzcXJ0X29mXzMgLSAxKSxcbiAgICAgICAgICAgIHMgPSAoeCArIHkpICogRjIsXG4gICAgICAgICAgICBpID0gZmxvb3IoeCArIHMpLFxuICAgICAgICAgICAgaiA9IGZsb29yKHkgKyBzKSxcblxuICAgICAgICAgICAgRzIgPSAoMyAtIHNxcnRfb2ZfMykgLyA2LFxuICAgICAgICAgICAgdCA9IChpICsgaikgKiBHMixcbiAgICAgICAgICAgIFgwID0gaSAtIHQsXG4gICAgICAgICAgICBZMCA9IGogLSB0LFxuICAgICAgICAgICAgeDAgPSB4IC0gWDAsXG4gICAgICAgICAgICB5MCA9IHkgLSBZMCxcblxuICAgICAgICAgICAgaTEsXG4gICAgICAgICAgICBqMSxcblxuICAgICAgICAgICAgcGVybSA9IHRoaXMuX3Blcm07XG5cbiAgICAgICAgaWYgKHgwID4geTApIHtcbiAgICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICAgIGoxID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICAgIGoxID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MSA9IHgwIC0gaTEgKyBHMixcbiAgICAgICAgICAgIHkxID0geTAgLSBqMSArIEcyLFxuXG4gICAgICAgICAgICB4MiA9IHgwIC0gMSArIDIgKiBHMixcbiAgICAgICAgICAgIHkyID0geTAgLSAxICsgMiAqIEcyLFxuXG4gICAgICAgICAgICBpaSA9IGkgJiAyNTUsXG4gICAgICAgICAgICBqaiA9IGogJiAyNTUsXG5cbiAgICAgICAgICAgIGdpMCA9IHBlcm1baWkgKyBwZXJtW2pqXV0gJSAxMixcbiAgICAgICAgICAgIGdpMSA9IHBlcm1baWkgKyBpMSArIHBlcm1bamogKyBqMV1dICUgMTIsXG4gICAgICAgICAgICBnaTIgPSBwZXJtW2lpICsgMSArIHBlcm1bamogKyAxXV0gJSAxMixcblxuICAgICAgICAgICAgdDAgPSAwLjUgLSB4MCAqIHgwIC0geTAgKiB5MDtcblxuICAgICAgICBpZiAodDAgPCAwKSB7XG4gICAgICAgICAgICBuMCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0MCAqPSB0MDtcbiAgICAgICAgICAgIG4wID0gdDAgKiB0MCAqIF9kb3QyZChHUkFEM1tnaTBdLCB4MCwgeTApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQxID0gMC41IC0geDEgKiB4MSAtIHkxICogeTE7XG4gICAgICAgIGlmICh0MSA8IDApIHtcbiAgICAgICAgICAgIG4xID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHQxICo9IHQxO1xuICAgICAgICAgICAgbjEgPSB0MSAqIHQxICogX2RvdDJkKEdSQUQzW2dpMV0sIHgxLCB5MSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdDIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MjtcbiAgICAgICAgaWYgKHQyIDwgMCkge1xuICAgICAgICAgICAgbjIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgICAgICBuMiA9IHQyICogdDIgKiBfZG90MmQoR1JBRDNbZ2kyXSwgeDIsIHkyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA3MCAqIChuMCArIG4xICsgbjIpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc2ljKHNlZWQpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzaWNOb2lzZShzZWVkKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2ltcGxlWChzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGV4Tm9pc2Uoc2VlZCk7XG59XG5cbk5vaXNlID0ge1xuICAgIEdSQUQzOiBHUkFEMyxcbiAgICBHUkFENDogR1JBRDQsXG4gICAgU0lNUExFWDogU0lNUExFWCxcblxuICAgIENsYXNzaWNOb2lzZTogQ2xhc3NpY05vaXNlLFxuICAgIFNpbXBsZXhOb2lzZTogU2ltcGxleE5vaXNlLFxuXG4gICAgY3JlYXRlQ2xhc3NpYzogY3JlYXRlQ2xhc3NpYyxcbiAgICBjcmVhdGVTaW1wbGVYOiBjcmVhdGVTaW1wbGVYXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vaXNlOyIsInZhciBWZWMyID0gcmVxdWlyZShcIi4uL3ZlYzIuanNcIiksXG4gICAgdmVjMl9hZGQgPSBWZWMyLmFkZCxcbiAgICB2ZWMyX3NjYWxlID0gVmVjMi5zY2FsZSxcbiAgICBhdXggPSBbMCwgMF07XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gcG9zaXRpb25cbiAqIEBwYXJhbSB7VmVjMn0gdmVsb2NpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdFxuICovXG5mdW5jdGlvbiBldWxlcihwb3NpdGlvbiwgdmVsb2NpdHksIGR0KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkocG9zaXRpb24pIHx8IHBvc2l0aW9uWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocG9zaXRpb25bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcG9zaXRpb25bMF0gfHwgcG9zaXRpb25bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihwb3NpdGlvblsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBwb3NpdGlvblsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBwb3NpdGlvblwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVsb2NpdHkpIHx8IHZlbG9jaXR5WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVsb2NpdHlbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVsb2NpdHlbMF0gfHwgdmVsb2NpdHlbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWxvY2l0eVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWxvY2l0eVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWxvY2l0eVwiKVxufVxuXG5pZiAoZHQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihkdCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBkdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImR0IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICB2ZWMyX2FkZChwb3NpdGlvbiwgcG9zaXRpb24sIHZlYzJfc2NhbGUoYXV4LCB2ZWxvY2l0eSwgZHQpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBldWxlcjtcbiIsIi8qKlxuICogUnVuZ2XigJNLdXR0YSA0XG4gKlxuICogQHJlZmVyZW5jZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1J1bmdlJUUyJTgwJTkzS3V0dGFfbWV0aG9kc1xuICogQHJlZmVyZW5jZSBodHRwOi8vd3d3LmdhZmZlci5vcmcvYXJ0aWNsZXNcbiAqIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL3dlbGxjYWZmZWluYXRlZC9QaHlzaWNzSlMvYmxvYi9tYXN0ZXIvc3JjL2ludGVncmF0b3JzL3ZlcmxldC5qc1xuICogQHNvdXJjZSBodHRwOi8vbXRkZXZhbnMuY29tLzIwMTMvMDUvZm91cnRoLW9yZGVyLXJ1bmdlLWt1dHRhLWFsZ29yaXRobS1pbi1qYXZhc2NyaXB0LXdpdGgtZGVtby9cbiAqIEBzb3VyY2UgaHR0cDovL2Rvc3dhLmNvbS8yMDA5LzAxLzAyL2ZvdXJ0aC1vcmRlci1ydW5nZS1rdXR0YS1udW1lcmljYWwtaW50ZWdyYXRpb24uaHRtbFxuICovXG5cbnZhciBrID0gMTA7XG52YXIgYiA9IDE7XG5cbi8qKlxuKiBAcGFyYW0ge051bWJlcn0geCBwb3NpdGlvblxuKiBAcGFyYW0ge051bWJlcn0gdiB2ZWxvY2l0eVxuKiBAcGFyYW0ge051bWJlcn0gbmlfbWFzcyBuZWdhdGVkIGludmVyc2Ugb2YgbWFzcyAoLTEvbSlcbiogQHBhcmFtIHtOdW1iZXJ9IHN0aWZmbmVzc1xuKiBAcGFyYW0ge051bWJlcn0gZGFtcGluZ1xuKiBAcGFyYW0ge051bWJlcn0gZHRcbiogQHBhcmFtIHtOdW1iZXJ9IGhkdCBkdCAqIDAuNVxuKiBAcGFyYW0ge051bWJlcn0gaWR0IGR0IC8gMC41XG4qIEByZXR1cm4ge0FycmF5fSBbbmV3X3Bvc2l0aW9uLCBuZXdfdmVsb2NpdHldXG4qL1xuZnVuY3Rpb24gcms0KHgsIHYsIG5pX21hc3MsIHN0aWZmbmVzcywgZGFtcGluZywgZHQsIGhkdCwgaWR0KSB7XG5pZiAoeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHYgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChuaV9tYXNzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obmlfbWFzcykgfHwgJ251bWJlcicgIT09IHR5cGVvZiBuaV9tYXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibmlfbWFzcyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoc3RpZmZuZXNzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oc3RpZmZuZXNzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHN0aWZmbmVzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0aWZmbmVzcyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoZGFtcGluZyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGRhbXBpbmcpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgZGFtcGluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRhbXBpbmcgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGR0ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oZHQpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgZHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoaGR0ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oaGR0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGhkdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImhkdCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoaWR0ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oaWR0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGlkdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlkdCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gIC8vIFJldHVybnMgZmluYWwgKHBvc2l0aW9uLCB2ZWxvY2l0eSkgYXJyYXkgYWZ0ZXIgdGltZSBkdCBoYXMgcGFzc2VkLlxuICAvLyAgICAgICAgeDogaW5pdGlhbCBwb3NpdGlvblxuICAvLyAgICAgICAgdjogaW5pdGlhbCB2ZWxvY2l0eVxuICAvLyAgICAgICAgYTogYWNjZWxlcmF0aW9uIGZ1bmN0aW9uIGEoeCx2LGR0KSAobXVzdCBiZSBjYWxsYWJsZSlcbiAgLy8gICAgICAgIGR0OiB0aW1lc3RlcFxuICB2YXIgeDEgPSB4O1xuICB2YXIgdjEgPSB2O1xuICB2YXIgYTEgPSAoc3RpZmZuZXNzICogeDEgKyBkYW1waW5nICogdjEpICogbmlfbWFzcztcblxuICB2YXIgeDIgPSB4ICsgdjEgKiBoZHQ7XG4gIHZhciB2MiA9IHYgKyBhMSAqIGhkdDtcbiAgdmFyIGEyID0gLShzdGlmZm5lc3MgKiB4MiArIGRhbXBpbmcgKiB2MikgKiBuaV9tYXNzO1xuXG4gIHZhciB4MyA9IHggKyB2MiAqIGhkdDtcbiAgdmFyIHYzID0gdiArIGEyICogaGR0O1xuICB2YXIgYTMgPSAoc3RpZmZuZXNzICogeDMgKyBkYW1waW5nICogdjMpICogbmlfbWFzcztcblxuICB2YXIgeDQgPSB4ICsgdjMgKiBkdDtcbiAgdmFyIHY0ID0gdiArIGEzICogZHQ7XG4gIHZhciBhNCA9IChzdGlmZm5lc3MgKiB4NCArIGRhbXBpbmcgKiB2NCkgKiBuaV9tYXNzO1xuXG4gIHZhciB4ZiA9IHggKyBpZHQgKiAodjEgKyAyICogKHYyICsgdjMpICsgdjQpO1xuICB2YXIgdmYgPSB2ICsgaWR0ICogKGExICsgMiAqIChhMiArIGEzKSArIGE0KTtcblxuICByZXR1cm4gW3hmLCB2Zl07XG59XG4vKlxudmFyIHRzID0gMDtcbnZhciBtYXhfdHMgPSA1MDtcbnZhciBkdCA9IDAuMTtcbnZhciBzdGF0ZSA9IFsxMDAsIDBdO1xudmFyIHN0aWZmbmVzcyA9IDE7XG52YXIgZGFtcGluZyA9IDA7XG5cbnZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICB0cys9ZHQ7XG5cbiAgICBzdGF0ZSA9IHJrNChzdGF0ZVswXSwgc3RhdGVbMV0sIC0xLCBzdGlmZm5lc3MsIGRhbXBpbmcsIGR0LCBkdCAqIDAuNSwgZHQgKiAwLjE2NjY2NjY2Nyk7XG5cbiAgICBjb25zb2xlLmxvZyhzdGF0ZVswXS50b0ZpeGVkKDIpLCBzdGF0ZVsxXS50b0ZpeGVkKDIpKTtcbiAgICAvL2NvbnNvbGUubG9nKHN0YXRlMi5wb3NpdGlvbi50b0ZpeGVkKDIpLCBcIiAtIFwiLCBzdGF0ZTIudmVsb2NpdHkudG9GaXhlZCgyKSk7XG4gICAgLy9jb25zb2xlLmxvZygpO1xuXG4gICAgaWYgKHRzID4gbWF4X3RzKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH1cblxufSwgZHQgKiAxMCk7XG4qL1xuXG4vLyBub2RlIGxpYi9pbnRlZ3JhdG9ycy5qcyA+IG91dHB1dC5kYXQgJiYgZ251cGxvdCAtZSBcInNldCB0ZXJtIHBuZzsgc2V0IG91dHB1dCAncHJpbnRtZS5wbmcnOyBzZXQgemVyb2F4aXM7IHBsb3QgJ291dHB1dC5kYXQnIHVzaW5nIDE6MiB3aXRoIGxpbmVzOyBzZXQgdGVybSB4MTFcIiAmJiBmaXJlZm94IHByaW50bWUucG5nXG5cblxubW9kdWxlLmV4cG9ydHMgPSByazQ7IiwidmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vdmVjMi5qc1wiKSxcbiAgICB2ZWMyX3N1YiA9IFZlYzIuc3ViLFxuICAgIHZlYzJfYWRkID0gVmVjMi5hZGQsXG4gICAgdmVjMl9zY2FsZSA9IFZlYzIuc2NhbGUsXG4gICAgYXV4ID0gWzAsIDBdO1xuXG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3Bvc2l0aW9uXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlbG9jaXR5XG4gKiBAcGFyYW0ge1ZlYzJ9IGxhc3RfdmVsb2NpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdFxuICovXG5mdW5jdGlvbiB2ZXJsZXQob3V0X3Bvc2l0aW9uLCB2ZWxvY2l0eSwgbGFzdF92ZWxvY2l0eSwgZHQpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfcG9zaXRpb24pIHx8IG91dF9wb3NpdGlvblswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF9wb3NpdGlvblswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfcG9zaXRpb25bMF0gfHwgb3V0X3Bvc2l0aW9uWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3Bvc2l0aW9uWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF9wb3NpdGlvblsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfcG9zaXRpb25cIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlbG9jaXR5KSB8fCB2ZWxvY2l0eVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlbG9jaXR5WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlbG9jaXR5WzBdIHx8IHZlbG9jaXR5WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVsb2NpdHlbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVsb2NpdHlbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVsb2NpdHlcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGxhc3RfdmVsb2NpdHkpIHx8IGxhc3RfdmVsb2NpdHlbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihsYXN0X3ZlbG9jaXR5WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGxhc3RfdmVsb2NpdHlbMF0gfHwgbGFzdF92ZWxvY2l0eVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGxhc3RfdmVsb2NpdHlbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbGFzdF92ZWxvY2l0eVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBsYXN0X3ZlbG9jaXR5XCIpXG59XG5cbmlmIChkdCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGR0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZHQgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHZlYzJfYWRkKGF1eCwgbGFzdF92ZWxvY2l0eSwgdmVsb2NpdHkpO1xuICAgIHZlYzJfc2NhbGUoYXV4LCBhdXgsIDAuNSAqIGR0KTtcblxuICAgIHJldHVybiB2ZWMyX2FkZChvdXRfcG9zaXRpb24sIG91dF9wb3NpdGlvbiwgYXV4KTtcbn1cblxuXG4vKipcbiAqIG1heWJlIHRoaXMgaW1wbGVtZW50YXRpb24gY291bGQgYmUgYmV0dGVyLCBzb21lIHRlc3QgPyFcbiAqIEBzb3VyY2UgaHR0cDovL2xvbmVzb2NrLm5ldC9hcnRpY2xlL3ZlcmxldC5odG1sXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfcG9zaXRpb25cbiAqIEBwYXJhbSB7VmVjMn0gdmVsb2NpdHlcbiAqIEBwYXJhbSB7VmVjMn0gbGFzdF92ZWxvY2l0eVxuICogQHBhcmFtIHtOdW1iZXJ9IGR0XG4gKiBAcGFyYW0ge051bWJlcn0gbGFzdF9kdFxuICovXG5mdW5jdGlvbiB0Y192ZXJsZXQob3V0X3Bvc2l0aW9uLCB2ZWxvY2l0eSwgbGFzdF92ZWxvY2l0eSwgZHQsIGxhc3RfZHQpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfcG9zaXRpb24pIHx8IG91dF9wb3NpdGlvblswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF9wb3NpdGlvblswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfcG9zaXRpb25bMF0gfHwgb3V0X3Bvc2l0aW9uWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3Bvc2l0aW9uWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF9wb3NpdGlvblsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfcG9zaXRpb25cIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlbG9jaXR5KSB8fCB2ZWxvY2l0eVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlbG9jaXR5WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlbG9jaXR5WzBdIHx8IHZlbG9jaXR5WzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVsb2NpdHlbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVsb2NpdHlbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVsb2NpdHlcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KGxhc3RfdmVsb2NpdHkpIHx8IGxhc3RfdmVsb2NpdHlbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihsYXN0X3ZlbG9jaXR5WzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGxhc3RfdmVsb2NpdHlbMF0gfHwgbGFzdF92ZWxvY2l0eVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGxhc3RfdmVsb2NpdHlbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbGFzdF92ZWxvY2l0eVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBsYXN0X3ZlbG9jaXR5XCIpXG59XG5cbmlmIChkdCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGR0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZHQgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKGxhc3RfZHQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihsYXN0X2R0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGxhc3RfZHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsYXN0X2R0IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICB2ZWMyX3N1YihhdXgsIHZlbG9jaXR5LCBsYXN0X3ZlbG9jaXR5KTtcbiAgICB2ZWMyX3NjYWxlKGF1eCwgYXV4LCBkdCAvIGxhc3RfZHQpO1xuXG4gICAgdmVjMl9hZGQoYXV4LCB2ZWxvY2l0eSwgYXV4KTtcbiAgICB2ZWMyX3NjYWxlKGF1eCwgYXV4LCAwLjUgKiBkdCk7XG4gICAgdmVjMl9hZGQob3V0X3Bvc2l0aW9uLCBvdXRfcG9zaXRpb24sIGF1eCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVybGV0O1xuIiwidmFyIFZlYzIgPSByZXF1aXJlKFwiLi92ZWMyLmpzXCIpLFxuICAgIHZlYzJfYWRkID0gVmVjMi5hZGQsXG4gICAgdmVjMl9zdWIgPSBWZWMyLnN1YixcbiAgICB2ZWMyX2RvdCA9IFZlYzIuZG90LFxuICAgIHZlYzJfY3Jvc3NMZW5ndGggPSBWZWMyLmNyb3NzTGVuZ3RoLFxuICAgIHZlYzJfY3Jvc3MgPSBWZWMyLmNyb3NzLFxuICAgIHZlYzJfc2NhbGUgPSBWZWMyLnNjYWxlLFxuICAgIHZlYzJfbmVnYXRlID0gVmVjMi5uZWdhdGUsXG4gICAgdmVjMl9ub3JtYWxpemUgPSBWZWMyLm5vcm1hbGl6ZSxcbiAgICB2ZWMyX2xlbmd0aFNxID0gVmVjMi5sZW5ndGhTcSxcbiAgICB2ZWMyX3BlcnAgPSBWZWMyLnBlcnAsXG5cbiAgICBNYXRyaXgyMyA9IHJlcXVpcmUoXCIuL21hdHJpeDIzLmpzXCIpLFxuXG4gICAgQmVpemVyID0gcmVxdWlyZShcIi4vYmVpemVyLmpzXCIpLFxuICAgIGJlaXplcl9nZXRQb2ludHMgPSBCZWl6ZXIuZ2V0UG9pbnRzLFxuICAgIGYsXG4gICAgc3VtID0gMCxcbiAgICBjcm9zcyA9IDAsXG4gICAgeCxcbiAgICB5LFxuICAgIG8sXG4gICAgcCxcbiAgICBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIGNvcyA9IE1hdGguY29zLFxuICAgIGFicyA9IE1hdGguYWJzLFxuICAgIHNpbiA9IE1hdGguc2luLFxuICAgIEVQUyA9IE1hdGguRVBTO1xuLyoqXG4gKiBpbnB1dCBhcmUgbWFueSBWZWMyKHMpXG4gKiBAcmV0dXJuIHtQb2x5Z29ufVxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIG91dCA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG91dFtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKlxuICogQ3JlYXRlIHRoZSBjb252ZXggaHVsbCB1c2luZyB0aGUgR2lmdCB3cmFwcGluZyBhbGdvcml0aG1cbiAqIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL2p1aGwvY29sbGlzaW9uLWRldGVjdGlvbi0yZC9ibG9iL21hc3Rlci91dGlsLmpzXG4gKiBAcmVmZXJlbmNlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2lmdF93cmFwcGluZ19hbGdvcml0aG1cbiAqIEByZWZlcmVuY2UgaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vR2VvbWV0cnkvQ29udmV4X2h1bGwvTW9ub3RvbmVfY2hhaW5cbiAqIEBwYXJhbSB7VmVjMltdfSB2ZWMyX2xpc3RcbiAqIEByZXR1cm4ge1BvbHlnb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbnZleEh1bGwodmVjMl9saXN0KSB7XG4gICAgLy8gRmluZCB0aGUgcmlnaHQgbW9zdCBwb2ludCBvbiB0aGUgaHVsbFxuICAgIHZhciBpMCA9IDAsXG4gICAgICAgIHgwID0gdmVjMl9saXN0WzBdWzBdLFxuICAgICAgICBpLFxuICAgICAgICB4O1xuXG4gICAgZm9yIChpID0gMTsgaSA8IHZlYzJfbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB4ID0gdmVjMl9saXN0W2ldWzBdO1xuICAgICAgICBpZiAoeCA+IHgwIHx8ICh4ID09PSB4MCAmJiB2ZWMyX2xpc3RbaV1bMV0gPCB2ZWMyX2xpc3RbaTBdWzFdKSkge1xuICAgICAgICAgICAgaTAgPSBpO1xuICAgICAgICAgICAgeDAgPSB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG4gPSB2ZWMyX2xpc3QubGVuZ3RoLFxuICAgICAgICBodWxsID0gW10sXG4gICAgICAgIG0gPSAwLFxuICAgICAgICBpaCA9IGkwLFxuICAgICAgICBpZSxcbiAgICAgICAgaixcbiAgICAgICAgciA9IFswLCAwXSxcbiAgICAgICAgdiA9IFswLCAwXSxcbiAgICAgICAgYztcblxuICAgIGRvIHtcbiAgICAgICAgaHVsbFttXSA9IGloO1xuXG4gICAgICAgIGllID0gMDtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgaWYgKGllID09PSBpaCkge1xuICAgICAgICAgICAgICAgIGllID0gajtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVjMl9zdWIociwgdmVjMl9saXN0W2llXSwgdmVjMl9saXN0W2h1bGxbbV1dKTtcbiAgICAgICAgICAgIHZlYzJfc3ViKHYsIHZlYzJfbGlzdFtqXSwgdmVjMl9saXN0W2h1bGxbbV1dKTtcbiAgICAgICAgICAgIGMgPSBWZWMyLmNyb3NzKHIsIHYpO1xuICAgICAgICAgICAgaWYgKGMgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWUgPSBqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb2xsaW5lYXJpdHkgY2hlY2tcbiAgICAgICAgICAgIGlmIChjID09PSAwICYmIHZlYzJfbGVuZ3RoU3EodikgPiB2ZWMyX2xlbmd0aFNxKHIpKSB7XG4gICAgICAgICAgICAgICAgaWUgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgKyttO1xuICAgICAgICBpaCA9IGllO1xuICAgIH0gd2hpbGUgKGllICE9PSBpMCk7XG5cbiAgICAvLyBDb3B5IHZlcnRpY2VzXG4gICAgdmFyIG5ld1BvaW50cyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2godmVjMl9saXN0W2h1bGxbaV1dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FBQkIyfSBhYWJiMlxuICogQHJldHVybiB7UG9seWdvbn1cbiAqL1xuZnVuY3Rpb24gZnJvbUFBQkIoYWFiYjIpIHtcbmlmICghQXJyYXkuaXNBcnJheShhYWJiMikgfHwgYWFiYjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlswXSB8fCBhYWJiMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzFdIHx8IGFhYmIyWzJdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMl0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMl0gfHwgYWFiYjJbM10gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlszXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgQUFCQjIgYWFiYjJcIilcbn1cblxuICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoNCk7XG4gICAgb3V0WzBdID0gW2FhYmIyWzBdLCBhYWJiMlsxXV07XG4gICAgb3V0WzFdID0gW2FhYmIyWzBdLCBhYWJiMlszXV07XG4gICAgb3V0WzJdID0gW2FhYmIyWzJdLCBhYWJiMlszXV07XG4gICAgb3V0WzNdID0gW2FhYmIyWzJdLCBhYWJiMlsxXV07XG5cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdFxuICogQHJldHVybiB7UG9seWdvbn1cbiAqL1xuZnVuY3Rpb24gZnJvbVJlY3RhbmdsZShyZWN0KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkocmVjdCkgfHwgcmVjdFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVswXSB8fCByZWN0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzFdIHx8IHJlY3RbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMF0gfHwgcmVjdFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgUmVjdGFuZ2xlIHJlY3RcIilcbn1cblxuICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoNCk7XG4gICAgb3V0WzBdID0gW3JlY3RbMF1bMF0sIHJlY3RbMF1bMV1dO1xuICAgIG91dFsxXSA9IFtyZWN0WzBdWzBdLCByZWN0WzFdWzFdXTtcbiAgICBvdXRbMl0gPSBbcmVjdFsxXVswXSwgcmVjdFsxXVsxXV07XG4gICAgb3V0WzNdID0gW3JlY3RbMV1bMF0sIHJlY3RbMF1bMV1dO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcG9seWdvbiwgdGhlIHBvbHlnb24gaXMgYSBsaW5lXG4gKiBAdG9kbyBleHRydWRlIHRoaXMgbGluZVxuICogQHBhcmFtIHtCZWl6ZXJ9IGN1cnZlXG4gKiBAcGFyYW0ge051bWJlcn0gbnBvaW50c1xuICogQHJldHVybiB7UG9seWdvbn1cbiAqL1xuZnVuY3Rpb24gZnJvbUJlaXplcihjdXJ2ZSwgbnBvaW50cykge1xuaWYgKG5wb2ludHMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihucG9pbnRzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG5wb2ludHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJucG9pbnRzIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gYmVpemVyX2dldFBvaW50cyhjdXJ2ZSwgbnBvaW50cyk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHBvbHlnb24gZnJvbSBhIGNpcmNsZVxuICogc3RhcnRfcmFkaWFucyByb3RhdGUgdGhlIGdpdmVuIHBvbHlnb25cbiAqIEBwYXJhbSB7Q2lyY2xlfSBjaXJjbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBucG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRfcmFkaWFuc1xuICogQHJldHVybiB7UG9seWdvbn1cbiAqL1xuZnVuY3Rpb24gZnJvbUNpcmNsZShjaXJjbGUsIG5wb2ludHMsIHN0YXJ0X3JhZGlhbnMpIHtcbmlmIChucG9pbnRzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obnBvaW50cykgfHwgJ251bWJlcicgIT09IHR5cGVvZiBucG9pbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibnBvaW50cyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoc3RhcnRfcmFkaWFucyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHN0YXJ0X3JhZGlhbnMpIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygc3RhcnRfcmFkaWFucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0YXJ0X3JhZGlhbnMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHZhciBpID0gc3RhcnRfcmFkaWFucyxcbiAgICAgICAgbWF4ID0gTWF0aC5UV09fUEkgKyBzdGFydF9yYWRpYW5zLFxuICAgICAgICBhbmdsZSA9IE1hdGguVFdPX1BJIC8gbnBvaW50cyxcbiAgICAgICAgb3V0ID0gW10sXG4gICAgICAgIGN4ID0gY2lyY2xlWzBdWzBdLFxuICAgICAgICBjeSA9IGNpcmNsZVswXVsxXSxcbiAgICAgICAgciA9IGNpcmNsZVsxXSxcbiAgICAgICAgYyxcbiAgICAgICAgcztcblxuICAgIGZvciAoOyBpIDwgbWF4OyBpICs9IGFuZ2xlKSB7XG4gICAgICAgIGMgPSBjb3MoaSk7XG4gICAgICAgIHMgPSBzaW4oaSk7XG4gICAgICAgIG91dC5wdXNoKFtjeCArIGMgKiByLCBjeSArIHMgKiByXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7UG9seWdvbn0gb3V0XG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHlcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHJldHVybiB7UG9seWdvbn1cbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgcG9seSwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICB2YXIgbGVuID0gcG9seS5sZW5ndGggLSAxO1xuXG4gICAgeCA9IHZlYzJbMF07XG4gICAgeSA9IHZlYzJbMV07XG5cbiAgICBkbyB7XG4gICAgICAgIHAgPSBwb2x5W2xlbl07XG4gICAgICAgIG8gPSBvdXRbbGVuXSA9IG91dFtsZW5dIHx8IFswLCAwXTtcbiAgICAgICAgb1swXSA9IHBbMF0gKyB4O1xuICAgICAgICBvWzFdID0gcFsxXSArIHk7XG4gICAgfSB3aGlsZSAobGVuLS0pO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cbnZhciBjZmFjdG9yLFxuICAgIHNmYWN0b3I7XG4vKipcbiAqXG4gKiBAcGFyYW0ge1BvbHlnb259IG91dFxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaWFuc1xuICogQHJldHVybiB7UG9seWdvbn1cbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dCwgcG9seSwgcmFkaWFucykge1xuaWYgKHJhZGlhbnMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyYWRpYW5zKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGlhbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpYW5zIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBpZiAob3V0Lmxlbmd0aCA+IHBvbHkubGVuZ3RoKSB7XG4gICAgICAgIG91dC5zcGxpY2UocG9seS5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwb2x5Lmxlbmd0aCAtIDE7XG5cbiAgICBjZmFjdG9yID0gY29zKHJhZGlhbnMpO1xuICAgIHNmYWN0b3IgPSBzaW4ocmFkaWFucyk7XG5cbiAgICBkbyB7XG4gICAgICAgIHAgPSBwb2x5W2xlbl07XG4gICAgICAgIG8gPSBvdXRbbGVuXSA9IG91dFtsZW5dIHx8IFswLCAwXTtcbiAgICAgICAgeCA9IHBbMF07XG4gICAgICAgIHkgPSBwWzFdO1xuXG4gICAgICAgIG9bMF0gPSB4ICogY2ZhY3RvciAtIHkgKiBzZmFjdG9yO1xuICAgICAgICBvWzFdID0geCAqIHNmYWN0b3IgKyB5ICogY2ZhY3RvcjtcbiAgICB9IHdoaWxlIChsZW4tLSk7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtQb2x5Z29ufSBvdXRcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnNcbiAqIEByZXR1cm4ge1BvbHlnb259XG4gKi9cbmZ1bmN0aW9uIGVkZ2VzKG91dCwgcG9seSkge1xuICAgIGlmIChvdXQubGVuZ3RoID4gcG9seS5sZW5ndGgpIHtcbiAgICAgICAgb3V0LnNwbGljZShwb2x5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsZW4gPSBwb2x5Lmxlbmd0aCxcbiAgICAgICAgbGVubTEgPSBsZW4gLSAxO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBlZGdlcy9ub3JtYWxzXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2ZWMyX3N1YihvdXRbaV0gPSBvdXRbaV0gfHwgWzAsIDBdLCBwb2x5W2kgPCBsZW5tMSA/IGkgKyAxIDogMF0sIHBvbHlbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0ge1BvbHlnb259IG91dFxuICogQHBhcmFtIHtQb2x5Z29ufSBlZGdlc1xuICogQHJldHVybiB7UG9seWdvbn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFscyhvdXQsIGVkZ2VzKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsZW4gPSBlZGdlcy5sZW5ndGg7XG5cbiAgICBpZiAob3V0Lmxlbmd0aCA+IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICBvdXQuc3BsaWNlKGVkZ2VzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBvdXRbaV0gfHwgWzAsIDBdO1xuICAgICAgICB2ZWMyX3BlcnAob3V0W2ldLCBlZGdlc1tpXSk7XG4gICAgICAgIHZlYzJfbm9ybWFsaXplKG91dFtpXSwgb3V0W2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG52YXIgY19hdXggPSBbMCwgMF0sXG4gICAgY19hdXgyID0gWzAsIDBdO1xuLyoqXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5XG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBjZW50cm9pZChvdXRfdmVjMiwgcG9seSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuICAgIHZhciBpID0gMCxcbiAgICAgICAgbGVuID0gcG9seS5sZW5ndGg7XG5cbiAgICBzdW0gPSAwO1xuICAgIG91dF92ZWMyWzBdID0gMDtcbiAgICBvdXRfdmVjMlsxXSA9IDE7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNfYXV4WzBdID0gcG9seVtpXVswXTtcbiAgICAgICAgY19hdXhbMV0gPSBwb2x5W2ldWzFdO1xuICAgICAgICBmID0gKGkgPT09IGxlbikgPyAwIDogaTtcbiAgICAgICAgY19hdXgyWzBdID0gcG9seVtmXVswXTtcbiAgICAgICAgY19hdXgyWzBdID0gcG9seVtmXVsxXTtcblxuICAgICAgICBjcm9zcyA9IHZlYzJfY3Jvc3MoY19hdXgsIGNfYXV4Mik7XG5cbiAgICAgICAgc3VtICs9IGNyb3NzO1xuICAgICAgICB2ZWMyX2FkZChjX2F1eCwgY19hdXgsIGNfYXV4Mik7XG4gICAgICAgIHZlYzJfc2NhbGUoY19hdXgsIGNfYXV4LCBjcm9zcyk7XG4gICAgICAgIHZlYzJfYWRkKG91dF92ZWMyLCBvdXRfdmVjMiwgY19hdXgpO1xuICAgIH1cblxuICAgIHJldHVybiB2ZWMyX3NjYWxlKG91dF92ZWMyLCBvdXRfdmVjMiwgMSAvICgzICogc3VtKSk7XG59XG52YXIgdmVjMl9jZW50cm9pZCA9IFswLCAwXTtcbi8qKlxuICpcbiAqIEBwYXJhbSB7UG9seWdvbn0gb3V0XG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHlcbiAqIEByZXR1cm4ge1BvbHlnb259XG4gKi9cbmZ1bmN0aW9uIHJlY2VudGVyKG91dCwgcG9seSkge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbGVuID0gcG9seS5sZW5ndGg7XG5cbiAgICBpZiAob3V0Lmxlbmd0aCA+IHBvbHkubGVuZ3RoKSB7XG4gICAgICAgIG91dC5zcGxpY2UocG9seS5sZW5ndGgpO1xuICAgIH1cblxuICAgIGNlbnRyb2lkKHZlYzJfY2VudHJvaWQsIHBvbHkpO1xuICAgIHZhciB4ID0gdmVjMl9jZW50cm9pZFswXSxcbiAgICAgICAgeSA9IHZlYzJfY2VudHJvaWRbMV07XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG91dFtpXSA9IG91dFtpXSB8fCBbMCwgMF07IC8vIGNyZWF0ZSBpZiBuZWVkZWQuLi5cbiAgICAgICAgb3V0W2ldWzBdICs9IHg7XG4gICAgICAgIG91dFtpXVsxXSArPSB5O1xuICAgIH1cbn1cbi8qXG4qIEBUT0RPIHJldmlldywgdGhpcyBkb2Vzbid0IHNlZW1zIHRvIGJlIHJpZ2h0IVxuKiBHZXQgdGhlIGNpcmN1bWV0ZXIgb2YgcG9seWdvblxuKiBAcGFyYW0ge0NvbXBsZXhbXX0gcCBUaGUgcG9seWdvblxuZnVuY3Rpb24gY2lyY3VtY2VudGVyKG91dCwgcG9seSkge1xuICAgIHZhciBjaXJjID0gMCwgaSA9IDE7XG4gICAgZm9yICg7IGkgPCBwb2x5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZHggPSBwb2x5W2ldWzBdIC0gcG9seVtpIC0gMV1bMF07XG4gICAgICB2YXIgZHkgPSBwb2x5W2ldWzFdIC0gcG9seVtpIC0gMV1bMV07XG4gICAgICBjaXJjICs9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cbiAgICByZXR1cm4gY2lyYztcbn0sXG4qL1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHlcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gYXJlYShwb2x5KSB7XG4gICAgdmFyIHZhbHVlID0gMCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxlbiA9IHBvbHkubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBmID0gKGkgPT09IGxlbikgPyAwIDogaTtcbiAgICAgICAgdmFsdWUgLT0gKHBvbHlbaV1bMF0gKiBwb2x5W2ZdWzBdKSAtIChwb2x5W2ldWzFdICogcG9seVtmXVsxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlICogMC41O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1BvbHlnb259IG91dFxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5XG4gKiBAcGFyYW0ge01hdHJpeDIzfSBtMmRcbiAqIEByZXR1cm4ge1BvbHlnb259XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShvdXQsIHBvbHksIG0yZCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG0yZCkgfHwgbTJkWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFswXSB8fCBtMmRbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzFdIHx8IG0yZFsyXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbMl0gfHwgbTJkWzNdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4obTJkWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG0yZFszXSB8fCBtMmRbNF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihtMmRbNF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbTJkWzRdIHx8IG0yZFs1XSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG0yZFs1XSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBtMmRbNV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1hdHJpeDIzIG0yZFwiKVxufVxuXG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsZW4gPSBwb2x5Lmxlbmd0aDtcblxuICAgIGlmIChvdXQubGVuZ3RoID4gcG9seS5sZW5ndGgpIHtcbiAgICAgICAgb3V0LnNwbGljZShwb2x5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvdXRbaV0gPSBvdXRbaV0gfHwgWzAsIDBdO1xuICAgICAgICBNYXRyaXgyMy50cmFuc2Zvcm0ob3V0W2ldLCBtMmQsIHBvbHlbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seVxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZlYzJJbnNpZGUocG9seSwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbiA9IHBvbHkubGVuZ3RoLFxuICAgICAgICBqID0gbGVuIC0gMSxcbiAgICAgICAgYyA9IGZhbHNlO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGogPSBpKyspIHtcbiAgICAgICAgaWYgKChwb2x5W2ldWzFdID49IHZlYzJbMV0pICE9PSAocG9seVtqXVsxXSA+PSB2ZWMyWzFdKSAmJlxuICAgICAgICAgICAgKHZlYzJbMF0gPD0gKHBvbHlbal1bMF0gLSBwb2x5W2ldWzBdKSAqICh2ZWMyWzFdIC0gcG9seVtpXVsxXSkgLyAocG9seVtqXVsxXSAtIHBvbHlbaV1bMV0pICsgcG9seVtpXVswXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjID0gIWM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYztcbn1cblxuLyoqXG4gKiBDb21wdXRlIGZhcnRoZXN0IHBvbHlnb24gcG9pbnQgaW4gcGFydGljdWxhciBkaXJlY3Rpb24uXG4gKiBSZXR1cm4gdGhlIGluZGV4IGluIHRoZSBwb2x5Z29uIGFuZCBhIGNsb25lIGluIG91dF92ZWMyXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5XG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJfZGlyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGluZGV4IGluIHRoZSBjdXJyZW50IHBvbHlcbiAqL1xuZnVuY3Rpb24gZnVydGhlc3RQb2ludChvdXRfdmVjMiwgcG9seSwgdmVjMl9kaXIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyX2RpcikgfHwgdmVjMl9kaXJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyX2RpclswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyX2RpclswXSB8fCB2ZWMyX2RpclsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJfZGlyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJfZGlyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJfZGlyXCIpXG59XG5cbiAgICB2YXIgaWR4LFxuICAgICAgICBpLFxuICAgICAgICBtYXgsXG4gICAgICAgIG1heF9kb3QgPSAtSW5maW5pdHksXG4gICAgICAgIGN1cnJlbnRfZG90O1xuXG4gICAgZm9yIChpID0gMCwgbWF4ID0gcG9seS5sZW5ndGg7IGkgPCBtYXg7ICsraSkge1xuICAgICAgICBjdXJyZW50X2RvdCA9IFZlYzIuZG90KHBvbHlbaV0sIHZlYzJfZGlyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRfZG90ID4gbWF4X2RvdCkge1xuICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgIG1heF9kb3QgPSBjdXJyZW50X2RvdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG91dF92ZWMyWzBdID0gcG9seVtpZHhdWzBdO1xuICAgIG91dF92ZWMyWzFdID0gcG9seVtpZHhdWzFdO1xuXG4gICAgcmV0dXJuIGlkeDtcbn1cblxudmFyIGZtX25kID0gWzAsIDBdLFxuICAgIGZtX2EgPSBbMCwgMF0sXG4gICAgZm1fYiA9IFswLCAwXTtcblxuLypcbiAqIGZ1cnRoZXN0IFBvaW50IGluIHRoZSBNaW5rb3dza2kgZGlmZiBiZXR3ZWVuIEEgYW5kIEIgcG9seWdvbnMgZm9yIGEgZ2l2ZW4gZGlyZWN0aW9uXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5X2FcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seV9iXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJfZGlyXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBmdXJ0aGVzdE1pbmtvd3NraShvdXRfdmVjMiwgcG9seV9hLCBwb2x5X2IsIHZlYzJfZGlyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMl9kaXIpIHx8IHZlYzJfZGlyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMl9kaXJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMl9kaXJbMF0gfHwgdmVjMl9kaXJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyX2RpclsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyX2RpclsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyX2RpclwiKVxufVxuXG4gICAgLy8gZnVydGhlc3QgcG9pbnQgaW4gcG9seV9hIGZvciB2ZWMyX2RpclxuICAgIGZ1cnRoZXN0UG9pbnQoZm1fYSwgcG9seV9hLCB2ZWMyX2Rpcik7XG5cbiAgICAvLyBmdXJ0aGVzdCBwb2ludCBpbiBwb2x5X2IgZm9yIC12ZWMyX2RpclxuICAgIHZlYzJfbmVnYXRlKGZtX25kLCB2ZWMyX2Rpcik7XG4gICAgZnVydGhlc3RQb2ludChmbV9iLCBwb2x5X2IsIGZtX25kKTtcblxuICAgIHJldHVybiB2ZWMyX3N1YihvdXRfdmVjMiwgZm1fYSwgZm1fYik7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIE1pbmtvd3NraSBEaWZmZXJlbmNlXG4gKlxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5X2FcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seV9iXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBhIG5ldyBvbmUsIGJlY2F1c2UgdGhlIHNpemUgaXMgcmFuZG9tXG4gKi9cbmZ1bmN0aW9uIE1pbmtvd3NraURpZmZlcmVuY2UocG9seV9hLCBwb2x5X2IpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaW1heCA9IHBvbHlfYS5sZW5ndGgsXG4gICAgICAgIGosXG4gICAgICAgIGptYXggPSBwb2x5X2IubGVuZ3RoLFxuICAgICAgICBzY2FsZSA9IGltYXggKiBqbWF4LFxuICAgICAgICBtaW5rU3VtID0gbmV3IEFycmF5KHNjYWxlKSxcbiAgICAgICAgaWR4ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGptYXg7ICsraikge1xuICAgICAgICAgICAgbWlua1N1bVtpZHgrK10gPSBbcG9seV9hW2ldWzBdIC0gcG9seV9iW2pdWzBdLCBwb2x5X2FbaV1bMV0gLSBwb2x5X2Jbal1bMV1dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNvbnZleEh1bGwobWlua1N1bSk7XG59XG4vKipcbiAqIEBzb3VyY2UgaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy8zNDI4MjItbW9tZW50LW9mLWluZXJ0aWEtb2YtYS1wb2x5Z29uLTJkL1xuICogQHNvdXJjZSBodHRwOi8vd3d3LnBoeXNpY3Nmb3J1bXMuY29tL3Nob3d0aHJlYWQucGhwP3Q9MjUyOTMmcGFnZT0yJnBwPTE1XG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXNzXG4gKi9cbmZ1bmN0aW9uIG1vbWVudE9mSW5lcnRpYShwb2x5LCBtYXNzKSB7XG5pZiAobWFzcyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hc3MpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWFzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1hc3MgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHZhciBkZW5vbSA9IDAuMCxcbiAgICAgICAgbnVtZXIgPSAwLjAsXG4gICAgICAgIGxlbiA9IHBvbHkubGVuZ3RoLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgaiA9IGxlbiAtIDEsXG4gICAgICAgIHAwLFxuICAgICAgICBwMSxcbiAgICAgICAgYSxcbiAgICAgICAgYjtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBqID0gaSsrKSB7XG4gICAgICAgIHAwID0gcG9seVtqXTtcbiAgICAgICAgcDEgPSBwb2x5W2ldO1xuICAgICAgICBhID0gYWJzKHZlYzJfY3Jvc3NMZW5ndGgocDAsIHAxKSk7XG4gICAgICAgIGIgPSB2ZWMyX2RvdChwMSwgcDEpICsgdmVjMl9kb3QocDEsIHAwKSArIHZlYzJfZG90KHAwLCBwMCk7XG4gICAgICAgIGRlbm9tICs9IGEgKiBiO1xuICAgICAgICBudW1lciArPSBhO1xuICAgIH1cbiAgICByZXR1cm4gKG1hc3MgLyA2LjApICogKGRlbm9tIC8gbnVtZXIpO1xufVxuXG4vKipcbiAqIEBzb3VyY2UgaHR0cDovL3BhdWxib3Vya2UubmV0L2dlb21ldHJ5L3BvbHlnb25tZXNoL1xuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5XG4gKi9cbmZ1bmN0aW9uIGlzQ29udmV4KHBvbHkpIHtcbiAgICB2YXIgbGVuID0gcG9seS5sZW5ndGgsXG4gICAgICAgIGksXG4gICAgICAgIGogPSAxLFxuICAgICAgICBrID0gMixcbiAgICAgICAgZmxhZyA9IDAsXG4gICAgICAgIHo7XG5cbiAgICBpZiAobGVuIDwgMykge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpLCArK2osICsraykge1xuICAgICAgICBqID0gaiAlIGxlbjtcbiAgICAgICAgayA9IGsgJSBsZW47XG5cbiAgICAgICAgeiAgPSAocG9seVtqXVswXSAtIHBvbHlbaV1bMF0pICogKHBvbHlba11bMV0gLSBwb2x5W2pdWzFdKSAtXG4gICAgICAgICAgICAgKHBvbHlbal1bMV0gLSBwb2x5W2ldWzFdKSAqIChwb2x5W2tdWzBdIC0gcG9seVtqXVswXSk7XG4gICAgICAgIGlmICh6IDwgMCkge1xuICAgICAgICAgICAgZmxhZyB8PSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHogPiAwKSB7XG4gICAgICAgICAgICBmbGFnIHw9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZyA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZsYWcgIT09IDApIHtcbiAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHBvbHkpIHtcbiAgICB2YXIgdmVjMnMgPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuID0gcG9seS5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmVjMnMucHVzaChWZWMyLnRvU3RyaW5nKHBvbHlbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJ7XCIgKyB2ZWMycy5qb2luKFwiLFwiKSArIFwifVwiO1xufVxuXG4vKipcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKi9cbnZhciBQb2x5Z29uID0ge1xuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGNyZWF0ZUNvbnZleEh1bGw6IGNyZWF0ZUNvbnZleEh1bGwsXG4gICAgZnJvbUFBQkI6IGZyb21BQUJCLFxuICAgIGZyb21SZWN0YW5nbGU6IGZyb21SZWN0YW5nbGUsXG4gICAgZnJvbUJlaXplcjogZnJvbUJlaXplcixcbiAgICBmcm9tQ2lyY2xlOiBmcm9tQ2lyY2xlLFxuICAgIHRyYW5zbGF0ZTogdHJhbnNsYXRlLFxuICAgIGlzQ29udmV4OiBpc0NvbnZleCxcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICBjZW50cm9pZDogY2VudHJvaWQsXG4gICAgcmVjZW50ZXI6IHJlY2VudGVyLFxuICAgIC8vY2lyY3VtY2VudGVyOiBjaXJjdW1jZW50ZXIsXG4gICAgYXJlYTogYXJlYSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcblxuICAgIG5vcm1hbHM6IG5vcm1hbHMsXG4gICAgZWRnZXM6IGVkZ2VzLFxuXG4gICAgaXNWZWMySW5zaWRlOiBpc1ZlYzJJbnNpZGUsXG4gICAgZnVydGhlc3RQb2ludDogZnVydGhlc3RQb2ludCxcbiAgICBmdXJ0aGVzdE1pbmtvd3NraTogZnVydGhlc3RNaW5rb3dza2ksXG4gICAgTWlua293c2tpRGlmZmVyZW5jZTogTWlua293c2tpRGlmZmVyZW5jZSxcblxuICAgIC8vcGh5c2ljc1xuICAgIG1vbWVudE9mSW5lcnRpYTogbW9tZW50T2ZJbmVydGlhLFxuXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XG4iLCIvKlxuICogU3RhYmlsaXR5OiAxIChPbmx5IGFkZGl0aW9ucyAmIGZpeGVzKVxuICpcbiAqIFJlY3RhbmdsZSBpcyByZXByZXNlbnRlZCBhcyBhIHRocmVlIGNvb3JkaW5hdGVzIGFycmF5XG4gKiBbYTogVmVjMiwgYjogVmVjMiwgbm9ybWFsaXplZDogQm9vbGVhbl1cbiAqL1xuXG52YXIgVmVjMiA9IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBleHBvcnRzID8gd2luZG93LlZlYzIgOiByZXF1aXJlKFwiLi92ZWMyLmpzXCIpLFxuICAgIHZlYzJfZGlzdGFuY2UgPSBWZWMyLmRpc3RhbmNlLFxuICAgIG1heCA9IE1hdGgubWF4LFxuICAgIG1pbiA9IE1hdGgubWluLFxuICAgIGF1eF92ZWMyXzEgPSBbMCwgMF0sXG4gICAgYXV4X3ZlYzJfMiA9IFswLCAwXSxcbiAgICBhID0gMCxcbiAgICBiID0gMDtcbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHgxXG4gKiBAcGFyYW0ge051bWJlcn0geTFcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSh4MSwgeTEsIHgyLCB5Mikge1xuaWYgKHgxID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDEpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgdmFyIG91dCA9IFtbeDEsIHkxXSwgW3gyLCB5Ml0sIGZhbHNlXTtcbiAgICBub3JtYWxpemUob3V0LCBvdXQpO1xuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7QUFCQjJ9IGFhYmIyXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG4gKi9cbmZ1bmN0aW9uIGZyb21CQihhYWJiMikge1xuaWYgKCFBcnJheS5pc0FycmF5KGFhYmIyKSB8fCBhYWJiMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzBdIHx8IGFhYmIyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oYWFiYjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgYWFiYjJbMV0gfHwgYWFiYjJbMl0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihhYWJiMlsyXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBhYWJiMlsyXSB8fCBhYWJiMlszXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGFhYmIyWzNdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGFhYmIyWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQUJCMiBhYWJiMlwiKVxufVxuXG4gICAgcmV0dXJuIGNyZWF0ZShhYWJiMlswXSwgYWFiYjJbMV0sIGFhYmIyWzJdLCBhYWJiMlszXSk7XG59XG4vKipcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX1cbiAqL1xuZnVuY3Rpb24gemVybygpIHtcbiAgICByZXR1cm4gW1swLCAwXSwgWzAsIDBdLCB0cnVlXTtcbn1cbi8qKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX1cbiAqL1xuZnVuY3Rpb24gY2xvbmUocmVjdCkge1xuaWYgKCFBcnJheS5pc0FycmF5KHJlY3QpIHx8IHJlY3RbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMF0gfHwgcmVjdFswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVsxXSB8fCByZWN0WzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzBdIHx8IHJlY3RbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSByZWN0XCIpXG59XG5cbiAgICByZXR1cm4gW1tyZWN0WzBdWzBdLCByZWN0WzBdWzFdXSwgW3JlY3RbMV1bMF0sIHJlY3RbMV1bMV1dLCByZWN0WzJdXTtcbn1cbi8qKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IG91dFxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX1cbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIHJlY3QpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF1bMF0gfHwgb3V0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXVsxXSB8fCBvdXRbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdWzBdIHx8IG91dFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHJlY3QpIHx8IHJlY3RbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMF0gfHwgcmVjdFswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVsxXSB8fCByZWN0WzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzBdIHx8IHJlY3RbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSByZWN0XCIpXG59XG5cbiAgICBvdXRbMF1bMF0gPSByZWN0WzBdWzBdO1xuICAgIG91dFswXVsxXSA9IHJlY3RbMF1bMV07XG5cbiAgICBvdXRbMV1bMF0gPSByZWN0WzFdWzBdO1xuICAgIG91dFsxXVsxXSA9IHJlY3RbMV1bMV07XG5cbiAgICBvdXRbMl0gPSByZWN0WzJdO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBhIC0+IGJvdHRvbS1sZWZ0XG4gKiBhIC0+IHRvcC1yaWdodFxuICpcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBvdXRcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW49fSBmb3JjZVxuICogQHJldHVybiB7UmVjdGFuZ2xlfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCByZWN0LCBmb3JjZSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dCkgfHwgb3V0WzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXVswXSB8fCBvdXRbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzBdWzFdIHx8IG91dFsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV1bMF0gfHwgb3V0WzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsxXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgUmVjdGFuZ2xlIG91dFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkocmVjdCkgfHwgcmVjdFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVswXSB8fCByZWN0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzFdIHx8IHJlY3RbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMF0gfHwgcmVjdFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgUmVjdGFuZ2xlIHJlY3RcIilcbn1cblxuaWYgKGZvcmNlICE9PSB1bmRlZmluZWQpIHtcbmlmICgnYm9vbGVhbicgIT09IHR5cGVvZiBmb3JjZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZvcmNlIGlzIG5vdCBhIGJvb2xlYW5cIilcbn1cblxufVxuICAgIGZvcmNlID0gZm9yY2UgfHwgcmVjdFsyXSA9PT0gZmFsc2UgfHwgZmFsc2U7XG5cbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICAgIGNvcHkob3V0LCByZWN0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhID0gbWluKHJlY3RbMF1bMF0sIHJlY3RbMV1bMF0pO1xuICAgIGIgPSBtYXgocmVjdFswXVswXSwgcmVjdFsxXVswXSk7XG5cbiAgICBvdXRbMF1bMF0gPSBhO1xuICAgIG91dFsxXVswXSA9IGI7XG5cbiAgICBhID0gbWluKHJlY3RbMF1bMV0sIHJlY3RbMV1bMV0pO1xuICAgIGIgPSBtYXgocmVjdFswXVsxXSwgcmVjdFsxXVsxXSk7XG5cbiAgICBvdXRbMF1bMV0gPSBhO1xuICAgIG91dFsxXVsxXSA9IGI7XG5cbiAgICBvdXRbMl0gPSB0cnVlO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIGNlbnRlcihvdXRfdmVjMiwgcmVjdCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHJlY3QpIHx8IHJlY3RbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMF0gfHwgcmVjdFswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVsxXSB8fCByZWN0WzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzBdIHx8IHJlY3RbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSByZWN0XCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IChyZWN0WzBdWzBdICsgcmVjdFsxXVswXSkgKiAwLjU7XG4gICAgb3V0X3ZlYzJbMV0gPSAocmVjdFswXVsxXSArIHJlY3RbMV1bMV0pICogMC41O1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gb3V0XG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdFxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIHJlY3QsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF1bMF0gfHwgb3V0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXVsxXSB8fCBvdXRbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdWzBdIHx8IG91dFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHJlY3QpIHx8IHJlY3RbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMF0gfHwgcmVjdFswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVsxXSB8fCByZWN0WzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzBdIHx8IHJlY3RbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSByZWN0XCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgb3V0WzBdWzBdID0gcmVjdFswXVswXSArIHZlYzJbMF07XG4gICAgb3V0WzBdWzFdID0gcmVjdFswXVsxXSArIHZlYzJbMV07XG5cbiAgICBvdXRbMV1bMF0gPSByZWN0WzFdWzBdICsgdmVjMlswXTtcbiAgICBvdXRbMV1bMV0gPSByZWN0WzFdWzFdICsgdmVjMlsxXTtcblxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0XG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdDJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UocmVjdCwgcmVjdDIpIHtcbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzBdIHx8IHJlY3RbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMV0gfHwgcmVjdFsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVswXSB8fCByZWN0WzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBSZWN0YW5nbGUgcmVjdFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkocmVjdDIpIHx8IHJlY3QyWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdDJbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdDJbMF1bMF0gfHwgcmVjdDJbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0MlswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0MlswXVsxXSB8fCByZWN0MlsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3QyWzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3QyWzFdWzBdIHx8IHJlY3QyWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdDJbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdDJbMV1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJlY3RhbmdsZSByZWN0MlwiKVxufVxuXG4gICAgY2VudGVyKGF1eF92ZWMyXzEsIHJlY3QpO1xuICAgIGNlbnRlcihhdXhfdmVjMl8yLCByZWN0Mik7XG5cbiAgICByZXR1cm4gdmVjMl9kaXN0YW5jZShhdXhfdmVjMl8yLCBhdXhfdmVjMl8xKTtcbn1cbi8qKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gYXJlYShyZWN0KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkocmVjdCkgfHwgcmVjdFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFswXVswXSB8fCByZWN0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzFdIHx8IHJlY3RbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMV1bMF0gfHwgcmVjdFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgUmVjdGFuZ2xlIHJlY3RcIilcbn1cblxuICAgIGEgPSByZWN0WzBdWzBdIC0gcmVjdFsxXVswXTtcbiAgICBiID0gcmVjdFswXVsxXSAtIHJlY3RbMV1bMV07XG4gICAgYSAqPSBiO1xuXG4gICAgcmV0dXJuIGEgPCAwID8gLWEgOiBhOyAvL25lZWRlZCBpZCBub3JtYWxpemVkID9cbn1cbi8qKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWZWMySW5zaWRlKHJlY3QsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzBdIHx8IHJlY3RbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMV0gfHwgcmVjdFsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVswXSB8fCByZWN0WzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBSZWN0YW5nbGUgcmVjdFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIHJldHVybiByZWN0WzBdWzBdIDwgdmVjMlswXSAmJiByZWN0WzFdWzBdID4gdmVjMlswXSAmJiByZWN0WzBdWzFdIDwgdmVjMlsxXSAmJiByZWN0WzFdWzFdID4gdmVjMlsxXTtcbn1cbi8qKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gcGVyaW1ldGVyKHJlY3QpIHtcbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzBdIHx8IHJlY3RbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMV0gfHwgcmVjdFsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVswXSB8fCByZWN0WzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBSZWN0YW5nbGUgcmVjdFwiKVxufVxuXG4gICAgcmV0dXJuIChyZWN0WzFdWzBdIC0gcmVjdFswXVswXSkgKiAyICsgKHJlY3RbMV1bMV0gLSByZWN0WzBdWzFdKSAqIDIgO1xufVxuLyoqXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IG1hc3NcbiAqL1xuZnVuY3Rpb24gbW9tZW50T2ZJbmVydGlhKHJlY3QsIG1hc3MpIHtcbmlmICghQXJyYXkuaXNBcnJheShyZWN0KSB8fCByZWN0WzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzBdWzBdIHx8IHJlY3RbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyZWN0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJlY3RbMF1bMV0gfHwgcmVjdFsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJlY3RbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmVjdFsxXVswXSB8fCByZWN0WzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmVjdFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiByZWN0WzFdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBSZWN0YW5nbGUgcmVjdFwiKVxufVxuXG5pZiAobWFzcyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG1hc3MpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbWFzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1hc3MgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHZhciB3ID0gcmVjdFsxXVswXSAtIHJlY3RbMF1bMF0sXG4gICAgICAgIGggPSByZWN0WzFdWzFdIC0gcmVjdFswXVsxXTtcblxuICAgIC8vIFgvMTJcbiAgICByZXR1cm4gbWFzcyAqIChoKmggKyB3KncpICogMC4wODMzMzMzMzMzMzMzMzMzMztcbn1cbi8qKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICovXG52YXIgUmVjdGFuZ2xlID0ge1xuICAgIGZyb21CQjogZnJvbUJCLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIHplcm86IHplcm8sXG4gICAgY2xvbmU6IGNsb25lLFxuICAgIGNvcHk6IGNvcHksXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXG4gICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgIGFyZWE6IGFyZWEsXG4gICAgaXNWZWMySW5zaWRlOiBpc1ZlYzJJbnNpZGUsXG4gICAgcGVyaW1ldGVyOiBwZXJpbWV0ZXIsXG5cbiAgICAvL3BoeXNpY3NcbiAgICBtb21lbnRPZkluZXJ0aWE6IG1vbWVudE9mSW5lcnRpYSxcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGU7IiwiLyoqXG4gKiBTZWdtZW50MiBpcyByZXByZXNlbnRlZCBieSBhIDQgY29vcmRpbmF0ZXMgYXJyYXlcbiAqIFt4MTpOdW1iZXIsIHkxOk51bWJlciwgeDI6TnVtYmVyLCB5MjpOdW1iZXJdIG5vcm1hbGl6ZWQgc28geDEgPCB4MlxuICovXG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4vdmVjMi5qc1wiKSxcbiAgICB2ZWMyX3JvdGF0ZSA9IFZlYzIucm90YXRlLFxuICAgIGF1eF92ZWMyID0gWzAsIDBdLFxuICAgIGF1eCxcbiAgICB3aXRoaW4gPSBWZWMyLiR3aXRoaW4sXG4gICAgc3FydCA9IE1hdGguc3FydCxcbiAgICBhdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgUEkgPSBNYXRoLlBJLFxuICAgIG5lYXIgPSBNYXRoLm5lYXIsXG4gICAgX194LFxuICAgIF9feSxcbiAgICB1ID0gMDtcbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHgxXG4gKiBAcGFyYW0ge051bWJlcn0geTFcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gKiBAcmV0dXJuIHtTZWdtZW50Mn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHgxLCB5MSwgeDIsIHkyKSB7XG5pZiAoeDEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHgyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBpZiAoeDEgPCB4Mikge1xuICAgICAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3gyLCB5MiwgeDEsIHkxXTtcbn1cbi8qKlxuICogQHBhcmFtIHtTZWdtZW50Mn0gb3V0XG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcmV0dXJuIHtTZWdtZW50Mn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgc2VnMikge1xuICAgIGlmIChzZWcyWzBdIDwgc2VnMlsxXSkge1xuICAgICAgICBvdXRbMF0gPSBzZWcyWzBdO1xuICAgICAgICBvdXRbMV0gPSBzZWcyWzFdO1xuICAgICAgICBvdXRbMl0gPSBzZWcyWzJdO1xuICAgICAgICBvdXRbM10gPSBzZWcyWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ID0gc2VnMlswXSxcbiAgICAgICAgICAgIHkgPSBzZWcyWzFdO1xuXG4gICAgICAgIG91dFswXSA9IHNlZzJbMl07XG4gICAgICAgIG91dFsxXSA9IHNlZzJbM107XG4gICAgICAgIG91dFsyXSA9IHg7XG4gICAgICAgIG91dFszXSA9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQHBhcmFtIHtTZWdtZW50Mn0gc2VnMlxuICogQHJldHVybiB7U2VnbWVudDJ9XG4gKi9cbmZ1bmN0aW9uIGNsb25lKHNlZzIpIHtcbiAgICByZXR1cm4gW3NlZzJbMF0sIHNlZzJbMV0sIHNlZzJbMl0sIHNlZzJbM11dO1xufVxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBvdXRcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEByZXR1cm4ge1NlZ21lbnQyfVxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgc2VnMikge1xuICAgIG91dFswXSA9IHNlZzJbMF07XG4gICAgb3V0WzFdID0gc2VnMlsxXTtcbiAgICBvdXRbMl0gPSBzZWcyWzJdO1xuICAgIG91dFszXSA9IHNlZzJbM107XG5cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBvdXRcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHJldHVybiB7U2VnbWVudDJ9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIHNlZzIsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgb3V0WzBdID0gc2VnMlswXSArIHZlYzJbMF07XG4gICAgb3V0WzFdID0gc2VnMlsxXSArIHZlYzJbMV07XG4gICAgb3V0WzJdID0gc2VnMlsyXSArIHZlYzJbMF07XG4gICAgb3V0WzNdID0gc2VnMlszXSArIHZlYzJbMV07XG5cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChzZWcyKSB7XG4gICAgX194ID0gc2VnMlsyXSAtIHNlZzJbMF07XG4gICAgX195ID0gc2VnMlszXSAtIHNlZzJbMV07XG5cbiAgICByZXR1cm4gc3FydChfX3ggKiBfX3ggKyBfX3kgKiBfX3kpO1xufVxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNxckxlbmd0aChzZWcyKSB7XG4gICAgX194ID0gc2VnMlsyXSAtIHNlZzJbMF07XG4gICAgX195ID0gc2VnMlszXSAtIHNlZzJbMV07XG5cbiAgICByZXR1cm4gX194ICogX194ICsgX195ICogX195O1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBtaWRQb2ludChvdXRfdmVjMiwgc2VnMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gKHNlZzJbMF0gKyBzZWcyWzJdKSAqIDAuNTtcbiAgICBvdXRfdmVjMlsxXSA9IChzZWcyWzFdICsgc2VnMlszXSkgKiAwLjU7XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2xvcGUoc2VnMikge1xuICAgIHJldHVybiAoc2VnMlswXSAtIHNlZzJbMl0pIC8gKHNlZzJbMV0gLSBzZWcyWzNdKTtcbn1cbi8qKlxuICogQHBhcmFtIHtTZWdtZW50Mn0gc2VnMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBhbmdsZShzZWcyKSB7XG4gICAgcmV0dXJuIGF0YW4yKHNlZzJbM10gLSBzZWcyWzFdLCBzZWcyWzJdIC0gc2VnMlswXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBjcm9zcyhzZWcyLCB2ZWMyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIHJldHVybiAoc2VnMlswXSAtIHZlYzJbMF0pICogKHNlZzJbM10gLSB2ZWMyWzFdKSAtIChzZWcyWzFdIC0gdmVjMlsxXSkgKiAoc2VnMlsyXSAtIHZlYzJbMF0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGluZWFyKHNlZzIsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgcmV0dXJuIG5lYXIoKHNlZzJbMl0gLSBzZWcyWzBdKSAqICh2ZWMyWzFdIC0gdmVjMlsxXSksICh2ZWMyWzBdIC0gc2VnMlswXSkgKiAoc2VnMlszXSAtIHNlZzJbMV0pKTtcbn1cbi8qKlxuICogQHRvZG8gZG8gaXQhXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHBhcmFtIHtTZWdtZW50Mn0gc2VnMlxuICogQHBhcmFtIHtTZWdtZW50Mn0gc2VnMl8yXG4gKi9cbmZ1bmN0aW9uIGlzUGFyYWxsZWwoc2VnMiwgc2VnMl8yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidG9kb1wiKTtcbn1cbi8qKlxuICogQHBhcmFtIHtTZWdtZW50Mn0gc2VnMlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZlYzJJbnNpZGUoc2VnMiwgdmVjMikge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbiAgICByZXR1cm4gaXNDb2xsaW5lYXIoc2VnMiwgdmVjMikgJiYgd2l0aGluKHNlZzJbMF0sIHNlZzJbMV0sIHZlYzJbMF0sIHZlYzJbMV0sIHNlZzJbMl0sIHNlZzJbM10pO1xufVxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7TnVtYmVyPX0gY2FjaGVkX3NlZzJfbWluX2FuZ2xlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Fib3ZlKHNlZzIsIHZlYzIsIGNhY2hlZF9zZWcyX21pbl9hbmdsZSkge1xuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cbmlmIChjYWNoZWRfc2VnMl9taW5fYW5nbGUgIT09IHVuZGVmaW5lZCkge1xuaWYgKGNhY2hlZF9zZWcyX21pbl9hbmdsZSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNhY2hlZF9zZWcyX21pbl9hbmdsZSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjYWNoZWRfc2VnMl9taW5fYW5nbGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWNoZWRfc2VnMl9taW5fYW5nbGUgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxufVxuICAgIGF1eF92ZWMyWzBdID0gc2VnMlswXTtcbiAgICBhdXhfdmVjMlsxXSA9IHNlZzJbMV07XG4gICAgYW5nbGUgPSBWZWMyLmFuZ2xlVG8odmVjMiwgYXV4X3ZlYzIpO1xuXG4gICAgY2FjaGVkX3NlZzJfbWluX2FuZ2xlID0gY2FjaGVkX3NlZzJfbWluX2FuZ2xlIHx8IFNlZ21lbnQyLmFuZ2xlKHNlZzIpO1xuXG4gICAgaWYgKGNhY2hlZF9zZWcyX21pbl9hbmdsZSA+PSAwKSB7XG4gICAgICAgIGF1eCA9IGNhY2hlZF9zZWcyX21pbl9hbmdsZTtcbiAgICAgICAgY2FjaGVkX3NlZzJfbWluX2FuZ2xlID0gY2FjaGVkX3NlZzJfbWluX2FuZ2xlIC0gUEk7XG4gICAgICAgIGNhY2hlX3NlZzJfYW5nbGVfbWF4ID0gYXV4O1xuICAgICAgICByZXR1cm4gYW5nbGUgPiBjYWNoZWRfc2VnMl9taW5fYW5nbGUgJiYgYW5nbGUgPCBjYWNoZV9zZWcyX2FuZ2xlX21heDtcbiAgICB9XG5cbiAgICBjYWNoZV9zZWcyX2FuZ2xlX21heCA9IGNhY2hlZF9zZWcyX21pbl9hbmdsZSArIFBJO1xuXG4gICAgcmV0dXJuIGFuZ2xlIDwgY2FjaGVkX3NlZzJfbWluX2FuZ2xlIHx8IGFuZ2xlID4gY2FjaGVfc2VnMl9hbmdsZV9tYXg7XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7U2VnbWVudDJ9IHNlZzJcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIGxlZnROb3JtYWwob3V0X3ZlYzIsIHNlZzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IHNlZzJbMl0gLSBzZWcyWzBdO1xuICAgIG91dF92ZWMyWzFdID0gc2VnMlszXSAtIHNlZzJbMV07XG5cbiAgICB2ZWMyX3JvdGF0ZShvdXRfdmVjMiwgb3V0X3ZlYzIsIC1NYXRoLkhBTEZfUEkpO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1NlZ21lbnQyfSBzZWcyXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiByaWdodE5vcm1hbChvdXRfdmVjMiwgc2VnMikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gc2VnMlsyXSAtIHNlZzJbMF07XG4gICAgb3V0X3ZlYzJbMV0gPSBzZWcyWzNdIC0gc2VnMlsxXTtcblxuICAgIHZlYzJfcm90YXRlKG91dF92ZWMyLCBvdXRfdmVjMiwgTWF0aC5IQUxGX1BJKTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtTZWdtZW50Mn0gc2VnMlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBjbG9zZXN0UG9pbnQob3V0X3ZlYzIsIHNlZzIsIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2ZWMyKSB8fCB2ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzBdIHx8IHZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdmVjMlwiKVxufVxuXG4gICAgcmV0dXJuICRjbG9zZXN0UG9pbnQob3V0X3ZlYzIsIHNlZzJbMF0sIHNlZzJbMV0sIHNlZzJbMl0sIHNlZzJbM10sIHZlYzJbMF0sIHZlYzJbMV0pO1xufVxuXG4vKipcbiAqIEB0b2RvIG9wdGltaXplLCBcImlubGluZSB0aGUgaWYvZWxzZVwiXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge051bWJlcn0geDFcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gKiBAcGFyYW0ge051bWJlcn0geTJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4M1xuICogQHBhcmFtIHtOdW1iZXJ9IHkzXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiAkY2xvc2VzdFBvaW50KG91dF92ZWMyLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoeDEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHgyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgX194ID0geDIgLSB4MTtcbiAgICBfX3kgPSB5MiAtIHkxO1xuXG4gICAgdSA9ICgoeDMgLSB4MSkgKiBfX3ggKyAoeTMgLSB5MSkgKiBfX3kpIC8gKF9feCAqIF9feCArIF9feSAqIF9feSk7XG5cbiAgICBpZiAodSA+IDEpIHtcbiAgICAgICAgdSA9IDE7XG4gICAgfSBlbHNlIGlmICh1IDwgMCkge1xuICAgICAgICB1ID0gMDtcbiAgICB9XG5cbiAgICBvdXRfdmVjMlswXSA9ICh4MSArIHUgKiBfX3gpO1xuICAgIG91dF92ZWMyWzFdID0gKHkxICsgdSAqIF9feSk7XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHgxXG4gKiBAcGFyYW0ge051bWJlcn0geTFcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gKiBAcGFyYW0ge051bWJlcn0geDNcbiAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gJGNvbGxpbmVhcih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG5pZiAoeDEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHgyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgLy9zdHJpY3QgcmV0dXJuICh4MiAtIHgxKSAqICh5MyAtIHkxKSA9PT0gKHgzIC0geDEpICogKHkyIC0geTEpO1xuICAgIHJldHVybiBuZWFyKCh4MiAtIHgxKSAqICh5MyAtIHkxKSwgKHgzIC0geDEpICogKHkyIC0geTEpKTtcbn1cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHgxXG4gKiBAcGFyYW0ge051bWJlcn0geTFcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gKiBAcGFyYW0ge051bWJlcn0geDNcbiAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gJGluc2lkZSh4MSwgeDIsIHkxLCB5MiwgeDMsIHkzKSB7XG5pZiAoeDEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkxID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTEpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuICRjb2xsaW5lYXIoeDEsIHgyLCB5MSwgeTIsIHgzLCB5MykgJiYgd2l0aGluKHgxLCB4MiwgeDMsIHkzLCB5MSwgeTIpO1xufVxuXG4vKipcbiAqIEBjbGFzcyBTZWdtZW50MlxuICovXG52YXIgU2VnbWVudDIgPSAge1xuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICBjb3B5OiBjb3B5LFxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICAgIHRyYW5zbGF0ZTogdHJhbnNsYXRlLFxuICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgIHNxckxlbmd0aDogc3FyTGVuZ3RoLFxuICAgIG1pZFBvaW50OiBtaWRQb2ludCxcbiAgICBzbG9wZTogc2xvcGUsXG4gICAgYW5nbGU6IGFuZ2xlLFxuICAgIGNyb3NzOiBjcm9zcyxcbiAgICBjbG9zZXN0UG9pbnQ6IGNsb3Nlc3RQb2ludCxcbiAgICBpc0NvbGxpbmVhcjogaXNDb2xsaW5lYXIsXG4gICAgaXNQYXJhbGxlbDogaXNQYXJhbGxlbCxcbiAgICBpc1ZlYzJJbnNpZGU6IGlzVmVjMkluc2lkZSxcbiAgICBpc0Fib3ZlOiBpc0Fib3ZlLFxuICAgIGxlZnROb3JtYWw6IGxlZnROb3JtYWwsXG4gICAgcmlnaHROb3JtYWw6IHJpZ2h0Tm9ybWFsLFxuXG4gICAgLy8gYWxpYXNcbiAgICBsZW5ndGhTcTogc3FyTGVuZ3RoLFxuICAgIGNvbnRhaW5zOiBpc1ZlYzJJbnNpZGUsXG5cbiAgICAkaW5zaWRlOiAkaW5zaWRlLFxuICAgICRjb2xsaW5lYXI6ICRjb2xsaW5lYXIsXG4gICAgJGNsb3Nlc3RQb2ludDogJGNsb3Nlc3RQb2ludFxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlZ21lbnQyOyIsIi8qXG4gKiBTdGFiaWxpdHk6IDIgKGZpeGVzIC8gcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzKVxuICpcbiAqIEBUT0RPIGV4cGFuZCBhbGwgZnVuY3Rpb24sIGRvIG5vdCBnZW5lcmF0ZSB3aXRoIGxvb3BzXG4gKi9cblxudmFyIGFycmF5ID0gcmVxdWlyZShcImFycmF5LWVuaGFuY2VtZW50c1wiKSxcbiAgICBCZWl6ZXIgPSByZXF1aXJlKFwiLi9iZWl6ZXIuanNcIiksXG4gICAgYmVpemVyX2N1YmljID0gQmVpemVyLmN1YmljLFxuICAgIGJlaXplcl9xdWFkcmljID0gQmVpemVyLnF1YWRyaWMsXG4gICAgYmVpemVyX3NvbHZlID0gQmVpemVyLnNvbHZlLFxuICAgIHBvdyA9IE1hdGgucG93LFxuICAgIHNpbiA9IE1hdGguc2luLFxuICAgIGFjb3MgPSBNYXRoLmFjb3MsXG4gICAgY29zID0gTWF0aC5jb3MsXG4gICAgUEkgPSBNYXRoLlBJLFxuICAgIHQgPSB7fSxcbiAgICBrLFxuICAgIFRyYW5zaXRpb25zID0ge30sXG4gICAgQ0hBSU4gPSAxLFxuICAgIFNUT1AgPSAyLFxuICAgIElHTk9SRSA9IDMsXG4gICAgQ0FOQ0VMID0gNDtcblxuXG5mdW5jdGlvbiBjcmVhdGVDdWJpYyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5KSB7XG4gICAgdmFyIGN1cnZlID0gYmVpemVyX2N1YmljKDAsIDAsIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIDEsIDEpLFxuICAgICAgICBhdXggPSBbMCwgMF07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBiZWl6ZXJfc29sdmUoYXV4LCBjdXJ2ZSwgdCk7XG5cbiAgICAgICAgcmV0dXJuIGF1eFsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVF1YWRyaWMoY3AxeCwgY3AxeSkge1xuICAgIHZhciBjdXJ2ZSA9IGJlaXplcl9xdWFkcmljKDAsIDAsIGNwMXgsIGNwMXksIDEsIDEpLFxuICAgICAgICBhdXggPSBbMCwgMF07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBiZWl6ZXJfc29sdmUoYXV4LCBjdXJ2ZSwgdCk7XG5cbiAgICAgICAgcmV0dXJuIGF1eFsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFBvdyhwb3MsIHgpIHtcbiAgICByZXR1cm4gcG93KHBvcywgKHggJiYgeFswXSkgfHwgNik7XG59XG5cbmZ1bmN0aW9uIEV4cG8ocG9zKSB7XG4gICAgcmV0dXJuIHBvdygyLCA4ICogKHBvcyAtIDEpKTtcbn1cblxuZnVuY3Rpb24gQ2lyYyhwb3MpIHtcbiAgICByZXR1cm4gMSAtIHNpbihhY29zKHBvcykpO1xufVxuXG5mdW5jdGlvbiBTaW5lKHBvcykge1xuICAgIHJldHVybiAxIC0gY29zKHBvcyAqIFBJIC8gMik7XG59XG5cbmZ1bmN0aW9uIEJhY2socG9zLCB4KSB7XG4gICAgeCA9ICh4ICYmIHhbMF0pIHx8IDEuNjE4O1xuICAgIHJldHVybiBwb3cocG9zLCAyKSAqICgoeCArIDEpICogcG9zIC0geCk7XG59XG5cbmZ1bmN0aW9uIEJvdW5jZShwb3MpIHtcbiAgICB2YXIgdmFsdWUsIGEsIGI7XG4gICAgZm9yIChhID0gMCwgYiA9IDE7IHRydWU7IGEgKz0gYiwgYiAvPSAyKSB7XG4gICAgICAgIGlmIChwb3MgPj0gKDcgLSA0ICogYSkgLyAxMSkge1xuICAgICAgICAgICAgdmFsdWUgPSBiICogYiAtIHBvdygoMTEgLSA2ICogYSAtIDExICogcG9zKSAvIDQsIDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFbGFzdGljKHBvcywgeCkge1xuICAgIHJldHVybiBwb3coMiwgMTAgKiAtLXBvcykgKiBjb3MoMjAgKiBwb3MgKiBQSSAqICgoeCAmJiB4WzBdKSB8fCAxKSAvIDMpO1xufVxuXG5cblxuLyoqXG4gKiBKdXN0IHJldHVybiB3aGF0IHlvdSBzZW50XG4gKiBAcGFyYW0ge051bWJlcn0gcG9zXG4gKi9cbmZ1bmN0aW9uIGxpbmVhcihwb3MpIHtcbmlmIChwb3MgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihwb3MpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcG9zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicG9zIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gcG9zO1xufVxuXG4vKipcbiAqIFdyYXAgeW91ciB0cmFuc2FjdGlvbiB3aXRoIEluL091dC9Jbk91dCBtb2RpZmllcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNpdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGUobmFtZSwgdHJhbnNpdGlvbikge1xuaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiB0cmFuc2l0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNpdGlvbiBpcyBub3QgYSBmdW5jdGlvblwiKVxufVxuXG5cbiAgICAvL1RyYW5zaXRpb25zW25hbWVdID0gZnVuY3Rpb24gKHBvcykge1xuICAgIC8vICAgIHJldHVybiB0cmFuc2l0aW9uKHBvcyk7XG4gICAgLy99O1xuICAgIC8vVHJhbnNpdGlvbnNbbmFtZSArIFwiSW5cIl0gPSBUcmFuc2l0aW9uc1tuYW1lXTtcblxuICAgIFRyYW5zaXRpb25zW25hbWVdID0gdHJhbnNpdGlvbjtcblxuICAgIFRyYW5zaXRpb25zW25hbWUgKyBcIkluXCJdID0gdHJhbnNpdGlvbjtcblxuICAgIFRyYW5zaXRpb25zW25hbWUgKyBcIk91dFwiXSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIDEgLSB0cmFuc2l0aW9uKDEgLSBwb3MpO1xuICAgIH07XG5cbiAgICBUcmFuc2l0aW9uc1tuYW1lICsgXCJJbk91dFwiXSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIChwb3MgPD0gMC41ID8gdHJhbnNpdGlvbigyICogcG9zKSA6ICgyIC0gdHJhbnNpdGlvbigyICogKDEgLSBwb3MpKSkpIC8gMjtcbiAgICB9O1xufVxuXG50ID0ge1xuICAgIFBvdzogUG93LFxuICAgIEV4cG86IEV4cG8sXG4gICAgQ2lyYzogQ2lyYyxcbiAgICBTaW5lOiBTaW5lLFxuICAgIEJhY2s6IEJhY2ssXG4gICAgQm91bmNlOiBCb3VuY2UsXG4gICAgRWxhc3RpYzogRWxhc3RpY1xufTtcblxuZm9yIChrIGluIHQpIHtcbiAgICBjcmVhdGUoaywgdFtrXSk7XG59XG5cbltcIlF1YWRcIiwgXCJDdWJpY1wiLCBcIlF1YXJ0XCIsIFwiUXVpbnRcIl0uZm9yRWFjaChmdW5jdGlvbiAodHJhbnNpdGlvbiwgaSkge1xuICAgIGNyZWF0ZSh0cmFuc2l0aW9uLCBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcG93KHAsIGkgKyAyKTtcbiAgICB9KTtcbn0pO1xuXG4vLyB0d2VlbiBmdW5jdGlvblxuXG5mdW5jdGlvbiBfZGVmX3JlbmRlcihvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgb2JqW3Byb3BdID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9kZWZfcGFyc2VyKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KG9ialtwcm9wXSwgMTApO1xufVxuXG5mdW5jdGlvbiBfZGVmX2ZhY3RvcihrMCwgazEsIHJmYWN0b3IpIHtcbiAgICByZXR1cm4gKChrMSAtIGswKSAqIHJmYWN0b3IpICsgazA7XG59XG5cblRyYW5zaXRpb25zLkxJTktfQ0hBSU4gID0gQ0hBSU47XG5UcmFuc2l0aW9ucy5MSU5LX1NUT1AgICA9IFNUT1A7XG5UcmFuc2l0aW9ucy5MSU5LX0lHTk9SRSA9IElHTk9SRTtcblRyYW5zaXRpb25zLkxJTktfQ0FOQ0VMID0gQ0FOQ0VMO1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplKG9iaiwgaW5wdXQpIHtcbiAgICAvL2dldCBhbGwgcHJvcHNcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaW5wdXQpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHBhcnNlRmxvYXQoYSkgLSBwYXJzZUZsb2F0KGIpOyB9KSxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgcHJvcCxcbiAgICAgICAga2V5LFxuICAgICAgICBma2V5LFxuICAgICAgICBwcm9wX2xpc3QgPSBbXSxcbiAgICAgICAgcHJvcHMgPSB7fSxcbiAgICAgICAgbGFzdDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHByb3BfbGlzdCA9IGFycmF5LmFkZChwcm9wX2xpc3QsIE9iamVjdC5rZXlzKGlucHV0W2tleXNbaV1dKSk7XG4gICAgfVxuICAgIHByb3BfbGlzdCA9IGFycmF5LnVuaXF1ZShwcm9wX2xpc3QpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHByb3BfbGlzdC5sZW5ndGg7ICsraikge1xuICAgICAgICBwcm9wID0gcHJvcF9saXN0W2pdO1xuICAgICAgICBwcm9wc1twcm9wXSA9IHt9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgICBma2V5ID0gcGFyc2VGbG9hdChrZXlzW2ldKTtcblxuICAgICAgICAgICAgLy8gZmlyc3Qgb2YgdGhlIHNvcnRlZCBsaXN0IGFuZCBpcyBub3QgMCVcbiAgICAgICAgICAgIC8vIHNldCBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBrZXkgIT09IFwiMCVcIikge1xuICAgICAgICAgICAgICAgIHByb3BzW3Byb3BdWzBdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5wdXRba2V5XVtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNbcHJvcF1bZmtleV0gPSBsYXN0ID0gaW5wdXRba2V5XVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIHRoYXQgaGFzIDEwMCUgaWYgbm90IHNldCB0aGUgbGFzdCBrbm93biB2YWx1ZVxuICAgICAgICBpZiAocHJvcHNbcHJvcF1bXCIxMDBcIl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvcHNbcHJvcF1bMTAwXSA9IGxhc3Q7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbn1cblxuLyoqXG4gKiBBbmltYXRlIG9iamVjdCBwcm9wZXJ0aWVzLlxuICpcbiAqICpvYmoqIG11c3QgYmUgd3JpdGFibGUgb3IgYXQgbGVhc3QgaGF2ZSBkZWZpbmVkICRfX3R3ZWVuXG4gKiAqcHJvcCogcHJvcGVydHkgbmFtZSB0byBhbmltYXRlXG4gKiAqdmFsdWVzKiBrZXlzIGFyZSBudW1iZXJzIGZyb20gMCB0byAxMDAsIHZhbHVlcyBjb3VsZCBiZSBhbnl0aGluZ1xuICogKmlvcHRpb25zKlxuICogKiptYW5kYXRvcnkqKlxuICogICAqICoqdGltZSoqOiA8bnVtYmVyPiBpbiBtc1xuICpcbiAqICoqb3B0aW9uYWwqKlxuICogICAqICoqdHJhbnNpdGlvbioqIFRyYW5zaXRpb24uWFhYLCBvciBhIHZhbGlkIGNvbXBhdGlibGUgZnVuY3Rpb24gRGVmYXVsdDogbGluZWFyXG4gKiAgICogKipsaW5rKiogVHJhbnNpdGlvbi5MSU5LX1hYWCBEZWZhdWx0OiBDSEFJTlxuICogICAqICoqcmVuZGVyKiogZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSwgbmV3X3ZhbHVlKSB7fVxuICogICAqICoqcGFyc2VyKiogZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSkgeyByZXR1cm4gPHZhbHVlPjsgfVxuICogICAqICoqdGlja0V2ZW50KiogPHN0cmluZz4gZXZlbnQgbmFtZSBEZWZhdWx0OiBcInRpY2tcIlxuICogICAqICoqZW5kRXZlbnQqKiA8c3RyaW5nPiBldmVudCBuYW1lIERlZmF1bHQ6IFwiYW5pbWF0aW9uOmVuZFwiXG4gKiAgICogKipzdGFydEV2ZW50KiogPHN0cmluZz4gZXZlbnQgbmFtZSBEZWZhdWx0OiBcImFuaW1hdGlvbjpzdGFyXCJcbiAqICAgKiAqKmNoYWluRXZlbnQqKiA8c3RyaW5nPiBldmVudCBuYW1lIERlZmF1bHQ6IFwiYW5pbWF0aW9uOmNoYWluXCJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHByb3BcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSB2YWx1ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBpb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhbmltYXRlKG9iaiwgcHJvcCwgdmFsdWVzLCBpb3B0aW9ucykge1xuaWYgKCdvYmplY3QnICE9PSB0eXBlb2Ygb2JqIHx8IEFycmF5LmlzQXJyYXkob2JqKSB8fCBvYmogPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmogaXMgbm90IGEgb2JqZWN0XCIpXG59XG5cbmlmICghKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcCkgJiYgIShwcm9wID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocHJvcCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBwcm9wKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInByb3AgaXMgdW5kZWZpbmVkIG9yIG51bGwgT1IgcHJvcCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoISghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSAmJiAhKCdvYmplY3QnICE9PSB0eXBlb2YgdmFsdWVzIHx8IEFycmF5LmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMgPT09IG51bGwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIGlzIG5vdCBhIGFycmF5IE9SIHZhbHVlcyBpcyBub3QgYSBvYmplY3RcIilcbn1cblxuaWYgKCdvYmplY3QnICE9PSB0eXBlb2YgaW9wdGlvbnMgfHwgQXJyYXkuaXNBcnJheShpb3B0aW9ucykgfHwgaW9wdGlvbnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpb3B0aW9ucyBpcyBub3QgYSBvYmplY3RcIilcbn1cblxuICAgIC8vIGxhenkgaW5pdFxuICAgIG9iai4kX190d2VlbiA9IG9iai4kX190d2VlbiB8fCB7fTtcblxuICAgIC8vY29uc29sZS5sb2coXCJvcHRpb25zXCIsIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpLCBKU09OLnN0cmluZ2lmeSh2YWx1ZXMpKTtcbiAgICAvLyA8ZGVidWc+XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5vbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmogbXVzdCBiZSBhbiBldmVudC1lbWl0dGVyXCIpO1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iaiBtdXN0IGJlIGFuIGV2ZW50LWVtaXR0ZXJcIik7XG4gICAgfVxuICAgIGlmIChcIm51bWJlclwiICE9PSB0eXBlb2YgaW9wdGlvbnMudGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLnRpbWUgaXMgbWFuZGF0b3J5XCIpO1xuICAgIH1cbiAgICAvLyA8L2RlYnVnPlxuXG4gICAgICAgIC8vc29mdCBjbG9uZSBhbmQgZGVmYXVsdHNcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlbmRlcjogaW9wdGlvbnMucmVuZGVyIHx8IF9kZWZfcmVuZGVyLFxuICAgICAgICAgICAgcGFyc2VyOiBpb3B0aW9ucy5wYXJzZXIgfHwgX2RlZl9wYXJzZXIsXG4gICAgICAgICAgICBhcHBseUZhY3RvcjogaW9wdGlvbnMuYXBwbHlGYWN0b3IgfHwgX2RlZl9mYWN0b3IsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBpb3B0aW9ucy50cmFuc2l0aW9uIHx8IFRyYW5zaXRpb25zLmxpbmVhcixcbiAgICAgICAgICAgIGxpbms6IGlvcHRpb25zLmxpbmsgfHwgQ0hBSU4sXG4gICAgICAgICAgICB0aWNrRXZlbnQ6IGlvcHRpb25zLnRpY2tFdmVudCB8fCBcInRpY2tcIixcbiAgICAgICAgICAgIGVuZEV2ZW50OiBpb3B0aW9ucy5lbmRFdmVudCB8fCBcImFuaW1hdGlvbjplbmRcIixcbiAgICAgICAgICAgIHN0YXJ0RXZlbnQ6IGlvcHRpb25zLnN0YXJ0RXZlbnQgfHwgXCJhbmltYXRpb246c3RhcnRcIiwgLy8gZmlyc3QgZW1pdFxuICAgICAgICAgICAgY2hhaW5FdmVudDogaW9wdGlvbnMuY2hhaW5FdmVudCB8fCBcImFuaW1hdGlvbjpjaGFpblwiLFxuICAgICAgICAgICAgdGltZTogaW9wdGlvbnMudGltZSxcbiAgICAgICAgICAgIHN0YXJ0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgY3VycmVudDogMFxuICAgICAgICB9LFxuICAgICAgICBjaGFpbl9mbixcbiAgICAgICAga3ZhbHVlcyA9IE9iamVjdC5rZXlzKHZhbHVlcyksXG4gICAgICAgIGZ2YWx1ZXMgPSBrdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBwYXJzZUZsb2F0KHZhbCkgKiAwLjAxOyB9KSxcbiAgICAgICAgdXBkYXRlX2ZuO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIm9wdGlvbnNcIiwgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyksIEpTT04uc3RyaW5naWZ5KHZhbHVlcykpO1xuXG4gICAgdXBkYXRlX2ZuID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2cocHJvcCwgXCJ0d2VlbiBAXCIsIGRlbHRhLCBvcHRpb25zLCB2YWx1ZXMpO1xuICAgICAgICBpZiAoIWRlbHRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFjZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmN1cnJlbnQgKz0gZGVsdGE7XG5cblxuXG4gICAgICAgIHZhciBmYWN0b3IgPSBvcHRpb25zLmN1cnJlbnQgLyBvcHRpb25zLnRpbWUsXG4gICAgICAgICAgICB0cl9mYWN0b3IsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgICAgIG1heCA9IGt2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgazAsXG4gICAgICAgICAgICBrMSxcbiAgICAgICAgICAgIHJmYWN0b3I7XG5cbiAgICAgICAgLy9jbGFtcFxuICAgICAgICBpZiAoZmFjdG9yID4gMSkgeyAvLyBlbmRcbiAgICAgICAgICAgIGZhY3RvciA9IDE7XG4gICAgICAgICAgICB0cl9mYWN0b3IgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJfZmFjdG9yID0gb3B0aW9ucy50cmFuc2l0aW9uKGZhY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWF4ICYmICFmb3VuZDsgKytpKSB7XG4gICAgICAgICAgICBrMCA9IGZ2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAoazAgPD0gdHJfZmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IG1heCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgazAgPSBmdmFsdWVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgazEgPSBmdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGsxID0gZnZhbHVlc1tpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGsxID4gdHJfZmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHByb3AsIFwia29cIiwgazAsIFwiazFcIiwgazEpO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHByb3AsIHRyX2ZhY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyX2ZhY3RvciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIob2JqLCBwcm9wLCB2YWx1ZXNbXCIxMDBcIl0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQsIG15IG9ubHkgZnJpZW5kLCB0aGUgZW5kLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlTGlzdGVuZXIob3B0aW9ucy50aWNrRXZlbnQsIG9iai4kX190d2Vlbltwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqLiRfX3R3ZWVuW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmVtaXQob3B0aW9ucy5lbmRFdmVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZmFjdG9yID0gKHRyX2ZhY3RvciAtIGswKSAvIChrMSAtIGswKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocHJvcCwgaSwgcmZhY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocHJvcCwgcmZhY3RvciwgXCJrMFwiLCB2YWx1ZXNbazBdLCBcImsxXCIsIHZhbHVlc1trMV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlbmRlcihvYmosIHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hcHBseUZhY3Rvcih2YWx1ZXNba3ZhbHVlc1tpXV0sIHZhbHVlc1trdmFsdWVzW2kgKyAxXV0sIHJmYWN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob2JqLiRfX3R3ZWVuW3Byb3BdKSB7XG4gICAgICAgIC8vIGxpbmsgd2lsbCB0b2xkIHVzIHdoYXQgdG8gZG8hXG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5saW5rKSB7XG4gICAgICAgIGNhc2UgSUdOT1JFOlxuICAgICAgICAgICAgcmV0dXJuIElHTk9SRTtcbiAgICAgICAgY2FzZSBDSEFJTjpcblxuICAgICAgICAgICAgY2hhaW5fZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmouJF9fdHdlZW5bcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfX3R3ZWVuW3Byb3BdID0gdXBkYXRlX2ZuO1xuICAgICAgICAgICAgICAgICAgICBvYmoub24ob3B0aW9ucy50aWNrRXZlbnQsIG9iai4kX190d2Vlbltwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihvcHRpb25zLmVuZEV2ZW50LCBjaGFpbl9mbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb2JqLm9uKG9wdGlvbnMuZW5kRXZlbnQsIGNoYWluX2ZuKTtcbiAgICAgICAgICAgIG9iai5lbWl0KG9wdGlvbnMuY2hhaW5FdmVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiBDSEFJTjtcbiAgICAgICAgY2FzZSBTVE9QOlxuICAgICAgICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKG9wdGlvbnMudGlja0V2ZW50LCBvYmouJF9fdHdlZW5bcHJvcF0pO1xuICAgICAgICAgICAgZGVsZXRlIG9iai4kX190d2Vlbltwcm9wXTtcblxuICAgICAgICAgICAgcmV0dXJuIFNUT1A7XG4gICAgICAgIGNhc2UgQ0FOQ0VMOlxuICAgICAgICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKG9wdGlvbnMudGlja0V2ZW50LCBvYmouJF9fdHdlZW5bcHJvcF0pO1xuICAgICAgICAgICAgZGVsZXRlIG9iai4kX190d2Vlbltwcm9wXTtcbiAgICAgICAgICAgIC8vIGFuZCBhdHRhY2ghXG5cbiAgICAgICAgICAgIG9iai4kX190d2Vlbltwcm9wXSA9IHVwZGF0ZV9mbjtcbiAgICAgICAgICAgIG9iai5vbihvcHRpb25zLnRpY2tFdmVudCwgb2JqLiRfX3R3ZWVuW3Byb3BdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqLiRfX3R3ZWVuW3Byb3BdID0gdXBkYXRlX2ZuO1xuICAgICAgICBvYmoub24ob3B0aW9ucy50aWNrRXZlbnQsIG9iai4kX190d2Vlbltwcm9wXSk7XG4gICAgfVxuXG5cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHR3ZWVuKG9iaiwgcGFyYW1zLCBvcHRpb25zKSB7XG5pZiAoJ29iamVjdCcgIT09IHR5cGVvZiBvYmogfHwgQXJyYXkuaXNBcnJheShvYmopIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm9iaiBpcyBub3QgYSBvYmplY3RcIilcbn1cblxuaWYgKCdvYmplY3QnICE9PSB0eXBlb2YgcGFyYW1zIHx8IEFycmF5LmlzQXJyYXkocGFyYW1zKSB8fCBwYXJhbXMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXJhbXMgaXMgbm90IGEgb2JqZWN0XCIpXG59XG5cbmlmICgnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucyBpcyBub3QgYSBvYmplY3RcIilcbn1cblxuICAgIC8vIDxkZWJ1Zz5cbiAgICBpZiAoIXBhcmFtcy5oYXNPd25Qcm9wZXJ0eShcIjEwMCVcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiMTAwJSBwYXJhbXMgbXVzdCBleGlzdHNcIik7XG4gICAgfVxuXG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5vbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmogbXVzdCBiZSBhbiBldmVudC1lbWl0dGVyXCIpO1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iaiBtdXN0IGJlIGFuIGV2ZW50LWVtaXR0ZXJcIik7XG4gICAgfVxuICAgIGlmIChcIm51bWJlclwiICE9PSB0eXBlb2Ygb3B0aW9ucy50aW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMudGltZSBpcyBtYW5kYXRvcnlcIik7XG4gICAgfVxuICAgIC8vIDwvZGVidWc+XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBzZXQgZGVmYXVsdHNcbiAgICBvcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyIHx8IF9kZWZfcmVuZGVyO1xuICAgIG9wdGlvbnMucGFyc2VyID0gb3B0aW9ucy5wYXJzZXIgfHwgX2RlZl9wYXJzZXI7XG4gICAgb3B0aW9ucy50cmFuc2l0aW9uID0gb3B0aW9ucy50cmFuc2l0aW9uIHx8IFRyYW5zaXRpb25zLmxpbmVhcjtcbiAgICBvcHRpb25zLmxpbmsgPSBvcHRpb25zLmxpbmsgfHwgQ0hBSU47XG4gICAgb3B0aW9ucy50aWNrID0gb3B0aW9ucy50aWNrIHx8IFwidGlja1wiO1xuXG4gICAgLy8gc2V0IGNvbmZpZ1xuICAgIG9iai4kX190d2VlbiA9IG9iai4kX190d2VlbiB8fCB7fTtcblxuICAgIHZhciBwbGlzdCA9IF9ub3JtYWxpemUob2JqLCBwYXJhbXMpLFxuICAgICAgICBpO1xuXG4gICAgLy8gYW5pbWF0ZSBlYWNoIHByb3BlcnR5XG4gICAgZm9yIChpIGluIHBsaXN0KSB7XG4gICAgICAgIFRyYW5zaXRpb25zLmFuaW1hdGUob2JqLCBpLCBwbGlzdFtpXSwgb3B0aW9ucyk7XG4gICAgfVxuXG59XG5cblxuVHJhbnNpdGlvbnMudHdlZW4gPSB0d2VlbjtcblRyYW5zaXRpb25zLmFuaW1hdGUgPSBhbmltYXRlO1xuVHJhbnNpdGlvbnMubGluZWFyID0gbGluZWFyO1xuVHJhbnNpdGlvbnMuY3JlYXRlID0gY3JlYXRlO1xuXG5UcmFuc2l0aW9ucy5jcmVhdGVDdWJpYyA9IGNyZWF0ZUN1YmljO1xuVHJhbnNpdGlvbnMuY3JlYXRlUXVhZHJpYyA9IGNyZWF0ZVF1YWRyaWM7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbnM7IiwiLyoqXG4gKiBTdGFiaWxpdHk6IDIgKGZpeGVzIC8gcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzKVxuICpcbiAqIFRyaWFuZ2xlIGlzIHJlcHJlc2VudGVkIGFzIGEgdGhyZWUgY29vcmRpbmF0ZXMgYXJyYXlcbiAqIFtBOlZlYzIsIEI6VmVjMiwgQzpWZWMyXVxuICovXG5cblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi92ZWMyLmpzXCIpLFxuICAgIHZlYzJfbWlkcG9pbnQgPSBWZWMyLm1pZFBvaW50LFxuICAgIHZlYzJfZGlzdGFuY2UgPSBWZWMyLmRpc3RhbmNlLFxuICAgIHZlYzJfcG93ID0gVmVjMi5wb3csXG4gICAgdmVjMl9kb3QgPSBWZWMyLmRvdCxcbiAgICBESVYzID0gMSAvIDMsXG4gICAgYWggPSBbMCwgMF0sXG4gICAgYmggPSBbMCwgMF0sXG4gICAgY2ggPSBbMCwgMF0sXG4gICAgZGFiID0gWzAsIDBdLFxuICAgIGRiYyA9IFswLCAwXSxcbiAgICBkY2EgPSBbMCwgMF0sXG4gICAgZGV0ID0gMCxcbiAgICBhID0gMCxcbiAgICBiID0gMCxcbiAgICBjID0gMDtcbi8qKlxuICogQSh4MSwgeTEpLCBCKHgyLCB5MiksIEMoeDMsIHkzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHgxXG4gKiBAcGFyYW0ge051bWJlcn0geTFcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gKiBAcGFyYW0ge051bWJlcn0geDNcbiAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICogQHJldHVybiB7VHJpYW5nbGV9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG5pZiAoeDEgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngxIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHgyID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeDIpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4MiBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeTIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh4MyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgzKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgdmFyIG91dCA9IFtbeDEsIHkxXSwgW3gyLCB5Ml0sIFt4MywgeTNdLCBmYWxzZV07XG5cbiAgICAvL25vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQHJldHVybiB7VHJpYW5nbGV9XG4gKi9cbmZ1bmN0aW9uIHplcm8oKSB7XG4gICAgcmV0dXJuIFtbMCwgMF0sIFswLCAwXSwgWzAsIDBdLCB0cnVlXTtcbn1cbi8qKlxuICogQHBhcmFtIHtUcmlhbmdsZX0gdHJpXG4gKiBAcmV0dXJuIHtUcmlhbmdsZX1cbiAqL1xuZnVuY3Rpb24gY2xvbmUodHJpKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodHJpKSB8fCB0cmlbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzBdIHx8IHRyaVswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMF1bMV0gfHwgdHJpWzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVswXSB8fCB0cmlbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzFdWzFdIHx8IHRyaVsyXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMF0gfHwgdHJpWzJdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzJdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsyXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVHJhaW5nbGUgdHJpXCIpXG59XG5cbiAgICByZXR1cm4gW1t0cmlbMF1bMF0sIHRyaVswXVsxXV0sIFt0cmlbMV1bMF0sIHRyaVsxXVsxXV0sIFt0cmlbMl1bMF0sIHRyaVsyXVsxXV0sIHRyaVszXV07XG59XG4vKipcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IG91dF90cmlcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHRyaVxuICogQHJldHVybiB7VHJpYW5nbGV9XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0X3RyaSwgdHJpKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3RyaSkgfHwgb3V0X3RyaVswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF90cmlbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3RyaVswXVswXSB8fCBvdXRfdHJpWzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3RyaVswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdHJpWzBdWzFdIHx8IG91dF90cmlbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdHJpWzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF90cmlbMV1bMF0gfHwgb3V0X3RyaVsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF90cmlbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3RyaVsxXVsxXSB8fCBvdXRfdHJpWzJdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3RyaVsyXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdHJpWzJdWzBdIHx8IG91dF90cmlbMl1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdHJpWzJdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF90cmlbMl1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRyYWluZ2xlIG91dF90cmlcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHRyaSkgfHwgdHJpWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVswXSB8fCB0cmlbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzFdIHx8IHRyaVsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMF0gfHwgdHJpWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVsxXSB8fCB0cmlbMl1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzBdIHx8IHRyaVsyXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRyYWluZ2xlIHRyaVwiKVxufVxuXG4gICAgb3V0X3RyaVswXVswXSA9IHRyaVswXVswXTtcbiAgICBvdXRfdHJpWzBdWzFdID0gdHJpWzBdWzFdO1xuXG4gICAgb3V0X3RyaVsxXVswXSA9IHRyaVsxXVswXTtcbiAgICBvdXRfdHJpWzFdWzFdID0gdHJpWzFdWzFdO1xuXG4gICAgb3V0X3RyaVsyXVswXSA9IHRyaVsyXVswXTtcbiAgICBvdXRfdHJpWzJdWzFdID0gdHJpWzJdWzFdO1xuXG4gICAgb3V0X3RyaVszXSA9IHRyaVszXTtcblxuICAgIHJldHVybiBvdXRfdHJpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHRyaVxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gYWJNaWRQb2ludChvdXRfdmVjMiwgdHJpKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodHJpKSB8fCB0cmlbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzBdIHx8IHRyaVswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMF1bMV0gfHwgdHJpWzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVswXSB8fCB0cmlbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzFdWzFdIHx8IHRyaVsyXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMF0gfHwgdHJpWzJdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzJdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsyXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVHJhaW5nbGUgdHJpXCIpXG59XG5cbiAgICByZXR1cm4gdmVjMl9taWRwb2ludChvdXRfdmVjMiwgdHJpWzBdLCB0cmlbMV0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1RyaWFuZ2xlfSB0cmlcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIGJjTWlkUG9pbnQob3V0X3ZlYzIsIHRyaSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHRyaSkgfHwgdHJpWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVswXSB8fCB0cmlbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzFdIHx8IHRyaVsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMF0gfHwgdHJpWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVsxXSB8fCB0cmlbMl1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzBdIHx8IHRyaVsyXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRyYWluZ2xlIHRyaVwiKVxufVxuXG4gICAgcmV0dXJuIHZlYzJfbWlkcG9pbnQob3V0X3ZlYzIsIHRyaVsxXSwgdHJpWzJdKTtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtUcmlhbmdsZX0gdHJpXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBjYU1pZFBvaW50KG91dF92ZWMyLCB0cmkpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh0cmkpIHx8IHRyaVswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMF1bMF0gfHwgdHJpWzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVsxXSB8fCB0cmlbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzFdWzBdIHx8IHRyaVsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMV0gfHwgdHJpWzJdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzJdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsyXVswXSB8fCB0cmlbMl1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBUcmFpbmdsZSB0cmlcIilcbn1cblxuICAgIHJldHVybiB2ZWMyX21pZHBvaW50KG91dF92ZWMyLCB0cmlbMl0sIHRyaVswXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IG91dFxuICogQHBhcmFtIHtUcmlhbmdsZX0gdHJpXG4gKiBAcmV0dXJuIHtUcmlhbmdsZX1cbiAqL1xuZnVuY3Rpb24gbWlkVHJpYW5nbGUob3V0LCB0cmkpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF1bMF0gfHwgb3V0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXVsxXSB8fCBvdXRbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdWzBdIHx8IG91dFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV1bMV0gfHwgb3V0WzJdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXVswXSB8fCBvdXRbMl1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMl1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzJdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBUcmFpbmdsZSBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHRyaSkgfHwgdHJpWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVswXSB8fCB0cmlbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzFdIHx8IHRyaVsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMF0gfHwgdHJpWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVsxXSB8fCB0cmlbMl1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzBdIHx8IHRyaVsyXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRyYWluZ2xlIHRyaVwiKVxufVxuXG4gICAgYWJNaWRQb2ludChvdXRbMF0sIHRyaSk7XG4gICAgYmNNaWRQb2ludChvdXRbMV0sIHRyaSk7XG4gICAgY2FNaWRQb2ludChvdXRbMl0sIHRyaSk7XG5cbiAgICByZXR1cm4gb3V0O1xuXG59XG4vKipcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHRyaVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBwZXJpbWV0ZXIodHJpKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodHJpKSB8fCB0cmlbMF1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzBdIHx8IHRyaVswXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVswXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMF1bMV0gfHwgdHJpWzFdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVswXSB8fCB0cmlbMV1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMV1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzFdWzFdIHx8IHRyaVsyXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMF0gfHwgdHJpWzJdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzJdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsyXVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVHJhaW5nbGUgdHJpXCIpXG59XG5cbiAgICByZXR1cm4gdmVjMl9kaXN0YW5jZSh0cmlbMF0sIHRyaVsxXSkgK1xuICAgICAgICB2ZWMyX2Rpc3RhbmNlKHRyaVsxXSwgdHJpWzJdKSArXG4gICAgICAgIHZlYzJfZGlzdGFuY2UodHJpWzJdLCB0cmlbMF0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHRyaVxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gY2VudHJvaWQob3V0X3ZlYzIsIHRyaSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHRyaSkgfHwgdHJpWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVswXSB8fCB0cmlbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzFdIHx8IHRyaVsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMF0gfHwgdHJpWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVsxXSB8fCB0cmlbMl1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzBdIHx8IHRyaVsyXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRyYWluZ2xlIHRyaVwiKVxufVxuXG4gICAgb3V0X3ZlYzJbMF0gPSAodHJpWzBdWzBdICsgdHJpWzFdWzBdICsgdHJpWzJdWzBdKSAqIERJVjM7XG4gICAgb3V0X3ZlYzJbMV0gPSAodHJpWzBdWzFdICsgdHJpWzFdWzFdICsgdHJpWzJdWzFdKSAqIERJVjM7XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHRyaVxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gaW5jZW50ZXIob3V0X3ZlYzIsIHRyaSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHRyaSkgfHwgdHJpWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVswXSB8fCB0cmlbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzFdIHx8IHRyaVsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMF0gfHwgdHJpWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVsxXSB8fCB0cmlbMl1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzBdIHx8IHRyaVsyXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRyYWluZ2xlIHRyaVwiKVxufVxuXG4gICAgYSA9IFZlYzIuZGlzdGFuY2UodHJpWzFdLCB0cmlbMl0pO1xuICAgIGIgPSBWZWMyLmRpc3RhbmNlKHRyaVsyXSwgdHJpWzBdKTtcbiAgICBjID0gVmVjMi5kaXN0YW5jZSh0cmlbMF0sIHRyaVsxXSk7XG5cbiAgICBvdXRfdmVjMlswXSA9IChhICogdHJpWzBdWzBdICsgYiAqIHRyaVsxXVswXSArIGMgKiB0cmlbMl1bMF0pICogRElWMztcbiAgICBvdXRfdmVjMlsxXSA9IChhICogdHJpWzBdWzFdICsgYiAqIHRyaVsxXVsxXSArIGMgKiB0cmlbMl1bMV0pICogRElWMztcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtUcmlhbmdsZX0gdHJpXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBjaXJjdW1jZW50ZXIob3V0X3ZlYzIsIHRyaSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHRyaSkgfHwgdHJpWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVswXSB8fCB0cmlbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzFdIHx8IHRyaVsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMF0gfHwgdHJpWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVsxXSB8fCB0cmlbMl1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzBdIHx8IHRyaVsyXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRyYWluZ2xlIHRyaVwiKVxufVxuXG4gICAgdmFyIGJ4ID0gdHJpWzFdWzBdIC0gdHJpWzBdWzBdLFxuICAgICAgICBieSA9IHRyaVsxXVsxXSAtIHRyaVswXVsxXSxcbiAgICAgICAgYmwgPSBieCAqIGJ4ICsgYnkgKiBieSxcbiAgICAgICAgY3ggPSB0cmlbMl1bMF0gLSB0cmlbMF1bMF0sXG4gICAgICAgIGN5ID0gdHJpWzJdWzFdIC0gdHJpWzBdWzFdLFxuICAgICAgICBjbCA9IGN4ICogY3ggKyBjeSAqIGN5LFxuICAgICAgICBkID0gMiAqIChieCAqIGN5IC0gYnkgKiBjeCksXG4gICAgICAgIHggPSBjeSAqIGJsIC0gYnkgKiBjbCxcbiAgICAgICAgeSA9IGJ4ICogY2wgLSBjeCAqIGJsO1xuXG4gICAgb3V0X3ZlYzJbMF0gPSB4IC8gZCArIHRyaVswXVswXTtcbiAgICBvdXRfdmVjMlsxXSA9IHkgLyBkICsgdHJpWzBdWzFdO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge1RyaWFuZ2xlfSB0cmlcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gYXJlYSh0cmkpIHtcbmlmICghQXJyYXkuaXNBcnJheSh0cmkpIHx8IHRyaVswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMF1bMF0gfHwgdHJpWzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVsxXSB8fCB0cmlbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzFdWzBdIHx8IHRyaVsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMV0gfHwgdHJpWzJdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzJdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsyXVswXSB8fCB0cmlbMl1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBUcmFpbmdsZSB0cmlcIilcbn1cblxuICAgIGRhYiA9IFZlYzIubWluKGRiYywgdHJpWzFdLCB0cmlbMF0pO1xuICAgIGRiYyA9IFZlYzIubWluKGRiYywgdHJpWzJdLCB0cmlbMF0pO1xuXG4gICAgcmV0dXJuIChkYmNbMV0gKiBkYWJbMF0gLSBkYmNbMF0gKiBkYWJbMV0pICogMC41O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IG91dFxuICogQHBhcmFtIHtUcmlhbmdsZX0gdHJpXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEByZXR1cm4ge1RyaWFuZ2xlfVxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCB0cmksIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXQpIHx8IG91dFswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMF1bMF0gfHwgb3V0WzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFswXVsxXSB8fCBvdXRbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzFdWzBdIHx8IG91dFsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dFsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRbMV1bMV0gfHwgb3V0WzJdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0WzJdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dFsyXVswXSB8fCBvdXRbMl1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRbMl1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0WzJdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBUcmFpbmdsZSBvdXRcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHRyaSkgfHwgdHJpWzBdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVswXSB8fCB0cmlbMF1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMF1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzBdWzFdIHx8IHRyaVsxXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMF0gfHwgdHJpWzFdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzFdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsxXVsxXSB8fCB0cmlbMl1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzBdIHx8IHRyaVsyXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsyXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMl1bMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFRyYWluZ2xlIHRyaVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIG91dFswXVswXSA9IHRyaVswXVswXSArIHZlYzJbMF07XG4gICAgb3V0WzBdWzFdID0gdHJpWzBdWzFdICsgdmVjMlsxXTtcblxuICAgIG91dFsxXVswXSA9IHRyaVsxXVswXSArIHZlYzJbMF07XG4gICAgb3V0WzFdWzFdID0gdHJpWzFdWzFdICsgdmVjMlsxXTtcblxuICAgIG91dFsyXVswXSA9IHRyaVsyXVswXSArIHZlYzJbMF07XG4gICAgb3V0WzJdWzFdID0gdHJpWzJdWzFdICsgdmVjMlsxXTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbnZhciBhYyA9IFswLCAwXSxcbiAgICBhYiA9IFswLCAwXSxcbiAgICBhdiA9IFswLCAwXSxcbiAgICBkb3QwMCxcbiAgICBkb3QwMSxcbiAgICBkb3QwMixcbiAgICBkb3QxMSxcbiAgICBkb3QxMixcbiAgICBpbnZEZW5vbSxcbiAgICB1LFxuICAgIHY7XG5cbi8qKlxuICogQHBhcmFtIHtUcmlhbmdsZX0gdHJpXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmVjMkluc2lkZSh0cmksIHZlYzIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh0cmkpIHx8IHRyaVswXVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVswXVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMF1bMF0gfHwgdHJpWzBdWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzBdWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVswXVsxXSB8fCB0cmlbMV1bMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMV1bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzFdWzBdIHx8IHRyaVsxXVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHRyaVsxXVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB0cmlbMV1bMV0gfHwgdHJpWzJdWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odHJpWzJdWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHRyaVsyXVswXSB8fCB0cmlbMl1bMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0cmlbMl1bMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdHJpWzJdWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBUcmFpbmdsZSB0cmlcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHZlYzIpIHx8IHZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHZlYzJbMF0gfHwgdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2ZWMyXCIpXG59XG5cblxuICAgIC8vIENvbXB1dGUgdmVjdG9yc1xuICAgIC8vIGFjID0gQyAtIEFcbiAgICBWZWMyLnN1YihhYywgdHJpWzJdLCB0cmlbMF0pO1xuICAgIC8vIGFiID0gQiAtIEFcbiAgICBWZWMyLnN1YihhYiwgdHJpWzFdLCB0cmlbMF0pO1xuICAgIC8vIGF2ID0gUCAtIEFcbiAgICBWZWMyLnN1YihhdiwgdmVjMiwgdHJpWzBdKTtcblxuICAgIC8vIENvbXB1dGUgZG90IHByb2R1Y3RzXG4gICAgZG90MDAgPSB2ZWMyX2RvdChhYywgYWMpXG4gICAgZG90MDEgPSB2ZWMyX2RvdChhYywgYWIpXG4gICAgZG90MDIgPSB2ZWMyX2RvdChhYywgYXYpXG4gICAgZG90MTEgPSB2ZWMyX2RvdChhYiwgYWIpXG4gICAgZG90MTIgPSB2ZWMyX2RvdChhYiwgYXYpXG5cbiAgICAvLyBDb21wdXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXG4gICAgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKVxuICAgIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub21cbiAgICB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tXG5cbiAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbiB0cmlhbmdsZVxuICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcbn1cblxuLyoqXG4gKiBAY2xhc3MgVHJpYW5nbGVcbiAqL1xudmFyIFRyaWFuZ2xlID0ge1xuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIHplcm86IHplcm8sXG4gICAgY2xvbmU6IGNsb25lLFxuICAgIGNvcHk6IGNvcHksXG5cbiAgICBhYk1pZFBvaW50OiBhYk1pZFBvaW50LFxuICAgIGJjTWlkUG9pbnQ6IGJjTWlkUG9pbnQsXG4gICAgY2FNaWRQb2ludDogY2FNaWRQb2ludCxcbiAgICBtaWRUcmlhbmdsZTogbWlkVHJpYW5nbGUsXG5cbiAgICBwZXJpbWV0ZXI6IHBlcmltZXRlcixcblxuICAgIGNlbnRyb2lkOiBjZW50cm9pZCxcbiAgICBpbmNlbnRlcjogaW5jZW50ZXIsXG4gICAgY2lyY3VtY2VudGVyOiBjaXJjdW1jZW50ZXIsXG4gICAgYXJlYTogYXJlYSxcbiAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZSxcbiAgICBpc1ZlYzJJbnNpZGU6IGlzVmVjMkluc2lkZSxcblxuICAgIC8vIGFsaWFzXG4gICAgY2VudGVyOiBjZW50cm9pZCxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGU7IiwiLyoqXG4gKiBTdGFiaWxpdHk6IDIgKGZpeGVzIC8gcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzKVxuICpcbiAqIFZlYzIgaXMgcmVwcmVzZW50ZWQgYXMgYSB0d28gY29vcmRpbmF0ZXMgYXJyYXlcbiAqIFt4Ok51bWJlciwgeTpOdW1iZXJdXG4gKi9cblxudmFyIGF1eF92ZWMgPSBbMCwgMF0sXG4gICAgX194ID0gMCxcbiAgICBfX3kgPSAwLFxuICAgIGF1eF9udW1iZXIxID0gMCxcbiAgICBhdXhfbnVtYmVyMiA9IDAsXG4gICAgYXV4X251bWJlcjMgPSAwLFxuXG4gICAgLy9jYWNoZVxuICAgIEVQUyA9IE1hdGguRVBTLFxuICAgIGFjb3MgPSBNYXRoLmFjb3MsXG4gICAgY29zICA9IE1hdGguY29zLFxuICAgIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgX19hYnMgID0gTWF0aC5hYnMsXG4gICAgc2luICA9IE1hdGguc2luLFxuICAgIF9fbWluICA9IE1hdGgubWluLFxuICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICBfX3BvdyA9IE1hdGgucG93LFxuXG4gICAgSEFMRl9OUEkgPSBNYXRoLkhBTEZfTlBJLFxuICAgIEhBTEZfUEkgPSBNYXRoLkhBTEZfUEksXG5cbiAgICBERUdfVE9fUkFEID0gTWF0aC5ERUdfVE9fUkFELFxuICAgIFZlYzI7XG5cbi8qKlxuICogQ3JlYXRlIGEgVmVjMiBnaXZlbiB0d28gY29vcmRzXG4gKlxuICogQHBhcmFtIHtWZWMyfE51bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSh4LCB5KSB7XG5pZiAoISghQXJyYXkuaXNBcnJheSh4KSB8fCB4WzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeFswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4WzBdIHx8IHhbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4WzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHhbMV0pICYmICEoeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgeCBPUiB4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWZWMyIGdpdmVuIGxlbmd0aCBhbmQgYW5nbGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge051bWJlcn0gZGVncmVlc1xuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gZEZyb21Qb2xhcihsZW5ndGgsIGRlZ3JlZXMpIHtcbmlmIChsZW5ndGggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihsZW5ndGgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChkZWdyZWVzID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oZGVncmVlcykgfHwgJ251bWJlcicgIT09IHR5cGVvZiBkZWdyZWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVncmVlcyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuIGZyb21Qb2xhcihsZW5ndGgsIGRlZ3JlZXMgKiBERUdfVE9fUkFEKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWZWMyIGdpdmVuIGxlbmd0aCBhbmQgYW5nbGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaWFuc1xuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gZnJvbVBvbGFyKGxlbmd0aCwgcmFkaWFucykge1xuaWYgKGxlbmd0aCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGxlbmd0aCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHJhZGlhbnMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyYWRpYW5zKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGlhbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpYW5zIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICByZXR1cm4gW2xlbmd0aCAqIHNpbihyYWRpYW5zKSwgbGVuZ3RoICogY29zKHJhZGlhbnMpXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZW1wdHkgVmVjMlxuICpcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIHplcm8oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbn1cblxuLyoqXG4gKiBDbG9uZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gY2xvbmUodjEpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbiAgICByZXR1cm4gW3YxWzBdLCB2MVsxXV07XG59XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIGNvbXBhcmlzb24gb3BlcmF0aW9uc1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBib3RoIHZlY3RvcnMgYXJlIGVxdWFsKHNhbWUgY29vcmRzKVxuICpcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVxdWFscyh2MSwgdjIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MikgfHwgdjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlswXSB8fCB2MlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyXCIpXG59XG5cbiAgICByZXR1cm4gdjJbMF0gPT09IHYxWzBdICYmIHYyWzFdID09PSB2MVsxXTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJvdGggdmVjdG9ycyBhcmUgXCJhbG1vc3QoTWF0aC5FUFMpXCIgZXF1YWxcbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBlcXVhbHNFcHNpbG9uKHYxLCB2Mikge1xuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuICAgIGF1eF9udW1iZXIxID0gX19hYnModjJbMF0gLSB2MVswXSk7XG4gICAgYXV4X251bWJlcjIgPSBfX2Ficyh2MlsxXSAtIHYxWzFdKTtcblxuICAgIHJldHVybiBhdXhfbnVtYmVyMSA8IEVQUyAmJiBhdXhfbnVtYmVyMiA8IEVQUztcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGJvdGggY29vcmRpbmF0ZXMgb2YgdjEgYXJlYSBncmVhdGVyIHRoYW4gdjJcbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBndCh2MSwgdjIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MikgfHwgdjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlswXSB8fCB2MlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyXCIpXG59XG5cbiAgICByZXR1cm4gdjJbMF0gPiB2MVswXSAmJiB2MlsxXSA+IHYxWzFdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgYm90aCBjb29yZGluYXRlcyBvZiB2MSBhcmVhIGxlc3NlciB0aGFuIHYyXG4gKlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2MlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbHQodjEsIHYyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjIpIHx8IHYyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMF0gfHwgdjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MlwiKVxufVxuXG4gICAgcmV0dXJuIHYyWzBdIDwgdjFbMF0gJiYgdjJbMV0gPCB2MVsxXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRpc3RhbmNlIGJldHdlZW4gdjEgYW5kIHYyIGlzIGxlc3MgdGhhbiBkaXN0LlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBuZWFyKHYxLCB2MiwgZGlzdCkge1xuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuaWYgKGRpc3QgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihkaXN0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGRpc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXN0IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICAvLyBtYXliZSBpbmxpbmVcbiAgICBhdXhfbnVtYmVyMSA9IHNxckRpc3RhbmNlKHYxLCB2Mik7XG5cblxuICAgIHJldHVybiBhdXhfbnVtYmVyMSA8IGRpc3QgKiBkaXN0O1xufVxuXG4vKipcbiAqICogMCBlcXVhbFxuICogKiAxIHRvcFxuICogKiAyIHRvcC1yaWdodFxuICogKiAzIHJpZ2h0XG4gKiAqIDQgYm90dG9tIHJpZ2h0XG4gKiAqIDUgYm90dG9tXG4gKiAqIDYgYm90dG9tLWxlZnRcbiAqICogNyBsZWZ0XG4gKiAqIDggdG9wLWxlZnRcbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUodjEsIHYyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjIpIHx8IHYyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMF0gfHwgdjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MlwiKVxufVxuXG4gICAgdmFyIHYxeCA9IHYxWzBdLFxuICAgICAgICB2MXkgPSB2MVsxXSxcbiAgICAgICAgdjJ4ID0gdjJbMF0sXG4gICAgICAgIHYyeSA9IHYyWzFdO1xuXG4gICAgaWYgKHYyeCA9PT0gdjF4ICYmIHYyeSA9PT0gdjF5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAodjJ4ID09PSB2MXgpIHtcbiAgICAgICAgcmV0dXJuIHYyeSA+IHYxeSA/IDEgOiA1O1xuICAgIH1cbiAgICBpZiAodjJ5ID09PSB2MXkpIHtcbiAgICAgICAgcmV0dXJuIHYyeCA+IHYxeCA/IDMgOiA3O1xuICAgIH1cblxuICAgIGlmICh2MnggPiB2MXgpIHtcbiAgICAgICAgaWYgKHYyeSA+IHYxeSkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodjJ5IDwgdjF5KSB7XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2MnggPCB2MXgpIHtcbiAgICAgICAgaWYgKHYyeSA8IHYxeSkge1xuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYyeSA+IHYxeSkge1xuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIHZhbGlkYXRpb25cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogVGhlIHZlY3RvciBkb2VzIG5vdCBjb250YWluIGFueSBub3QgbnVtYmVyIHZhbHVlOiDCsUluZmluaXR5IHx8IE5hTlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWQodjEpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbiAgICByZXR1cm4gISh2MVswXSA9PT0gSW5maW5pdHkgfHwgdjFbMF0gPT09IC1JbmZpbml0eSB8fCBpc05hTih2MVswXSkgfHwgdjFbMV0gPT09IEluZmluaXR5IHx8IHYxWzFdID09PSAtSW5maW5pdHkgfHwgaXNOYU4odjFbMV0pKTtcbn1cbi8qKlxuICogQW55IGNvb3JkaW5hdGUgaXMgTmFOPyAtPiB0cnVlXG4gKlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOYU4odjEpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbiAgICByZXR1cm4gaXNOYU4odjFbMF0pIHx8IGlzTmFOKHYxWzFdKTtcbn1cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSBvdXRwdXRcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuLyoqXG4gKiBDb3B5IHYxIGludG8gb3V0X3ZlYzJcbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBjb3B5KG91dF92ZWMyLCB2MSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gdjFbMF07XG4gICAgb3V0X3ZlYzJbMV0gPSB2MVsxXTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cblxuLyoqXG4gKiBOZWdhdGUgdjEgaW50byBvdXRfdmVjMlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXRfdmVjMiwgdjEpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IC12MVswXTtcbiAgICBvdXRfdmVjMlsxXSA9IC12MVsxXTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKG91dF92ZWMyLCB2MSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuICAgIF9feCA9IHYxWzBdO1xuICAgIF9feSA9IHYxWzFdO1xuICAgIGF1eF9udW1iZXIzID0gc3FydChfX3ggKiBfX3ggKyBfX3kgKiBfX3kpO1xuXG4gICAgaWYgKGF1eF9udW1iZXIzID4gRVBTKSB7XG4gICAgICAgIGF1eF9udW1iZXIzID0gMSAvIGF1eF9udW1iZXIzO1xuICAgICAgICBvdXRfdmVjMlswXSA9IHYxWzBdICogYXV4X251bWJlcjM7XG4gICAgICAgIG91dF92ZWMyWzFdID0gdjFbMV0gKiBhdXhfbnVtYmVyMztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSB2MSBidXQgc3F1YXJlZCBubyB1c2Ugc3FydCwgZm9yIHBlcmZvcm1hbmNlLlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNxKG91dF92ZWMyLCB2MSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuICAgIF9feCA9IHYxWzBdO1xuICAgIF9feSA9IHYxWzFdO1xuICAgIGF1eF9udW1iZXIzID0gX194ICogX194ICsgX195ICogX195O1xuXG4gICAgaWYgKGF1eF9udW1iZXIzID4gRVBTICogRVBTKSB7XG4gICAgICAgIGF1eF9udW1iZXIzID0gMSAvIGF1eF9udW1iZXIzO1xuICAgICAgICBvdXRfdmVjMlswXSA9IHYxWzBdICogYXV4X251bWJlcjM7XG4gICAgICAgIG91dF92ZWMyWzFdID0gdjFbMV0gKiBhdXhfbnVtYmVyMztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIFJvdGF0ZSB0aGUgdmVjdG9yIGNsb2Nrd2lzZVxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIHBlcnBlbmRpY3VsYXIob3V0X3ZlYzIsIHYxKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG4gICAgYXV4X251bWJlcjEgPSB2MVswXTtcbiAgICBvdXRfdmVjMlswXSA9IHYxWzFdO1xuICAgIG91dF92ZWMyWzFdID0gLWF1eF9udW1iZXIxO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBSb3RhdGUgdGhlIHZlY3RvciBjb3VudGVyY2xvY2t3aXNlXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gcnBlcnBlbmRpY3VsYXIob3V0X3ZlYzIsIHYxKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG4gICAgYXV4X251bWJlcjEgPSB2MVswXTtcbiAgICBvdXRfdmVjMlswXSA9IC12MVsxXTtcbiAgICBvdXRfdmVjMlsxXSA9IGF1eF9udW1iZXIxO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlIGJldHdlZW4gYSBhbmQgYi5cbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gbGVycChvdXRfdmVjMiwgdjEsIHYyLCB0KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjIpIHx8IHYyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMF0gfHwgdjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MlwiKVxufVxuXG5pZiAodCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHQpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInQgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gdjFbMF0gKyAodjJbMF0gLSB2MVswXSkgKiB0O1xuICAgIG91dF92ZWMyWzFdID0gdjFbMV0gKyAodjJbMV0gLSB2MVsxXSkgKiB0O1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlIGJldHdlZW4gdjEgdG93YXJkcyB2MiBieSBkaXN0YW5jZSBkLlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBsZXJwY29uc3Qob3V0X3ZlYzIsIHYxLCB2MiwgZCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuaWYgKGQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihkKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IHYyWzBdIC0gdjFbMF07XG4gICAgb3V0X3ZlYzJbMV0gPSB2MlsxXSAtIHYxWzFdO1xuXG4gICAgY2xhbXAob3V0X3ZlYzIsIG91dF92ZWMyLCBkKTtcblxuICAgIG91dF92ZWMyWzBdICs9IHYxWzBdO1xuICAgIG91dF92ZWMyWzFdICs9IHYxWzFdO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuXG4vKipcbiAqIFNwaGVyaWNhbCBsaW5lYXJseSBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHYxIGFuZCB2Mi5cbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gc2xlcnAob3V0X3ZlYzIsIHYxLCB2MiwgdCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuaWYgKHQgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih0KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICB2YXIgb21lZ2EgPSBhY29zKGRvdCh2MSwgdjIpKSxcbiAgICAgICAgZGVub207XG5cbiAgICBpZiAob21lZ2EpIHtcbiAgICAgICAgZGVub20gPSAxLjAgLyBzaW4ob21lZ2EpO1xuXG4gICAgICAgIHNjYWxlKG91dF92ZWMyLCB2MSwgc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAqIGRlbm9tKTtcbiAgICAgICAgc2NhbGUoYXV4X3ZlYywgc2luKHQgKiBvbWVnYSkgKiBkZW5vbSk7XG5cbiAgICAgICAgcmV0dXJuIGFkZChvdXRfdmVjMiwgb3V0X3ZlYzIsIGF1eF92ZWMpO1xuICAgIH1cblxuICAgIHJldHVybiBjb3B5KG91dF92ZWMyLCB2MSk7XG59XG5cbi8qKlxuICogU3BoZXJpY2FsIGxpbmVhcmx5IGludGVycG9sYXRlIGJldHdlZW4gdjEgdG93YXJkcyB2MiBieSBubyBtb3JlIHRoYW4gYW5nbGUgYSBpbiByYWRpYW5zLlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBzbGVycGNvbnN0KG91dF92ZWMyLCB2MSwgdjIsIHJhZGlhbnMpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MikgfHwgdjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlswXSB8fCB2MlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyXCIpXG59XG5cbmlmIChyYWRpYW5zID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocmFkaWFucykgfHwgJ251bWJlcicgIT09IHR5cGVvZiByYWRpYW5zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmFkaWFucyBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgdmFyIF9yYWRpYW5zID0gYWNvcyhkb3QodjEsIHYyKSk7XG4gICAgcmV0dXJuIHNsZXJwKG91dF92ZWMyLCB2MSwgdjIsIF9fbWluKHJhZGlhbnMsIF9yYWRpYW5zKSAvIF9yYWRpYW5zKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bml0IGxlbmd0aCB2ZWN0b3IgZm9yIHRoZSBnaXZlbiBhbmdsZSAoaW4gcmFkaWFucykuXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnNcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIGZvckFuZ2xlKG91dF92ZWMyLCByYWRpYW5zKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAocmFkaWFucyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJhZGlhbnMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmFkaWFucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJhZGlhbnMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gY29zKHJhZGlhbnMpO1xuICAgIG91dF92ZWMyWzFdID0gc2luKHJhZGlhbnMpO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZlY3RvciBwcm9qZWN0aW9uIG9mIHYxIG9udG8gdjIuXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2MlxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gcHJvamVjdChvdXRfdmVjMiwgdjEsIHYyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjIpIHx8IHYyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMF0gfHwgdjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MlwiKVxufVxuXG4gICAgbXVsdGlwbHkob3V0X3ZlYzIsIHYxLCB2Mik7XG4gICAgc2NhbGUob3V0X3ZlYzIsIGRvdCh2MSwgdjIpIC8gZG90KHYyLCB2MikpO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgdGhlIHBvaW50IGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0X3ZlYzIsIHYxLCByYWRpYW5zKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAocmFkaWFucyA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJhZGlhbnMpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcmFkaWFucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJhZGlhbnMgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHZhciBzID0gc2luKHJhZGlhbnMpLFxuICAgICAgICBjID0gY29zKHJhZGlhbnMpO1xuXG4gICAgX194ID0gdjFbMF07XG4gICAgX195ID0gdjFbMV07XG5cbiAgICBvdXRfdmVjMlswXSA9IF9feCAqIGMgLSBfX3kgKiBzO1xuICAgIG91dF92ZWMyWzFdID0gX195ICogYyArIF9feCAqIHM7XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIFJvdGF0ZXMgdGhlIHBvaW50IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgYW4gb3B0aW9uYWwgY2VudGVyIHBvaW50LlxuICpcbiAqIEBub3RlIGNlbnRlciBjYW5ub3QgYmUgb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zXG4gKiBAcGFyYW0ge1ZlYzJ9IGNlbnRlclxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gcm90YXRlRnJvbShvdXRfdmVjMiwgdjEsIHJhZGlhbnMsIGNlbnRlcikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKHJhZGlhbnMgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihyYWRpYW5zKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJhZGlhbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpYW5zIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheShjZW50ZXIpIHx8IGNlbnRlclswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGNlbnRlclswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBjZW50ZXJbMF0gfHwgY2VudGVyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oY2VudGVyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGNlbnRlclsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBjZW50ZXJcIilcbn1cblxuICAgIHN1YnRyYWN0KG91dF92ZWMyLCB2MSwgY2VudGVyKTtcblxuICAgIF9feCA9IG91dF92ZWMyWzBdO1xuICAgIF9feSA9IG91dF92ZWMyWzFdO1xuXG4gICAgdmFyIHMgPSBzaW4ocmFkaWFucyksXG4gICAgICAgIGMgPSBjb3MocmFkaWFucyk7XG5cblxuICAgIG91dF92ZWMyWzBdID0gX194ICogYyAtIF9feSAqIHM7XG4gICAgb3V0X3ZlYzJbMV0gPSBfX3kgKiBjICsgX194ICogcztcblxuICAgIGFkZChvdXRfdmVjMiwgb3V0X3ZlYzIsIGNlbnRlcik7XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBnaXZlbiBcImFuZ2xlXCIgYnkgYSBub3JtYWxpemVkIHZlY3RvciB2Ml9uXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2Ml9uXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiByb3RhdGVWZWMob3V0X3ZlYzIsIHYxLCB2Ml9uKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjJfbikgfHwgdjJfblswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyX25bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJfblswXSB8fCB2Ml9uWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJfblsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2Ml9uWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyX25cIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gdjFbMF0gKiB2Ml9uWzBdIC0gdjFbMV0gKiB2Ml9uWzFdO1xuICAgIG91dF92ZWMyWzFdID0gdjFbMF0gKiB2Ml9uWzFdICsgdjFbMV0gKiB2Ml9uWzBdO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBVbi1yb3RhdGUgYSB2ZWN0b3IgZ2l2ZW4gXCJhbmdsZVwiIGJ5IGEgbm9ybWFsaXplZCB2ZWN0b3IgdjJfblxuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJfblxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gdW5yb3RhdGVWZWMob3V0X3ZlYzIsIHYxLCB2Ml9uKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjJfbikgfHwgdjJfblswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyX25bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJfblswXSB8fCB2Ml9uWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJfblsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2Ml9uWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyX25cIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gdjFbMF0gKiB2Ml9uWzBdICsgdjFbMV0gKiB2Ml9uWzFdO1xuICAgIG91dF92ZWMyWzFdID0gdjFbMV0gKiB2Ml9uWzBdIC0gdjFbMF0gKiB2Ml9uWzFdO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2MlxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gbWlkUG9pbnQob3V0X3ZlYzIsIHYxLCB2Mikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gKHYxWzBdICsgdjJbMF0pICogMC41O1xuICAgIG91dF92ZWMyWzFdID0gKHYxWzFdICsgdjJbMV0pICogMC41O1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuXG52YXIgcmVmbGVjdF9mYWN0b3I7XG4vKipcbiAqIFJlZmxlY3QgdjEgYnkgdGhlIGltYWdpbmFyeSBsaW5lIHYyX25cbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyX25cbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIHJlZmxlY3Qob3V0X3ZlYzIsIHYxLCB2Ml9uKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjJfbikgfHwgdjJfblswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyX25bMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJfblswXSB8fCB2Ml9uWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJfblsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2Ml9uWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyX25cIilcbn1cblxuICAgIHJlZmxlY3RfZmFjdG9yID0gZG90KHYxLCB2Ml9uKTtcblxuICAgIHNjYWxlKG91dF92ZWMyLCB2Ml9uLCAyICogcmVmbGVjdF9mYWN0b3IpO1xuICAgIHN1YnRyYWN0KG91dF92ZWMyLCB2MSwgb3V0X3ZlYzIpO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXRfdmVjMiwgdjEsIHYyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjIpIHx8IHYyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMF0gfHwgdjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MlwiKVxufVxuXG4gICAgb3V0X3ZlYzJbMF0gPSB2MVswXSAtIHYyWzBdO1xuICAgIG91dF92ZWMyWzFdID0gdjFbMV0gLSB2MlsxXTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdDIob3V0X3ZlYzIsIHYxLCB4LCB5KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IHYxWzBdIC0geDtcbiAgICBvdXRfdmVjMlsxXSA9IHYxWzFdIC0geTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2MlxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gYWRkKG91dF92ZWMyLCB2MSwgdjIpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MikgfHwgdjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlswXSB8fCB2MlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IHYxWzBdICsgdjJbMF07XG4gICAgb3V0X3ZlYzJbMV0gPSB2MVsxXSArIHYyWzFdO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIGFkZDIob3V0X3ZlYzIsIHYxLCB4LCB5KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih5KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IHYxWzBdICsgeDtcbiAgICBvdXRfdmVjMlsxXSA9IHYxWzFdICsgeTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogQHNlZSBzY2FsZVxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2MlxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0X3ZlYzIsIHYxLCB2Mikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gdjFbMF0gKiB2MlswXTtcbiAgICBvdXRfdmVjMlsxXSA9IHYxWzFdICogdjJbMV07XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkyKG91dF92ZWMyLCB2MSwgeCwgeSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKHggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgb3V0X3ZlYzJbMF0gPSB2MVswXSAqIHg7XG4gICAgb3V0X3ZlYzJbMV0gPSB2MVsxXSAqIHk7XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXRfdmVjMiwgdjEsIHYyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjIpIHx8IHYyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMF0gfHwgdjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MlwiKVxufVxuXG4gICAgb3V0X3ZlYzJbMF0gPSB2MVswXSAvIHYyWzBdO1xuICAgIG91dF92ZWMyWzFdID0gdjFbMV0gLyB2MlsxXTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBkaXZpZGUyKG91dF92ZWMyLCB2MSwgeCwgeSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKHggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgb3V0X3ZlYzJbMF0gPSB2MVswXSAvIHg7XG4gICAgb3V0X3ZlYzJbMV0gPSB2MVsxXSAvIHk7XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIEBzZWUgbXVsdGlwbHlcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG91dF92ZWMyLCB2MSwgZmFjdG9yKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoZmFjdG9yID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oZmFjdG9yKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGZhY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZhY3RvciBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgb3V0X3ZlYzJbMF0gPSB2MVswXSAqIGZhY3RvcjtcbiAgICBvdXRfdmVjMlsxXSA9IHYxWzFdICogZmFjdG9yO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiAoeDFeeSwgeTFeeSlcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBwb3cob3V0X3ZlYzIsIHYxLCB5KSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoeSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInkgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIGlmICh5ID09PSAyKSB7XG4gICAgICAgIG91dF92ZWMyWzBdID0gdjFbMF0gKiB2MVswXTtcbiAgICAgICAgb3V0X3ZlYzJbMV0gPSB2MVsxXSAqIHYxWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dF92ZWMyWzBdID0gX19wb3codjFbMF0sIHkpO1xuICAgICAgICBvdXRfdmVjMlsxXSA9IF9fcG93KHYxWzFdLCB5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0X3ZlYzI7XG59XG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbmZ1bmN0aW9uIG1heChvdXRfdmVjMiwgdjEsIHYyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjIpIHx8IHYyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMF0gfHwgdjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MlwiKVxufVxuXG4gICAgb3V0X3ZlYzJbMF0gPSB2MVswXSA+IHYyWzBdID8gdjFbMF0gOiB2MlswXTtcbiAgICBvdXRfdmVjMlsxXSA9IHYxWzFdID4gdjJbMV0gPyB2MVsxXSA6IHYyWzFdO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBtaW4ob3V0X3ZlYzIsIHYxLCB2Mikge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gdjFbMF0gPCB2MlswXSA/IHYxWzBdIDogdjJbMF07XG4gICAgb3V0X3ZlYzJbMV0gPSB2MVsxXSA8IHYyWzFdID8gdjFbMV0gOiB2MlsxXTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gYWJzKG91dF92ZWMyLCB2MSkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuICAgIG91dF92ZWMyWzBdID0gX19hYnModjFbMF0pO1xuICAgIG91dF92ZWMyWzFdID0gX19hYnModjFbMV0pO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcGFyYW0ge051bWJlcn0gZmFjdG9yXG4gKiBAcmV0dXJuIHtWZWMyfVxuICovXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXRfdmVjMiwgdjEsIHYyLCBmYWN0b3IpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MikgfHwgdjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlswXSB8fCB2MlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyXCIpXG59XG5cbmlmIChmYWN0b3IgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihmYWN0b3IpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgZmFjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmFjdG9yIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IHYxWzBdICsgKHYyWzBdICogZmFjdG9yKTtcbiAgICBvdXRfdmVjMlsxXSA9IHYxWzFdICsgKHYyWzFdICogZmFjdG9yKTtcblxuICAgIHJldHVybiBvdXRfdmVjMjtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gY2xhbXAob3V0X3ZlYzIsIHYxLCBsZW5ndGgpIHtcbmlmICghQXJyYXkuaXNBcnJheShvdXRfdmVjMikgfHwgb3V0X3ZlYzJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlswXSB8fCBvdXRfdmVjMlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIG91dF92ZWMyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmIChsZW5ndGggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihsZW5ndGgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbiAgICBvdXRfdmVjMlswXSA9IHYxWzBdO1xuICAgIG91dF92ZWMyWzFdID0gdjFbMV07XG5cbiAgICBpZiAoZG90KHYxLCB2MSkgPiBsZW5ndGggKiBsZW5ndGgpIHtcbiAgICAgICAgbm9ybWFsaXplKG91dF92ZWMyKTtcbiAgICAgICAgbXVsdGlwbHkob3V0X3ZlYzIsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtWZWMyfSBvdXRfdmVjMlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiB0cnVuY2F0ZShvdXRfdmVjMiwgdjEsIGxlbmd0aCkge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKGxlbmd0aCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGxlbmd0aCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHZhciBsZW5ndGhfc3EgPSB2MVswXSAqIHYxWzBdICsgdjFbMV0gKiB2MVsxXTtcbiAgICBpZiAobGVuZ3RoX3NxID4gbGVuZ3RoICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzY2FsZShvdXRfdmVjMiwgdjEsIGxlbmd0aCAvIHNxcnQobGVuZ3RoX3NxKSk7XG4gICAgfVxuXG4gICAgb3V0X3ZlYzJbMF0gPSB2MVswXTtcbiAgICBvdXRfdmVjMlsxXSA9IHYxWzFdO1xuXG4gICAgcmV0dXJuIG91dF92ZWMyO1xufVxuXG4vKipcbiAqIENyb3NzIHByb2R1Y3QgYmV0d2VlbiBhIHZlY3RvciBhbmQgdGhlIFogY29tcG9uZW50IG9mIGEgdmVjdG9yXG4gKiBBS0EgUm90YXRlIENXIGFuZCBzY2FsZVxuICpcbiAqIEB0b2RvIHRlc3QgdXNlIHJwcmVwZW5kaWN1bGFyID9cbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHZlYzJcbiAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gY3Jvc3NWWihvdXRfdmVjMiwgdmVjMiwgZmFjdG9yKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuaWYgKGZhY3RvciA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGZhY3RvcikgfHwgJ251bWJlcicgIT09IHR5cGVvZiBmYWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWN0b3IgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJvdGF0ZShvdXRfdmVjMiwgdmVjMiwgSEFMRl9OUEkpOyAvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcbiAgICByZXR1cm4gc2NhbGUob3V0X3ZlYzIsIG91dF92ZWMyLCBmYWN0b3IpOyAvLyBTY2FsZSB3aXRoIHpcbn1cbi8qKlxuICogQ3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIGEgdmVjdG9yIGFuZCB0aGUgWiBjb21wb25lbnQgb2YgYSB2ZWN0b3JcbiAqIEFLQSBSb3RhdGUgQ0NXIGFuZCBzY2FsZVxuICpcbiAqIEB0b2RvIHRlc3QgdXNlIHByZXBlbmRpY3VsYXIgP1xuICpcbiAqIEBwYXJhbSB7VmVjMn0gb3V0X3ZlYzJcbiAqIEBwYXJhbSB7VmVjMn0gdmVjMlxuICogQHBhcmFtIHtOdW1iZXJ9IGZhY3RvclxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuZnVuY3Rpb24gY3Jvc3NaVihvdXRfdmVjMiwgZmFjdG9yLCB2ZWMyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkob3V0X3ZlYzIpIHx8IG91dF92ZWMyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMF0gfHwgb3V0X3ZlYzJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihvdXRfdmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBvdXRfdmVjMlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiBvdXRfdmVjMlwiKVxufVxuXG5pZiAoZmFjdG9yID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oZmFjdG9yKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIGZhY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZhY3RvciBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodmVjMikgfHwgdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHZlYzJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdmVjMlswXSB8fCB2ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odmVjMlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2ZWMyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHZlYzJcIilcbn1cblxuICAgIHJvdGF0ZShvdXRfdmVjMiwgdmVjMiwgSEFMRl9QSSk7XG4gICAgcmV0dXJuIHNjYWxlKG91dF92ZWMyLCBvdXRfdmVjMiwgZmFjdG9yKTtcbn1cblxudmFyIHRwX2xlZnQgPSBbMCwgMF0sXG4gICAgdHBfcmlnaHQgPSBbMCwgMF07XG4vKipcbiAqIChBIHggQikgeCBDID0gQihDIMK3IEEpIC0gQShDIMK3IEIpXG4gKiAoQSB4IEIpIHggQyA9IEIoQS5kb3QoQykpIC0gQShCLmRvdChDKSlcbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dF92ZWMyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcGFyYW0ge1ZlYzJ9IHYzXG4qL1xuZnVuY3Rpb24gdHJpcGxlUHJvZHVjdChvdXRfdmVjMiwgdjEsIHYyLCB2Mykge1xuaWYgKCFBcnJheS5pc0FycmF5KG91dF92ZWMyKSB8fCBvdXRfdmVjMlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKG91dF92ZWMyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIG91dF92ZWMyWzBdIHx8IG91dF92ZWMyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ob3V0X3ZlYzJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2Ygb3V0X3ZlYzJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgb3V0X3ZlYzJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYzKSB8fCB2M1swXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYzWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYzWzBdIHx8IHYzWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjNbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjNcIilcbn1cblxuICAgIHNjYWxlKHRwX2xlZnQsIHYyLCBkb3QodjEsIHYzKSk7XG5cbiAgICBzY2FsZSh0cF9yaWdodCwgdjEsIGRvdCh2MiwgdjMpKTtcblxuICAgIHJldHVybiBzdWJ0cmFjdChvdXRfdmVjMiwgdHBfbGVmdCwgdHBfcmlnaHQpO1xufVxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyBmdW5jdGlvbnMgdGhhdCByZXR1cm4gbnVtYmVyc1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vKipcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gbWFnbml0dWRlKHYxLCB2Mikge1xuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuICAgIF9feCA9IHYxWzBdIC0gdjJbMF07XG4gICAgX195ID0gdjFbMV0gLSB2MlsxXTtcblxuICAgIHJldHVybiBfX3ggLyBfX3k7XG59XG5cbi8qKlxuICogdjEgwrcgdjIgPSB8YXwgKiB8YnwgKiBzaW4gzrhcbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRvdCh2MSwgdjIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MikgfHwgdjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlswXSB8fCB2MlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyXCIpXG59XG5cbiAgICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG59XG5cbi8qKlxuICogdjEgw5cgdjIgPSB8YXwgKiB8YnwgKiBzaW4gzrhcbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKHYxLCB2Mikge1xuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuICAgIHJldHVybiB2MVswXSAqIHYyWzFdIC0gdjFbMV0gKiB2MlswXTtcbn1cbi8qKlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiB0b0FuZ2xlKHYxKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG4gICAgcmV0dXJuIGF0YW4yKHYxWzFdLCB2MVswXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2MlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBhbmdsZVRvKHYxLCB2Mikge1xuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuaWYgKCFBcnJheS5pc0FycmF5KHYyKSB8fCB2MlswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzBdIHx8IHYyWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjJcIilcbn1cblxuICAgIHJldHVybiBhdGFuMih2MlsxXSAtIHYxWzFdLCB2MlswXSAtIHYxWzBdKTtcbn1cblxudmFyIGRpc3RhbmNlX3gsXG4gICAgZGlzdGFuY2VfeTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB2MSBhbmQgdjIuXG4gKlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2MlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh2MSwgdjIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MikgfHwgdjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlswXSB8fCB2MlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyXCIpXG59XG5cbiAgICAvL3N1YnRyYWN0XG4gICAgZGlzdGFuY2VfeCA9IHYyWzBdIC0gdjFbMF07XG4gICAgZGlzdGFuY2VfeSA9IHYyWzFdIC0gdjFbMV07XG4gICAgLy9zcXJMZW5ndGhcbiAgICByZXR1cm4gc3FydChkaXN0YW5jZV94ICogZGlzdGFuY2VfeCArIGRpc3RhbmNlX3kgKiBkaXN0YW5jZV95KTtcbn1cbi8qKlxuICogRGlzdGFuY2Ugd2l0aG91dCB1c2luZyBzcXJ0IChzcXVhcmVkIGRpc3RhbmNlKVxuICpcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gc3FyRGlzdGFuY2UodjEsIHYyKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG5pZiAoIUFycmF5LmlzQXJyYXkodjIpIHx8IHYyWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjJbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjJbMF0gfHwgdjJbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MlwiKVxufVxuXG4gICAgLy9zdWJ0cmFjdFxuICAgIGRpc3RhbmNlX3ggPSB2MVswXSAtIHYyWzBdO1xuICAgIGRpc3RhbmNlX3kgPSB2MVsxXSAtIHYyWzFdO1xuICAgIC8vc3FyTGVuZ3RoXG4gICAgcmV0dXJuIGRpc3RhbmNlX3ggKiBkaXN0YW5jZV94ICsgZGlzdGFuY2VfeSAqIGRpc3RhbmNlX3k7XG59XG5cbi8qKlxuICogUmV0dXJuIHZlY3RvciB0aGUgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gbGVuZ3RoKHYxKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG4gICAgcmV0dXJuIHNxcnQodjFbMF0gKiB2MVswXSArIHYxWzFdICogdjFbMV0pO1xufVxuLyoqXG4gKiBTcXVhcmVkIGxlbmd0aCAobm8gc3FydClcbiAqXG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNxckxlbmd0aCh2MSkge1xuaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCB2MVswXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzBdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzBdIHx8IHYxWzFdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMV0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFZlYzIgdjFcIilcbn1cblxuICAgIHJldHVybiB2MVswXSAqIHYxWzBdICsgdjFbMV0gKiB2MVsxXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB2MiBpcyBiZXR3ZWVuIHYxIGFuZCB2MyhpbmNsdXNpdmUpXG4gKlxuICogQHBhcmFtIHtWZWMyfSB2MVxuICogQHBhcmFtIHtWZWMyfSB2MlxuICogQHBhcmFtIHtWZWMyfSB2M1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gd2l0aGluKHYxLCB2MiwgdjMpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MikgfHwgdjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlswXSB8fCB2MlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MykgfHwgdjNbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2M1swXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2M1swXSB8fCB2M1sxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYzWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYzWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYzXCIpXG59XG5cbiAgICByZXR1cm4gKCh2MVswXSA8PSB2MlswXSAmJiB2MlswXSA8PSB2M1swXSkgfHwgKHYzWzBdIDw9IHYyWzBdICYmIHYyWzBdIDw9IHYxWzBdKSkgJiZcbiAgICAgICAgICAoKHYxWzFdIDw9IHYyWzFdICYmIHYyWzFdIDw9IHYzWzFdKSB8fCAodjNbMV0gPD0gdjJbMV0gJiYgdjJbMV0gPD0gdjFbMV0pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBxIGlzIGJldHdlZW4gcCBhbmQgcihpbmNsdXNpdmUpXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHB4XG4gKiBAcGFyYW0ge051bWJlcn0gcHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBxeFxuICogQHBhcmFtIHtOdW1iZXJ9IHF5XG4gKiBAcGFyYW0ge051bWJlcn0gcnhcbiAqIEBwYXJhbSB7TnVtYmVyfSByeVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gJHdpdGhpbihweCwgcHksIHF4LCBxeSwgcngsIHJ5KSB7XG5pZiAocHggPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihweCkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBweCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInB4IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChweSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHB5KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHB5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHkgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHF4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocXgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJxeCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAocXkgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihxeSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBxeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInF5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChyeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHJ4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHJ4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicnggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHJ5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocnkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyeSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG4gICAgcmV0dXJuICgocHggPD0gcXggJiYgcXggPD0gcngpIHx8IChyeCA8PSBxeCAmJiBxeCA8PSBweCkpICYmXG4gICAgICAgICAgKChweSA8PSBxeSAmJiBxeSA8PSByeSkgfHwgKHJ5IDw9IHF5ICYmIHF5IDw9IHB5KSk7XG59XG5cbi8qKlxuICogcCBpcyBuZWFyIHggwrEgZGlzdCAoXCJib3ggdGVzdFwiKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBweFxuICogQHBhcmFtIHtOdW1iZXJ9IHB5XG4gKiBAcGFyYW0ge051bWJlcn0gcXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBxeVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3QgRVBTXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiAkbmVhcihweCwgcHksIHF4LCBxeSwgZGlzdCkge1xuaWYgKHB4ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocHgpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJweCBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAocHkgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTihweSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiBweSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInB5IGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmIChxeCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHF4KSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicXggaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHF5ID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4ocXkpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgcXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJxeSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoZGlzdCA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKGRpc3QpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgZGlzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRpc3QgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiAocHggPiBxeCA/IChweCAtIHF4KSA8IGRpc3QgOiAocXggLSBweCkgPCBkaXN0KSAmJlxuICAgICAgICAgICAocHkgPiBxeSA/IChweSAtIHF5KSA8IGRpc3QgOiAocXkgLSBweSkgPCBkaXN0KTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gKiBAcGFyYW0ge051bWJlcn0geDJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiAkY3Jvc3MoeDEsIHkxLCB4MiwgeTIpIHtcbmlmICh4MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkxID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTEpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeDIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiB4MSAqIHkyIC0geTEgKiB4Mjtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHgxXG4gKiBAcGFyYW0ge051bWJlcn0geTFcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uICRkb3QoeDEsIHkxLCB4MiwgeTIpIHtcbmlmICh4MSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHgxKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHgxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieDEgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuaWYgKHkxID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4oeTEpIHx8ICdudW1iZXInICE9PSB0eXBlb2YgeTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5MSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKVxufVxuXG5pZiAoeDIgPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih4MikgfHwgJ251bWJlcicgIT09IHR5cGVvZiB4Mikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIngyIGlzIHVuZGVmaW5lZCBvciBudWxsXCIpXG59XG5cbmlmICh5MiA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHkyKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHkyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwieTIgaXMgdW5kZWZpbmVkIG9yIG51bGxcIilcbn1cblxuICAgIHJldHVybiB4MSAqIHgyICsgeTEgKiB5Mjtcbn1cbi8qKlxuICogU3dhcCB2ZWN0b3JzLCBib3RoIHdpbGwgYmUgbW9kaWZpZWQuXG4gKiBmb3IgbGF6eSBwZW9wbGVcbiAqIEBwYXJhbSB7VmVjMn0gdjFcbiAqIEBwYXJhbSB7VmVjMn0gdjJcbiAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gc3dhcCh2MSwgdjIpIHtcbmlmICghQXJyYXkuaXNBcnJheSh2MSkgfHwgdjFbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVswXSB8fCB2MVsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYxWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYxWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYxXCIpXG59XG5cbmlmICghQXJyYXkuaXNBcnJheSh2MikgfHwgdjJbMF0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MlswXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MlswXSB8fCB2MlsxXSA9PSB1bmRlZmluZWQgfHwgTnVtYmVyLmlzTmFOKHYyWzFdKSB8fCAnbnVtYmVyJyAhPT0gdHlwZW9mIHYyWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBWZWMyIHYyXCIpXG59XG5cbiAgICBfX3ggPSB2MlswXTtcbiAgICB2MlswXSA9IHYxWzBdO1xuICAgIHYxWzBdID0gX194O1xuXG4gICAgX194ID0gdjJbMV07XG4gICAgdjJbMV0gPSB2MVsxXTtcbiAgICB2MVsxXSA9IF9feDtcbn1cbi8qXG4gKiAoeCwgeSkgd2l0aCBvbmx5IHR3byBkZWNpbWFscywgZm9yIHJlYWRhYmlsaXR5XG4gKiBAcGFyYW0ge1ZlYzJ9IHYxXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHYxKSB7XG5pZiAoIUFycmF5LmlzQXJyYXkodjEpIHx8IHYxWzBdID09IHVuZGVmaW5lZCB8fCBOdW1iZXIuaXNOYU4odjFbMF0pIHx8ICdudW1iZXInICE9PSB0eXBlb2YgdjFbMF0gfHwgdjFbMV0gPT0gdW5kZWZpbmVkIHx8IE51bWJlci5pc05hTih2MVsxXSkgfHwgJ251bWJlcicgIT09IHR5cGVvZiB2MVsxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVmVjMiB2MVwiKVxufVxuXG4gICAgcmV0dXJuIFwiKFwiICsgdjFbMF0udG9GaXhlZCgyKSArIFwiLFwiICsgdjFbMV0udG9GaXhlZCgyKSArIFwiKVwiO1xufVxuXG5WZWMyID0ge1xuICAgIFpFUk86IFswLCAwXSxcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICBkRnJvbVBvbGFyOiBkRnJvbVBvbGFyLFxuICAgIGZyb21Qb2xhcjogZnJvbVBvbGFyLFxuICAgIHplcm86IHplcm8sXG4gICAgY2xvbmU6IGNsb25lLFxuICAgIGVxdWFsczogZXF1YWxzLFxuICAgIGVxdWFsc0Vwc2lsb246IGVxdWFsc0Vwc2lsb24sXG4gICAgZ3Q6IGd0LFxuICAgIGx0OiBsdCxcbiAgICBuZWFyOiBuZWFyLFxuICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgaXNOYU46IGlzTmFOLFxuICAgIGNvcHk6IGNvcHksXG4gICAgbmVnYXRlOiBuZWdhdGUsXG4gICAgcGVycGVuZGljdWxhcjogcGVycGVuZGljdWxhcixcbiAgICBwZXJwOiBwZXJwZW5kaWN1bGFyLFxuICAgIHJvdGF0ZUNXOiBwZXJwZW5kaWN1bGFyLFxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICAgIG5vcm1hbGl6ZVNxOiBub3JtYWxpemVTcSxcbiAgICBycGVycGVuZGljdWxhcjogcnBlcnBlbmRpY3VsYXIsXG4gICAgcnBlcnA6IHJwZXJwZW5kaWN1bGFyLFxuICAgIHJvdGF0ZUNDVzogcnBlcnBlbmRpY3VsYXIsXG4gICAgbGVycDogbGVycCxcbiAgICBpbnRlcnBvbGF0ZTogbGVycCxcbiAgICBsZXJwY29uc3Q6IGxlcnBjb25zdCxcbiAgICBzbGVycDogc2xlcnAsXG4gICAgc2xlcnBjb25zdDogc2xlcnBjb25zdCxcbiAgICBmb3JBbmdsZTogZm9yQW5nbGUsXG4gICAgcHJvamVjdDogcHJvamVjdCxcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICByb3RhdGVGcm9tOiByb3RhdGVGcm9tLFxuICAgIHJvdGF0ZVZlYzogcm90YXRlVmVjLFxuICAgIHVucm90YXRlVmVjOiB1bnJvdGF0ZVZlYyxcbiAgICBtaWRQb2ludDogbWlkUG9pbnQsXG4gICAgcmVmbGVjdDogcmVmbGVjdCxcbiAgICBzdWJ0cmFjdDogc3VidHJhY3QsXG4gICAgc3VidHJhY3QyOiBzdWJ0cmFjdDIsXG4gICAgYWRkOiBhZGQsXG4gICAgYWRkMjogYWRkMixcbiAgICBtdWx0aXBseTogbXVsdGlwbHksXG4gICAgbXVsdGlwbHkyOiBtdWx0aXBseTIsXG4gICAgZGl2aWRlOiBkaXZpZGUsXG4gICAgZGl2aWRlMjogZGl2aWRlMixcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgcG93OiBwb3csXG4gICAgbWF4OiBtYXgsXG4gICAgbWluOiBtaW4sXG4gICAgYWJzOiBhYnMsXG4gICAgc2NhbGVBbmRBZGQ6IHNjYWxlQW5kQWRkLFxuICAgIGNsYW1wOiBjbGFtcCxcbiAgICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG4gICAgbWFnbml0dWRlOiBtYWduaXR1ZGUsXG4gICAgY29tcGFyZTogY29tcGFyZSxcbiAgICBkb3Q6IGRvdCxcbiAgICBjcm9zczogY3Jvc3MsXG4gICAgY3Jvc3NWWjogY3Jvc3NWWixcbiAgICBjcm9zc1pWOiBjcm9zc1pWLFxuICAgIHRvQW5nbGU6IHRvQW5nbGUsXG4gICAgYW5nbGU6IHRvQW5nbGUsXG4gICAgYW5nbGVUbzogYW5nbGVUbyxcbiAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgc3FyRGlzdGFuY2U6IHNxckRpc3RhbmNlLFxuICAgIHNxckxlbmd0aDogc3FyTGVuZ3RoLFxuICAgIHdpdGhpbjogd2l0aGluLFxuICAgIHN3YXA6IHN3YXAsXG4gICAgdHJpcGxlUHJvZHVjdDogdHJpcGxlUHJvZHVjdCxcblxuICAgIC8vIGFsaWFzXG4gICAgZXE6IGVxdWFscyxcbiAgICBzdWI6IHN1YnRyYWN0LFxuICAgIHN1YjI6IHN1YnRyYWN0MixcbiAgICBtdWw6IG11bHRpcGx5LFxuICAgIG11bDI6IG11bHRpcGx5MixcbiAgICBkaXY6IGRpdmlkZSxcbiAgICBkaXYyOiBkaXZpZGUyLFxuICAgIGRpc3RhbmNlU3E6IHNxckRpc3RhbmNlLFxuICAgIGxlbmd0aFNxOiBzcXJMZW5ndGgsXG4gICAgJHdpdGhpbjogJHdpdGhpbixcbiAgICAkbmVhcjogJG5lYXIsXG4gICAgJGNyb3NzOiAkY3Jvc3MsXG4gICAgJGRvdDogJGRvdCxcblxuICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWMyO1xuIiwiLy8gZnJvbTogaHR0cDovL2pzZG8uaXQvYWttMi9maE1DL2pzXG4vLyBkb24ndCBrbm93IHRoZSBhdXRob3IgOilcbi8vIEkganVzdCBsaW50IHRoZSBjb2RlLi4uIGFuZCBhZGFwdCBpdCB0byB0aGlzIGxpYiBwaGlsb3NvcGh5XG5cbi8vIEhlbHBlclxuXG5mdW5jdGlvbiBfbWFzaChkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICB2YXIgbiA9IDB4ZWZjODI0OWQsXG4gICAgICAgIGksXG4gICAgICAgIGxlbixcbiAgICAgICAgaDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgICAgbiA9IGggPj4+IDA7XG4gICAgICAgIGggLT0gbjtcbiAgICAgICAgaCAqPSBuO1xuICAgICAgICBuID0gaCA+Pj4gMDtcbiAgICAgICAgaCAtPSBuO1xuICAgICAgICBuICs9IGggKiAweDEwMDAwMDAwMDtcbiAgICB9XG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7XG59XG5cbi8qKlxuICogUmFuZG9tIG51bWJlcnMgZ2VuZXJhdG9yXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRocmVlIG1ldGhvZHNcbiAqICogdWludDMyKClcbiAqICogcmFuZG9tKClcbiAqICogZnJhY3Q1MygpXG4gKlxuICogQHNlZSBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWG9yc2hpZnRcbiAqIEBzb3VyY2UgaHR0cDovL2pzZG8uaXQvYWttMi9maE1DL2pzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VlZHNcbiAqIEByZXR1cm4ge09iamVjdH0ge3VpbnQzMjogRnVuY3Rpb24sIHJhbmRvbTogRnVuY3Rpb24sIGZyYWN0NTM6IEZ1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGUoc2VlZHMpIHtcbmlmICghQXJyYXkuaXNBcnJheShzZWVkcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZWVkcyBpcyBub3QgYSBhcnJheVwiKVxufVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBzZWVkcyA9IChhcmd1bWVudHMubGVuZ3RoKSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOiBbbmV3IERhdGUoKS5nZXRUaW1lKCldLFxuXG4gICAgICAgIHggPSAxMjM0NTY3ODksXG4gICAgICAgIHkgPSAzNjI0MzYwNjksXG4gICAgICAgIHogPSA1MjEyODg2MjksXG4gICAgICAgIHcgPSA4ODY3NTEyMyxcbiAgICAgICAgdiA9IDg4Njc1NjQ1MyxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICBzZWVkLFxuICAgICAgICB0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc2VlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc2VlZCA9IHNlZWRzW2ldO1xuICAgICAgICB4IF49IF9tYXNoKHNlZWQpICogMHgxMDAwMDAwMDA7XG4gICAgICAgIHkgXj0gX21hc2goc2VlZCkgKiAweDEwMDAwMDAwMDtcbiAgICAgICAgeiBePSBfbWFzaChzZWVkKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgICB2IF49IF9tYXNoKHNlZWQpICogMHgxMDAwMDAwMDA7XG4gICAgICAgIHcgXj0gX21hc2goc2VlZCkgKiAweDEwMDAwMDAwMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1aW50MzI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQgPSAoeCBeICh4ID4+PiA3KSkgPj4+IDA7XG4gICAgICAgICAgICB4ID0geTtcbiAgICAgICAgICAgIHkgPSB6O1xuICAgICAgICAgICAgeiA9IHc7XG4gICAgICAgICAgICB3ID0gdjtcbiAgICAgICAgICAgIHYgPSAodiBeICh2IDw8IDYpKSBeICh0IF4gKHQgPDwgMTMpKSA+Pj4gMDtcbiAgICAgICAgICAgIHJldHVybiAoKHkgKyB5ICsgMSkgKiB2KSA+Pj4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICByYW5kb206IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnVpbnQzMigpICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDtcbiAgICAgICAgfSxcblxuICAgICAgICBmcmFjdDUzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yYW5kb20oKSArIChzZWxmLnVpbnQzMigpICYgMHgxZmZmZmYpICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5Yb3JzaGlmdCA9IHtcbiAgICBjcmVhdGU6IGNyZWF0ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYb3JzaGlmdDsiLCIoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvYXJyYXlzLmpzXCIpO1xuXG59KCkpOyIsIihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuKiBUT0RPXG4qIC0gc29tZSBtb3ppbGxhIGZ1bmN0aW9ucyB1c2UgLmNhbGwgYnV0IHRoaXNwIGNvdWxkIGJlIFwidW5kZWZpbmVkXCIgc28gLT4gY2FuIGJlIHJlcGxhY2VkIGJ5IGRpcmVjdCBjYWxsID8hXG4qXG4qL1xuXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgX19jbG9uZSxcbiAgICAgICAgX19yZmlsdGVyO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFycmF5IGdpdmVuIGFueSB0eXBlIG9mIGFyZ3VtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01peGVkfSBpdGVtXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzLml6ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpdGVtLCBcImNhbGxlZVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIGRlYWwgd2l0aCBJdGVyYWJsZSBvYmplY3RzIGxpa2UgQ29sbGVjdGlvbnMhXG5cbiAgICAgICAgcmV0dXJuIFsgaXRlbSBdO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5mcm9tID0gQXJyYXkuaXplO1xuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGFueSBnaXZlbiBudW1iZXIgb2YgYXJyYXlzIGludG8gYSBuZXcgb25lXG4gICAgICogQHRvZG8gc3VwcG9ydCBhbnkgdHlwZSBvZiBhcmd1bWVudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgICAgYXI7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXIgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChhcltqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvbmUgKGNvdWxkIGJlIHJlY3Vyc2l2ZSkgYSBkZW5zZSBhcnJheVxuICAgICAqIE5vdGU6IG9ubHkgbG9vcCBhcnJheXMgbm90IG9iamVjdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBBcnJheSBhclxuICAgICAqIEBwYXJhbSBCb29sZWFuIGRlZXBcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMuY2xvbmUgPSBfX2Nsb25lID0gZnVuY3Rpb24gKGFyLCBkZWVwKSB7XG4gICAgICAgIHZhciBpID0gYXIubGVuZ3RoLFxuICAgICAgICAgICAgY2xvbmUgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChkZWVwICYmIGFyW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZVtpXSA9IF9fY2xvbmUoYXJbaV0sIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbG9uZVtpXSA9IGFyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhbiBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyXG4gICAgICogQHBhcmFtIHtNaXhlZH0gbyBUaGUgb2JqZWN0IHRvIGFkZFxuICAgICAqIEBwYXJhbSB7aW50fSBpbmRleCBUaGUgaW5kZXggcG9zaXRpb24gdGhlIGVsZW1lbnQgaGFzIHRvIGJlIGluc2VydGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvIGlzIHN1Y2Nlc3NmdWxseSBpbnNlcnRlZFxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzLmluc2VydEF0ID0gZnVuY3Rpb24gKGFyLCBvLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPiAtMSAmJiBpbmRleCA8PSBhci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFyLnNwbGljZShpbmRleCwgMCwgbyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYSByYW5kb20gdmFsdWUsIHRoZSBhcnJheSBtdXN0IGJlIGRlbnNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcmV0dXJucyB7TWl4ZWR9XG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMucmFuZG9tID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICB2YXIgbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYXJyW2xdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFycmF5IHJlbW92aW5nIGR1cGxpY2F0ZWQgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMudW5pcXVlID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChyZXQuaW5kZXhPZihhcnJbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGFycltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzb3J0IGFuIGFycmF5IChtdXN0IGJlIGRlbnNlKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzLnNvcnRPYmplY3QgPSBmdW5jdGlvbiAoYXJyLCBrZXkpIHtcbiAgICAgICAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSAodHlwZW9mIGFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS52YWx1ZS50b0xvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoYi52YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhW2tleV0gLSBiW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNodWZmbGVzIChyYW5kb21pemVzIHRoZSBvcmRlciBvZiB0aGUgZWxlbWVudHMgaW4pIGFuIGFycmF5LlxuICAgICAqIGNyZWRpdHMgLSAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNDUwOTU0L2hvdy10by1yYW5kb21pemUtYS1qYXZhc2NyaXB0LWFycmF5XG4gICAgICogQG5vdGUgR2l2ZW4gYXJyYXkgaXMgbW9kaWZpZWQhXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzLnNodWZmbGUgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgdGVtcG9yYXJ5VmFsdWUsXG4gICAgICAgICAgICByYW5kb21JbmRleDtcblxuICAgICAgICAvLyBXaGlsZSB0aGVyZSByZW1haW4gZWxlbWVudHMgdG8gc2h1ZmZsZS4uXG4gICAgICAgIHdoaWxlICgwICE9PSBjdXJyZW50SW5kZXgpIHtcblxuICAgICAgICAgICAgLy8gUGljayBhIHJlbWFpbmluZyBlbGVtZW50Li5cbiAgICAgICAgICAgIHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCAtPSAxO1xuXG4gICAgICAgICAgICAvLyBBbmQgc3dhcCBpdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICAgICAgICB0ZW1wb3JhcnlWYWx1ZSA9IGFycltjdXJyZW50SW5kZXhdO1xuICAgICAgICAgICAgYXJyW2N1cnJlbnRJbmRleF0gPSBhcnJbcmFuZG9tSW5kZXhdO1xuICAgICAgICAgICAgYXJyW3JhbmRvbUluZGV4XSA9IHRlbXBvcmFyeVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlYWNoIHZhbHVlIGluIHRoZSBhcnJheSBwYXNzaW5nIHRoZW0gdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCBhbGwgdGhlIGNhbGxiYWNrIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMucmZpbHRlciA9IF9fcmZpbHRlciA9IGZ1bmN0aW9uIChhcnIsIGZ1biAvKiwgdGhpc3AgKi8pIHtcbiAgICAgICAgaWYgKGFyciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBPYmplY3QoYXJyKSxcbiAgICAgICAgICAgIGxlbiA9IHQubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgcmVzLFxuICAgICAgICAgICAgdGhpc3AsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgcjtcblxuICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZnVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gdCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRbaV07IC8vIGluIGNhc2UgZnVuIG11dGF0ZXMgdGhpc1xuICAgICAgICAgICAgICAgIHIgPSBmdW4uY2FsbCh0aGlzcCwgdmFsLCBpLCB0KTtcbiAgICAgICAgICAgICAgICBpZiAociAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmNodW5rID0gZnVuY3Rpb24gKGFyciwgc2l6ZSwgcHJlc2VydmVfa2V5cykge1xuICAgICAgICBwcmVzZXJ2ZV9rZXlzID0gcHJlc2VydmVfa2V5cyB8fCBmYWxzZTtcblxuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGNodW5rcyA9IFtbXV07XG5cbiAgICAgICAgLy93aGlsZSggQGxpc3QoICRrZXksICR2YWx1ZSApID0gQGVhY2goIGFyciApICkge1xuICAgICAgICBmb3IgKGtleSA9IDA7IGtleSA8IGFyci5sZW5ndGg7ICsra2V5KSB7XG4gICAgICAgICAgICB2YWwgPSBhcnJba2V5XTtcblxuXG4gICAgICAgICAgICBpZiAoY2h1bmtzW2ldLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVfa2V5cykge1xuICAgICAgICAgICAgICAgICAgICBjaHVua3NbaV1ba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1tpXS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goW10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlX2tleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW2ldW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW2ldW2pdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSB2YWx1ZXMgZnJvbSBhIHNpbmdsZSBjb2x1bW4gb2YgdGhlIGFycmF5LW9mLW9iamVjdHMvYXJyYXlzLCBpZGVudGlmaWVkIGJ5IHRoZSBjb2x1bW5fa2V5LlxuICAgICAqIE9wdGlvbmFsbHksIHlvdSBtYXkgcHJvdmlkZSBhbiBpbmRleF9rZXkgdG8gaW5kZXggdGhlIHZhbHVlcyBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgYnkgdGhlIHZhbHVlcyBmcm9tIHRoZSBpbmRleF9rZXkgY29sdW1uIGluIHRoZSBpbnB1dCBhcnJheS5cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cy5jb2x1bW4gPSBmdW5jdGlvbiAoYXJyLCBmaWVsZCkge1xuICAgICAgICByZXR1cm4gQXJyYXkucmZpbHRlcihhcnIsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ID8geFtmaWVsZF0gOiB1bmRlZmluZWQ7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwZW5kIGFueSBudW1iZXIgb2YgYXJyYXlzIGludG8gdGhlIGZpcnN0IG9uZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZHN0XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzLmNvbWJpbmUgPSBmdW5jdGlvbiAoZHN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGFyO1xuXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhcmd1bWVudHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGFyID0gYXJndW1lbnRzW2pdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkc3QucHVzaChhcltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvdW50cyBhbGwgdGhlIHZhbHVlcyBvZiBhbiBhcnJheVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzLmNvdW50VmFsdWVzID0gZnVuY3Rpb24gKGFyciwgY2kpIHtcbiAgICAgICAgY2kgPSBjaSB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBjb3VudGVyID0ge30sXG4gICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFsID0gYXJyW2ldO1xuICAgICAgICAgICAgaWYgKGNpICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWwpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvdW50ZXJbdmFsXSkge1xuICAgICAgICAgICAgICAgICsrY291bnRlclt2YWxdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW3ZhbF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgYXJyYXkgcGFkZGVkIHRvIHNpemUgc3BlY2lmaWVkIGJ5IHNpemUgd2l0aCB2YWx1ZSB2YWx1ZS4gSWYgc2l6ZSBpcyBwb3NpdGl2ZSB0aGVuIHRoZSBhcnJheSBpcyBwYWRkZWQgb24gdGhlIHJpZ2h0LCBpZiBpdFwicyBuZWdhdGl2ZSB0aGVuIG9uIHRoZSBsZWZ0LiBJZiB0aGUgYWJzb2x1dGUgdmFsdWUgb2Ygc2l6ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdGhlbiBubyBwYWRkaW5nIHRha2VzIHBsYWNlXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMucGFkID0gZnVuY3Rpb24gKGFyciwgc2l6ZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHNpemUpIDw9IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbjtcblxuICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7ICBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gaSA8IGFyci5sZW5ndGggPyBhcnJbaV0gOiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSBNYXRoLmFicyhzaXplKTtcbiAgICAgICAgICAgIGxlbiA9IHNpemUgLSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgIGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBpIDwgbGVuID8gdmFsdWUgOiBhcnJbaSAtIGxlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwcm9kdWN0IG9mIHZhbHVlcyBpbiBhbiBhcnJheVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzLnByb2R1Y3QgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIHZhciBzdW0gPSAxLFxuICAgICAgICAgICAgbGVuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKj0gcGFyc2VGbG9hdChhcnJbaV0pOyAvLyBiZSBzdXJlIGl0XCJzIGEgbnVtYmVyLi5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQaWNrcyBvbmUgb3IgbW9yZSByYW5kb20gZW50cmllcyBvdXQgb2YgYW4gYXJyYXksIGFuZCByZXR1cm5zIHRoZSBrZXkgKG9yIGtleXMpIG9mIHRoZSByYW5kb20gZW50cmllcy5cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cy5yYW5kID0gZnVuY3Rpb24gKGFyciwgbGVuKSB7XG4gICAgICAgIHZhciBvdXQgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGxlbiA9IGxlbiB8fCAxO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgb3V0LnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuZGVuc2UgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcblxuICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBvdXQucHVzaCh2YWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5zdW0gPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIHZhciBzdW0gPSAwLFxuICAgICAgICAgICAgbGVuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gcGFyc2VGbG9hdChhcnJbaV0pOyAvLyBiZSBzdXJlIGl0XCJzIGEgbnVtYmVyLi5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbGwgYW4gYXJyYXkgd2l0aCB2YWx1ZXNcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cy5maWxsID0gZnVuY3Rpb24gKHN0YXJ0LCBjb3VudCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGFyciA9IFtdLFxuICAgICAgICAgICAgbGVuID0gc3RhcnQgKyBjb3VudCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZXMgZnJvbSBhIHNpbmdsZSBjb2x1bW4gaW4gdGhlIGlucHV0IGFycmF5XG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMuY29sdW1uID0gZnVuY3Rpb24gKGFyciwgZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIF9fcmZpbHRlcihhcnIsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4W2ZpZWxkXTsgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGtleXMgZ2l2ZW4gYSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0XG4gICAgICogQHRocm93cyBpZiB0aGUgZmllbGQgaXMgdW5kZWZpbmVkIVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzLmttYXAgPSBmdW5jdGlvbiAoYXJyLCBmaWVsZCkge1xuICAgICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICghdltmaWVsZF0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh2KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWVsZCBub3QgZm91bmQgaW4gdlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0W3ZbZmllbGRdXSA9IHY7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuXG4gICAgbW9kdWxlLmV4cG9ydHMub0ZpbHRlciA9IGZ1bmN0aW9uIChhcnIsIG9iaikge1xuICAgICAgICBpZiAoIWFycikgcmV0dXJuIFtdO1xuXG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIG1heCA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1heDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldKSB7XG4gICAgICAgICAgICAgICAgZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChqIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldW2pdICE9PSBvYmpbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChhcnJbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGtleSBvZiB0aGUgb2JqZWN0IGNvbnRhaW5lZCBpbiB0aGUgYXJyYXkgdGhhdCBoYXMgdGhlIHNhbWUgdmFsdWUgaW4gZ2l2ZW4ga2V5LlxuICAgICAqIEB0aHJvd3MgaWYgdGhlIGZpZWxkIGlzIHVuZGVmaW5lZCFcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiAoYXJyLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghYXJyIHx8ICFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG1heCA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1heDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldICYmIGFycltpXVtrZXldID09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuXG4gICAgbW9kdWxlLmV4cG9ydHMubWFwQXN5bmMgPSBmdW5jdGlvbiAoYXJyLCBjYWxsYmFjaywgZG9uZWNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICghYXJyIHx8ICFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZWNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG1heCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICBkb25lX2NvdW50ID0gMCxcbiAgICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgICAgZG9uZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0Lmxlbmd0aCA9PT0gMCAmJiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0ge307XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm8gZmlyc3RcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkgfHwgZG9uZV9jb3VudDtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IHZhbHVlO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoKytkb25lX2NvdW50ID09PSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZWNhbGxiYWNrKHJldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWF4OyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBhcnJbaV0sIGksIGRvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhhcnJbaV0sIGksIGRvbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMubWFwU2VyaWFsID0gZnVuY3Rpb24gKGFyciwgY2FsbGJhY2ssIGRvbmVjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBpZiAoIWFyciB8fCAhYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmVjYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbWF4ID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgcmV0IHRvIG9iamVjdCBpZiBmaXJzdCBjYWxsIGhhcyBrZXlcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0ge307XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAvLyBubyBmaXJzdFxuICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleSB8fCBpO1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjaSA9IGksXG4gICAgICAgICAgICAgICAgICAgIGN0ID0gYXJyW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCsraSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZWNhbGxiYWNrKHJldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNBcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBjdCwgY2ksIG5leHQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY3QsIGNpLCBuZXh0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZCA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkgfHwgaTtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgZG9uZWNhbGxiYWNrKHJldCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xufSgpKTsiLCIoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvb2JqZWN0cy5qc1wiKTtcblxufSgpKTsiLCIoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgaGFzRG9udEVudW1CdWcgPSAhKHt0b1N0cmluZzogbnVsbH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwidG9TdHJpbmdcIiksXG4gICAgICAgIGRvbnRFbnVtcyA9IFtcbiAgICAgICAgICAgIFwidG9TdHJpbmdcIixcbiAgICAgICAgICAgIFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICAgICAgICAgIFwidmFsdWVPZlwiLFxuICAgICAgICAgICAgXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICAgICAgXCJpc1Byb3RvdHlwZU9mXCIsXG4gICAgICAgICAgICBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsXG4gICAgICAgICAgICBcImNvbnN0cnVjdG9yXCJcbiAgICAgICAgXSxcbiAgICAgICAgZG9udEVudW1zTGVuZ3RoID0gZG9udEVudW1zLmxlbmd0aCxcbiAgICAgICAgQXJyYXlQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2gsXG4gICAgICAgIE9iamVjdENvbnN0cnVjdG9yID0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgX190eXBlb2YsXG4gICAgICAgIF9fbWVyZ2UsXG4gICAgICAgIF9fZGVwdGgsXG4gICAgICAgIF9fcmZpbHRlcixcbiAgICAgICAgX19kZWJ1ZyA9IHRydWU7XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcInR5cGVvZlwiXSA9IF9fdHlwZW9mID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9udCBkZWFsIHdpdGggdW5kZWZpbmUuLi5cbiAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIGZvciBwZXJmb3JtYW5jZSwgd2UgY2hlY2sgaWYgaXRcInMgYSBwbGFpbiBvYmplY3QgZmlyc3RcbiAgICAgICAgICAgIGlmICh0eXBlLmNvbnN0cnVjdG9yID09PSBPYmplY3RDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsLnB1c2ggPT09IEFycmF5UHVzaCAmJiB2YWwubGVuZ3RoICE9IG51bGwpIHsgLy8gIT0gbnVsbCBpcyBvayFcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlLCBJIHdpbGwga2VlcCB0aGlzIGluc2VjdXJlXG4gICAgICAgICAgICAvLyBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIFwiY2FsbGVlXCIpKSB7XG4gICAgICAgICAgICBpZiAodmFsLmhhc093blByb3BlcnR5ICYmIHZhbC5oYXNPd25Qcm9wZXJ0eShcImNhbGxlZVwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImFyZ3VtZW50c1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicmVnZXhwXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2Ygc29tZXRoaW5nP1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gT2JqZWN0XG4gICAgLy9cblxuICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2tleXNcbiAgICBpZiAoIU9iamVjdC5rZXlzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgKHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIiB8fCBvYmogPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC5rZXlzIGNhbGxlZCBvbiBub24tb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sIHByb3AsIGk7XG5cbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRvbnRFbnVtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZG9udEVudW1zW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9udEVudW1zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBpZiBub3QgZm91bmQsIG5vIGZ1bmN0aW9uYWxpdHkganVzdCBhIHJlcGxhY2VtZW50IHNvIHlvdXIgY29kZSBub3QgdGhyb3chXG4gICAgaWYgKCFPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgbmFtZSwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKHByb3AuZ2V0IHx8IHByb3Auc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIganMuZW5naW5lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW25hbWVdID0gcHJvcC52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIC8vIGRlZmluZSBPYmplY3Quc2VhbCBpZiBub3QgZm91bmQsIG5vIGZ1bmN0aW9uYWxpdHkganVzdCBhIHJlcGxhY2VtZW50IHNvIHlvdXIgY29kZSBub3QgdGhyb3chXG4gICAgaWYgKCFPYmplY3Quc2VhbCkge1xuICAgICAgICBPYmplY3Quc2VhbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoX19kZWJ1Zykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgKHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIiB8fCBvYmogPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC52YWx1ZXMgY2FsbGVkIG9uIG5vbi1vYmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICghX19kZWJ1ZyB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmpbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGtleXMgb2YgYW4gb2JqZWN0IChvciBhbnl0aGluZyBpdGVyYWJsZSBmb3IuLi5pbikgbm90ZTogcmVtb3ZlIHByb3RvdHlwZSBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9fZWFjaChvYmplY3QsIGZuKSB7XG4gICAgICAgIHZhciBrZXkgPSBudWxsO1xuXG4gICAgICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgZm4ob2JqZWN0W2tleV0sIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzLmVhY2ggPSBfX2VhY2g7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5mb3JFYWNoID0gX19lYWNoO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBfX21lcmdlKHt9LCBvYmosIHRydWUsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbWVyZ2UgdHdvIG9iamVjdFxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW1zIHtPYmplY3R9IHRvLCB0aGlzIHBhcmFtZXRlciBpcyBtb2RpZmllZFxuICAgICAqIEBwYXJhbXMge09iamVjdH0gZnJvbVxuICAgICAqIEBwYXJhbXMge0Jvb2xlYW59IGNsb25lXG4gICAgICogQHBhcmFtcyB7Qm9vbGVhbn0gbXVzdF9leGlzdHMgZG8gbm90IGFsbG93IHVuZGVmaW5lZCBpbiB0aGUgb2JqZWN0c1xuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzLm1lcmdlID0gX19tZXJnZSA9IGZ1bmN0aW9uICh0bywgZnJvbSwgY2xvbmUsIG11c3RfZXhpc3RzKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJPYmplY3QubWVyZ2VcIiwgZnJvbSk7XG4gICAgICAgIGNsb25lID0gY2xvbmUgfHwgZmFsc2U7XG4gICAgICAgIG11c3RfZXhpc3RzID0gbXVzdF9leGlzdHMgfHwgZmFsc2U7XG5cbiAgICAgICAgdmFyIGZ0eXBlID0gX190eXBlb2YoZnJvbSksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICByZXQ7XG5cbiAgICAgICAgc3dpdGNoIChmdHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmUgPyBcIlwiICsgZnJvbSA6IGZyb207XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBjbG9uZSA/IDAgKyBmcm9tIDogZnJvbTtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6IC8vIG1heWJlIG5lZWQgbW9yZSBkZWVwIGNsb25lID9cblxuICAgICAgICAgICAgaWYgKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgPSAwOyBrZXkgPCBmcm9tLmxlbmd0aDsgKytrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBfX21lcmdlKHRvW2tleV0gfHwge30sIGZyb21ba2V5XSwgY2xvbmUsIG11c3RfZXhpc3RzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnJvbTtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBjbG9uZSA/IChmcm9tID8gdHJ1ZSA6IGZhbHNlKSA6IGZyb207XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gZnJvbTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgLy8gdG8gaXQgbm90IGFuIG9iamVjdCwgb3ZlcndyaXRlIVxuICAgICAgICAgICAgcmV0ID0gX190eXBlb2YodG8pICE9PSBcIm9iamVjdFwiID8ge30gOiB0byB8fCB7fTtcbiAgICAgICAgICAgIC8vIGlmIGhhcyBwcm90b3R5cGUganVzdCBjb3B5XG4gICAgICAgICAgICBrZXkgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11c3RfZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gX19tZXJnZShyZXRba2V5XSB8fCB7fSwgZnJvbVtrZXldLCBjbG9uZSwgbXVzdF9leGlzdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgY2FzZSBcInJlZ2V4cFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoZnJvbS5zb3VyY2UpO1xuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGNsb25lID8gbmV3IERhdGUoZnJvbSkgOiBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVua25vd24gdHlwZS4uLiBqdXN0IHJldHVyblxuICAgICAgICByZXR1cm4gZnJvbTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuY29tYmluZSA9IGZ1bmN0aW9uIChrZXlzLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzIHx8IFtdO1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHJldCA9IHt9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXRba2V5c1tpXV0gPSB2YWx1ZXNbaV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMua3NvcnQgPSBmdW5jdGlvbiAoZnJvbSkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHJldCA9IHt9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXRba2V5c1tpXV0gPSBmcm9tW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICAgICAgbyxcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuO1xuXG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBvICYmIG8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHAgaW4gbykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBvW3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiAoZnJvbSwga2V5cywgZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHJldCA9IHt9O1xuXG4gICAgICAgIGRlZmF1bHRfdmFsdWUgPSBkZWZhdWx0X3ZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVmYXVsdF92YWx1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmV0W2tleXNbaV1dID0gZnJvbVtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdF92YWx1ZSA6IGZyb21ba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5lbXB0eSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuZGVwdGggPSBfX2RlcHRoID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgIHByb3BzID0gZmFsc2UsXG4gICAgICAgICAgICBkID0gMDtcblxuICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIC8vIGFycmF5XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG1heCA9IG9iai5sZW5ndGg7IGkgPCBtYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGQgPSBNYXRoLm1heChkLCBfX2RlcHRoKG9ialtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMgPSBtYXggPiAwO1xuICAgICAgICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBvYmopIHtcbiAgICAgICAgICAgIC8vIG9iamVjdFxuXG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGQgPSBNYXRoLm1heChkLCBfX2RlcHRoKG9ialtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChwcm9wcyA/IDEgOiAwKSArIGQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzLnJGaWx0ZXIgPSBfX3JmaWx0ZXIgPSBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaywgbG9vcF9hcnJheXMpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBtYXg7XG4gICAgICAgIGxvb3BfYXJyYXlzID0gbG9vcF9hcnJheXMgPT09IHRydWU7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgICAgIGlmICghbG9vcF9hcnJheXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBjYWxsYmFjayhvYmopO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBtYXggPSBvYmoubGVuZ3RoOyBpIDwgbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2ldID0gX19yZmlsdGVyKG9ialtpXSwgY2FsbGJhY2ssIGxvb3BfYXJyYXlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9iaikge1xuICAgICAgICAgICAgLy8gb2JqZWN0XG4gICAgICAgICAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBEYXRlIHx8IG9iaiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcblxuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2ldID0gX19yZmlsdGVyKG9ialtpXSwgY2FsbGJhY2ssIGxvb3BfYXJyYXlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhvYmopO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5wcmVmaXhLZXlzID0gZnVuY3Rpb24gKG9iaiwgcHJlZml4LCBpZ25vcmVfa2V5cykge1xuICAgICAgICBpZ25vcmVfa2V5cyA9IGlnbm9yZV9rZXlzIHx8IFtdO1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHJldCA9IHt9O1xuXG4gICAgICAgIGlmIChpZ25vcmVfa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlX2tleXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W3ByZWZpeCArIGldID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtpXSA9IG9ialtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0W3ByZWZpeCArIGldID0gb2JqW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMucmVtUHJlZml4S2V5cyA9IGZ1bmN0aW9uIChvYmosIHByZWZpeCwgaWdub3JlX2tleXMpIHtcbiAgICAgICAgaWdub3JlX2tleXMgPSBpZ25vcmVfa2V5cyB8fCBbXTtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBwcmVmaXhfbGVuID0gcHJlZml4Lmxlbmd0aCxcbiAgICAgICAgICAgIHJldCA9IHt9O1xuXG4gICAgICAgIGlmIChpZ25vcmVfa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlX2tleXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbaS5zdWJzdHJpbmcocHJlZml4X2xlbildID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaS5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2kuc3Vic3RyaW5nKHByZWZpeF9sZW4pXSA9IG9ialtpXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRbaV0gPSBvYmpbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG5cbiAgICBtb2R1bGUuZXhwb3J0cy5kaWZmID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgcmV0ID0ge30sXG4gICAgICAgICAgICBhcmdsID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGsxLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGZvdW5kO1xuXG4gICAgICAgIGZvciAoazEgaW4gb2JqKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ2wgJiYgIWZvdW5kOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW2sxXSA9PT0gYXJndW1lbnRzW2ldW2sxXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldFtrMV0gPSBvYmpbazFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgfTtcblxufSgpKTsiXX0=
